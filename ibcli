#!/usr/bin/perl
#
# (c) Copyright: Geoff horne, SLC 2001-2003
#               All rights reserved
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. So there...
#
# THIS TICKET IS SOLD SUBJECT TO THE SELLERS CONDITIONS OF SALE OF COPY
# WHICH IS AVAILABLE FOR INSPECTION AT TIME OF PURCHASE AND/OR CONDITIONS
# OF THIS TICKET AND ALSO (TO THE EXTENT THAT THEY ARE NOT INCONSISTENt
# WITH THE SELLERS CONDITIONS OF SALE) THE FOLLOWING:
# 
# 1: A CHANGE IN CONDITIONS OF THE PURCHASER DOES NOT ENTITLE THE PURCHASER
#    TO RETURN OR EXCHANGE TICKET.
# 
# 2: THE SELLER RESERVES THE RIGHT TO:
#    - ADD, WITHDRAW OR SUBSTITUTE ARTISTS
#    - VARY ADVERTISED PROBRAMMES, SEATING ARRANGEMENT AND AUDIENCE
#      CAPACITY , AND:
#    - REFUSE ADMISSION WITH REASONABLE CAUSE
#
# 3: CAMERAS AND TAPE RECORDERS MAY NOT BE PERMITTED. LATE ARRIVALS MAY
#    RESULT IN NON-ADMITTANCE UNTIL A SUITABLE BREAK IN PERFORMANCE. THE
#    SELLER REQUESTS THAT ALL PAGERS AND MOBILE PHONES BE TURNED OFF BEFORE
#    ENTRY.
#
# 4: IF AN OUTDOOR PERFORMANCE IS CANCELLED DUE TO ADVERSE WEATHER OR ANy
#    OTHER CAUSE REASONABLY BEYOND THE SELLERS CONTROL, THERE IS NO RIGHT 
#    TO A REFUND OR EXCHANGE, AND THE SELLER IS NOT OBLIGED TO ARRANGE A 
#    SUBSTITUTE SERVICE, EVENT OR PERFORMANCE
#
# StreetLevel Communications
#
#            support@slc.com.au
#            ph: +1-650-483-0998
#
###############################################################################


# $Id: ibcli,v 1.7 2003/09/22 19:24:30 horne Exp $
# $Revision: 1.7 $
# $Date: 2003/09/22 19:24:30 $
#

# Perl CGI common chunks
#
use strict ;
no strict "refs" ;
use Getopt::Long ;
use Text::Abbrev ;



# include infoblox
use InfoBloxDNS ;

#### work out where i am
# these 3 varables can then be used to find config files
# and keep the code portable

use FindBin qw($Bin $Script);
my ($BASE,$NAME)=($Bin,$Script) ;

######################
#
# define some globals
#
my $DEBUG = 0 ;
my $CLI = 0 ;
my $CONN_STRING = "!" ;

my $SERVER_ID ;
my $SERVER_PASS ;
my $CONNECTED ;
my $CONFIG ;

my $GOOD_COMMAND ;
my $LINE ;
# my $NO_COMMAND ;
my $SAVE_HIST ;
my @CLIST ;
my @WORDS ;
my @P_ARGS ;
my @HISTORY ;

my $PROMPT ;

#
# WTF is P_ARGS ??
#
# Well, grasshopper, some subroutines need to know some of the earlier
# arguments, so we keep these in a stack and pass them around where
# necessary. it is a global because all sorts of subs will want to play
# with it...
#

#
#####################

# read the lines
# the datastructure is kinda nested, but the command set is still small
# enough to avoid some sort of lexical overhead subroutine

## NOTE - to make a better CLI version we should have a wrapper loop that
#  checks if you are coming in as a file or STD in. The primary loop in
#  either case should pass to the actual arg parser
#

# optional args
# -f <config file>
# -s <server>
# -p <password>
# -d <debug level>

GetOptions(
      "s=s" => \$SERVER_ID , 
      "p=s" => \$SERVER_PASS ,
      "f=s" => \$CONFIG ,
      "d=s" => \$DEBUG ,
   );

   #

# check if we need to do any initial conections
if ( $SERVER_ID ) { &add_server($SERVER_ID) }
else              { $PROMPT = "no server > " ; }

if ( $SERVER_PASS ) { &add_pass($SERVER_PASS) }

#
# are we interactive or in batch mode ?
#
if ( ! $CONFIG ) {
   print "CLI version\n";
   $CLI = 1 ;
   # unflush the buffer
   $| = 1 ;

   # set initial prompt
   &print_prompt ;
}

if ( $CONFIG ) { 
   # make 'while(<>)' still work...
   push @ARGV , $CONFIG  ;
}

#
# time to read commands, line at a time...
#

while (<>) {

   # strip blanks, comments etc
   if ( /^\s*#/ ) { &print_prompt ; next ; } ;
   if ( /^\s*$/ ) { &print_prompt ; next ; } ;

   $GOOD_COMMAND = 1 ;
   $SAVE_HIST = "" ;

   chomp ;

   #
   # Pattern matching, we want 'fuzzy' matches but only in the form of
   # abbreviations, if the command is 'server', 'ser' and 'serv' should
   # match but not 'serf'. FORTUNATELY, there seems to be a perlmodule
   # for this. ( Text::Abbrev )
   #
   # and the nice thing is that we can build up a hash
   # of command to subroutine matching, the abbrev code will
   # find the right command to call, then we can pass the WHOLE line to
   # the required routine.
   #
   # HOWEVER, the additional args at the end of the line will break the
   # abbrev match, so we still need to eat the line - 1 word at a time
   # and branch apropriately
   #
   # if the abbrev gets an ambiguous match, we return '0'...

   # we have a problem in that if we get a match on the first arg we are
   # still in 2 states
   #  - execute
   #  - check for more args
   #  - check for more commands
   #
   # after the branching we still keep track of :
   #  - the original command (for history)
   #  - the optional args
   # and IF WE GET A MATCH, we say the command is good and THEN execute


   # SO break the commandline into components
   #
   # @WORDS is a global, because we want to keep eating the array
   # regardless of what routine we are in. At the end of the parsing, we
   # should end up with the command ($SAVE_HIST) and the args (@WORDS)
   #
   $LINE = $_ ;
   @WORDS  = split /\s+/ ;
   @P_ARGS = () ;
   my $arg = shift @WORDS ;

   my %commands = ( 
                'history' => 'show_history',
                'commit' => 'commit',
                'connect' => 'connect',
                'disconnect' => 'disconnect',
                'set' => 'set_commands' ,
                'configure' => 'set_commands' ,
                'show' => 'show_commands' ,
                'get' => 'show_commands' ,
                'exit' => 'do_exit' ,
        ) ;

   &shift_arg($arg,%commands);

   # history - if kosher
   # ( done at the end, after all other line processing... )
   if ( $GOOD_COMMAND ) {
      &addhistory($SAVE_HIST , @WORDS);
   }

   # lastly - the prompt
   &print_prompt ;
   
}

# just in case
&do_exit ;

################################################################

# 
# EXIT
#
sub do_exit {
    $LINE = "exit" ;
    if ( $CONNECTED ) { 
       &commit ;
       &disconnect ;
    }

    exit ;
}

#
# shift arg, once we've set up a new %commands hash
# we just want to call shift_arg to do the rest of the processing
#
# THIS is the guts of the command line parser, for each ARG in a line
# shift_arg looks at this word, does an apprev match, and if it is ok
# then calles the hashed subroutine.
#
# The nice thing about this is that the subroutines can either be end
# points (do this feature) or subroutines that set possibilities for the
# next arg value. This has more power then putting ALL the commands in a
# treed hash since we can jump around tween subs as much as we like
#
# [ you just have to keep track of the parser subroutines :-) ]
#
sub shift_arg {

   my ( $arg , %commands ) = @_ ;

   @CLIST = sort keys %commands ;
   my %clookup = abbrev ( @CLIST ) ;

   # $full_comm does the abbreviation lookup and gets the
   # ACTUAL full comand name, or returns '0' so the expansion
   # is automatic, but sometimes full_comm can be a wildcard
   # so we check the existence of the subroutine to call instead.
   #
   # and we hack history accordingly
   
   my $full_comm = $clookup{ lc($arg) };
   &debug (4,"shift: h($SAVE_HIST) arg($arg) com[$full_comm]");

   # we set $call_sub , cos we risk re-setting $full_com ;
   my $call_sub = $commands{$full_comm} ;
   if ( $call_sub ) {
      &debug (4,"shift: sub($call_sub)");

      # catch wildcards...
      if ( ! $full_comm ) { 
         $full_comm = $arg  ;
         push @P_ARGS , $arg ;
      }
      $SAVE_HIST .= "$full_comm " ;

      &rd_line($call_sub) ;
   }
   else {
      &missing_arg(@CLIST)  ;
   }
}

# PARSER : show xxx
sub show_commands {
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                'zone' => 'show_zone',
                'network' => 'show_zone',
                'host' => 'show_host',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set xxx
sub set_commands {
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                'debug' => 'set_debug',
                'server' => 'add_server',
                'system' => 'system_comands',
                'password' => 'add_pass',
                'zone' => 'zone_commands',
                'network' => 'network_commands',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : set system xxx
sub system_comands {
   &debug (4,"sub = zone_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "default" => 'erase_data',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set zone xxx
sub zone_commands {
   &debug (4,"sub = zone_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_zone',
                "delete" => 'remove_zone',
                "remove" => 'remove_zone',
                "" => 'mod_zone',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network xxx
sub network_commands {
   &debug (4,"sub = network_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_network',
                "delete" => 'remove_network',
                "remove" => 'remove_network',
                "" => 'mod_network',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network <n.n.n.n/mm> xxx
sub mod_network {
   &debug (4,"sub = mod_net ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "split" => 'split_network',
                "add" => 'add_to_network',
                "remove" => 'remove_network',
                "delete" => 'remove_network',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network <n.n.n.n/mm> add xxx
sub add_to_network {
   &debug (4,"sub = mod_net ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "address" => 'add_network_ptr',
                "network" => 'add_sub_network',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set zone <zone> xxx
sub mod_zone {
   &debug (4,"sub = mod_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_to_zone',
                "delete" => 'remove_from_zone',
                "remove" => 'remove_from_zone',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : set zone <zone> add xxx
sub add_to_zone {
   &debug (4,"sub = add_to_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "host" => 'add_host',
                "cname" => 'add_cname',
                "onewayhost" => 'add_one_host',
                "bulkhost"   => 'add_bulkhost',
                "nameserver" => 'NOT_READY',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set zone <zone> remove xxx
sub remove_from_zone {
   &debug (4,"sub = remove_from_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "host" => 'remove_host',
                "cname" => 'remove_cname',
                "bulkhost" => 'remove_bulkhost',
                "nameserver" => 'NOT_READY',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : default
sub NOT_READY {
    print "***-  NOT IMPLEMENTED\n";
}

###########################################
#
# here endith the arg parsers
#
###########################################

#
# call an infoblox function, ONLY if we're connected
#
sub do_ib_func {
    my ($function) = @_ ;
    &debug (3,"do_ib_func [$function]");

    if ( $CONNECTED ) {
       eval $function ;
    }
    else {
       &err_print("CANNOT EXECUTE - no connection is in place");
    }
}


###########################################
#
# actual ib_ functions.
#
###########################################

sub erase_data {

    &err_print("ERASING ALL DATABASE data ...");

    # we may want an 'are you sure here...'
    my $function = "ib_erase_dns_data()";
    &do_ib_func($function);

    &err_print("DONE ");
}

sub add_host {
    my ( $zone , $host , $ip ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"addh n($name) n($ip) ");

    my $function = "ib_insert_host(\"$name\",\"$ip\")";
    &do_ib_func($function);

}

sub remove_host {
    my ( $zone , $host ) = @_ ;
    if ( ! $host ) {
       &missing_arg("<host>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"addh n($name) ");

    my $function = "ib_remove_host(\"$name\")";
    &do_ib_func($function);

}

sub add_one_host {
    my ( $zone , $host , $ip ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"add1h n($name) n($ip) ");

    my $function = "ib_insert_oneway_host(\"$name\",\"$ip\")";
    &do_ib_func($function);

}

sub add_bulkhost {
    my ( $zone , $prefix , $fip , $nip ) = @_ ;

    if ( $zone and $prefix and $fip and $nip ) {

       &debug (2,"addbh n($zone) p($prefix) n($fip,$nip) ");

       my $func="ib_insert_bulk_host(\"$zone\",\"$prefix\",\"$fip\",\"$nip\")";
       &do_ib_func($func);
    }
    else {
       &missing_arg("<prefix> <start_ip> <end_ip>")  ;
       return ;
    }

}

sub remove_bulkhost {
    my ( $zone , $prefix , $fip , $nip ) = @_ ;

    if ( $zone and $prefix and $fip and $nip ) {

       &debug (2,"addbh n($zone) p($prefix) n($fip,$nip) ");

       my $func="ib_remove_bulk_host(\"$zone\",\"$prefix\",\"$fip\",\"$nip\")";
       &do_ib_func($func);
    }
    else {
       &missing_arg("<prefix> <start_ip> <end_ip>")  ;
       return ;
    }
}

sub add_cname {
    my ( $zone , $cname , $host ) = @_ ;
    if ( (! $host ) or ( ! $cname ) ) {
       &missing_arg("<cname> <host>")  ;
       return ;
    }
    my $fcname="$cname.$zone";

    &debug (2,"addh n($fcname) n($host) ");

    my $function = "ib_insert_cname(\"$fcname\",\"$host\")";
    &do_ib_func($function);

}

sub remove_cname {
    my ( $zone , $host ) = @_ ;
    if ( ! $host ) {
       &missing_arg("<host>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"addh n($name) ");

    my $function = "ib_remove_cname(\"$name\")";
    &do_ib_func($function);

}

sub add_zone {
    my ( $zone , $type ) = @_ ;

    if ( ! $zone ) { &missing_arg("<zone>") ; return }
    my $etype ;

    #
    # etype is the expanded version of whatever we typed for $type
    #
    if ( $type ) {
       my @opts = ( "authoritative","nonauthoritative","delegated","secondary");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "authoritative" ) ; }

    &debug (2,"addz n($zone) a($etype) ");

    my $function = "ib_insert_zone(\"$zone\",\"$etype\")";
    &do_ib_func($function);

}

sub remove_zone {
    my ( $zone ) = @_ ;
    if ( ! $zone ) { &missing_arg("<zone>") ; return }
    &debug (2,"remz n($zone)");

    my $function = "ib_remove_zone(\"$zone\")";
    &do_ib_func($function);

}

sub add_network_ptr {
    my ( $parent , $ip , $host ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<n.n.n.n/mm> <host> <ip>")  ;
       return ;
    }
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    &debug (2,"addnp n($net) m($mask) ip($ip) h($host)");

    # ib_insert_oneway_ptr(10.0.0.0 , 255.255.0.0 , 10.2.3.4 , foo.com );
    my $func="ib_insert_oneway_ptr(\"$net\",\"$mask\",\"$ip\",\"$host\")";
    &do_ib_func($func);

}

sub add_network {
    my ( $netarg , $type ) = @_ ;
    if ( ! $netarg ) { &missing_arg("<n.n.n.n/mm>") ; return }
    my $etype ;

    #
    # etype is the expanded version of whatever we typed for $type
    # [ I've used this twice now, can i make it a sub ?? ]
    #
    if ( $type ) {
       my @opts = ( "authoritative",,"delegated","secondary");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "authoritative" ) ; }

    #
    # use the /cidr to find the mask etc etc
    #
    my ($net,$cidr) = split(/\//,$netarg);
    my $mask = &cidrfind($cidr) ;

    &debug (2,"addn n($net) c($cidr) m($mask) ");

    # add net now requires a bogus parent
    # not that this will add it at the root level. you need to
    # use add subnet for anything else
    my $func="ib_insert_network(\"$net\",\"$mask\",\"0.0.0.0\",\"0.0.0.0\")";
    &do_ib_func($func);

}

sub add_sub_network {
    my ( $parg , $netarg , $type ) = @_ ;
    if ( ! $netarg ) { &missing_arg("<n.n.n.n/mm>") ; return }
    my $etype ;

    #
    # etype is the expanded version of whatever we typed for $type
    # [ I've used this thrice now, can i make it a sub ?? ]
    #
    if ( $type ) {
       my @opts = ( "authoritative",,"delegated","secondary");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "authoritative" ) ; }

    #
    # use the /cidr to find the mask etc etc
    #
    my ($net,$cidr) = split(/\//,$netarg);
    my ($pnet,$pcidr) = split(/\//,$parg);
    my $mask = &cidrfind($cidr) ;
    my $pmask = &cidrfind($pcidr) ;

    &debug (2,"addsn pn($pnet) pc($pmask) n($net) c($cidr) m($mask) ");

    # add net now requires a bogus parent
    # not that this will add it at the root level. you need to
    # use add subnet for anything else
    my $func="ib_insert_network(\"$net\",\"$mask\",\"$pnet\",\"$pmask\")";
    &do_ib_func($func);

}
sub split_network {
    #
    # the second last arg of ib_split_network is a bitshift RELATIVE
    # to the original mask, so there is some math involved

    my($parent,$ncidr,$type) = @_ ;
    my($pnet,$pcidr)= split(/\//,$parent );
       $ncidr =~ s/\/// ;
    my $pmask = &cidrfind($pcidr);
    my $bitshift = $ncidr - $pcidr ;

    &debug (2,"split net [$pnet] [$pcidr] [$ncidr] ($bitshift)\n");
    &debug (1,"splitting network [$pnet , $pmask] to add [$bitshift] bits");

    # check for optional args...
    my $etype ;
    if ( $type ) {
       my @opts = ( "all","required");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "0" ) ; }
    if ( $etype eq "required" ) { $etype = "1" }
    if ( $etype eq "all" ) { $etype = "2" }

    # ib_split_network("10.0.0.0", "255.255.0.0", 8);
    my $func ;
    $func="ib_split_network(\"$pnet\", \"$pmask\", \"$bitshift\",\"$etype\")";
    &do_ib_func($func);

}

sub remove_network {
    my ( $netarg ) = @_ ;
    if ( ! $netarg ) { &missing_arg("<n.n.n.n/mm>") ; return }

    # use the /cidr to find the mask etc etc
    #
    my ($net,$cidr) = split(/\//,$netarg);
    my $mask = &cidrfind($cidr) ;

    &debug (2,"remn n($net) c($cidr) m($mask) ");

    my $func="ib_remove_network(\"$net\",\"$mask\")";
    &do_ib_func($func);

}


##########################################################
#
# An important thing to note :
#
# what happens if you issue commands and you do NOT have a connection in
# place yet ? do we rely on the infoblox module to generate errors or
# should we assume the worst ? we don't want to re-invent the wheel
# here...
#
#


###########################################3
#

# parse a line, this is called EVERYTIME we press <cr> so we can
# do things like print the prompt
# we abstract this to keep it in one place
#
sub rd_line {

    # we're passed :
    #  the subroutine to call
    #  the subroutine arguments
    #
    #  if we are eating more of the args, we append to savehistory...

    my ($command) = @_ ;

    &debug (4,"rd_line b: c[$command] h[$SAVE_HIST] , go_c [$GOOD_COMMAND]");
    &debug (4,"           p_args[@P_ARGS] words[@WORDS]");

    # call the command (and any prev args...)
    &$command(@P_ARGS,@WORDS);

    #
    &debug (4,"rd_line a: c[$command] h[$SAVE_HIST] , go_c [$GOOD_COMMAND]");
    &debug (4,"           p_args[@P_ARGS] words[@WORDS]");


}

sub missing_arg {
    &debug(4,"MISS ARG call");
    if ( $CLI ) {
       print "Next possible completions : \n\t@_\n";
    }
    else {
       &err_print("UNRECOGNISED command");
    }
    $GOOD_COMMAND = 0 ;
}

#
# PROMPT
#
sub print_prompt {
    if ( $CLI ) {
       print "[$DEBUG] $CONN_STRING $PROMPT" ;
    }
}

#
# ERRORS
#
sub err_print {
    if ( $CLI ) {
       print "@_\n" ;
    }
    else {
#        print "@_\n" ;
#        print "ERROR: @_ : $LINE\n";
       print "@_ : $LINE\n";
    }
}

#
# SET DEBUG
#
sub set_debug {

    if ( "@_" =~ /\d+/ ) {
       $DEBUG = shift @_ ;
    }
    else {
       &missing_arg("$SAVE_HIST <level>");
    }
}

#
# SHOW THE HISTORY:
#

sub addhistory {
    my ($line) = "@_" ;

    #cleanup spacing
    $line =~ s/^\s*//;
    $line =~ s/\s+/ /g;
    $line =~ tr/A-Z/a-z/;

    push @HISTORY , $line ;

}

sub show_history {
    my $lineno = 1 ;

    # walk through the history array and print what we input
    print "\n-- COMMAND HISTORY --\n";
    foreach my $command ( @HISTORY ) {
       print "-- $lineno\t$command\n";
       $lineno ++ ;
    }
    print "\n";

#     $GOOD_COMMAND = 1 ;

}

#
# SERVER CONNECTION STUFF.....
#

sub add_server {
    my ($arg) = @_ ;
    # save the server id and see if we have enough info to connect

    if ($arg) {
       &debug (2,"adding server [$arg]");
       $SERVER_ID = $arg ;

       $PROMPT = "$SERVER_ID > " ;

       &connect ;
    }
    else {
       &missing_arg("$SAVE_HIST <server>");
    }
}

sub add_pass {
    my ($arg) = @_ ;

    if ($arg) {
       # save the server password and see if we have enough info to connect
       &debug (2,"adding passwd [$arg]");
       $SERVER_PASS = $arg ;
       &connect ;
    }
    else {
       &missing_arg("$SAVE_HIST <password>");
    }


}

sub connect {
    # make a connection
    # unless we have both server and password,  die

    if ( $SERVER_ID && $SERVER_PASS ) {
       if ( $CONNECTED ) {
          &err_print("SERVER :: already connected");
          return ;
       }

       &debug (1,"connecting to server [$SERVER_ID] [$SERVER_PASS]");

       &err_print("SERVER :: connecting");

       ib_open_connection($SERVER_ID,$SERVER_PASS) ;

       $PROMPT = "$SERVER_ID > " ;
       $CONN_STRING = "*" ;

       $CONNECTED = 1 ;

    }
    else {
       &err_print ("CANNOT CONNECT :: no server|pass supplied");
       &debug (3,"NOOP - incomplete details for server connection");
    }

}

sub disconnect {
    if ( $CONNECTED ) {
       &commit ;
       &err_print ( "SERVER :: disconnecting");
       ib_close_connection();
       $CONNECTED = 0 ;

       $PROMPT = "no server > " ;
    }
    else {
       &err_print ( "CANNOT DISCONNECT - no connection is in place");
    }

}

sub commit {
    &err_print ( "COMMIT -  NOT WORKING");

    if ( $CONNECTED ) {
       print "SERVER :: Committing Changes .. ";

       ib_update_server();

       print "DONE.\n";

       $CONN_STRING = " " ;
    }
    else {
       &err_print ("CANNOT COMMIT - no connection is in place");
    }
}

#
# DIGS AND GET ROUTINES
#

sub show_host {
    my ($query,$verbose) = @_ ;

    # use dig...

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <host> (verbose)") ;
       return (0) ;
    }

    &debug (2,"showing zone [@_]");

    if ( ! $CONNECTED ) {
       &err_print("CANNOT dig - no connection is in place");
    }
    else {
       &do_dig($SERVER_ID,$query,$verbose);
    }


}
sub show_zone {
    my ($query,$type,$verbose) = @_ ;

    # use dig...

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <zone> (type) (verbose)") ;
       return (0) ;
    }

    &debug (2,"showing zone [@_]");

    if ( ! $type ) { $type = "SOA" }

    if ( ! $CONNECTED ) {
       &err_print( "CANNOT dig - no connection is in place");
    }
    else {
       &do_dig($SERVER_ID,$query,$type,$verbose);
    }


}

sub do_dig {
    # use a 'dig' to get zone data.
    my $DIG = '/usr/bin/dig' ;
    my $DIGOPTS = '+multiline +nostat +nocmd +norecur';
    my $TERSEOPTS = '+noquestion +noauthority +noadditional +nocomments';

    my $V_DIG = "$DIG $DIGOPTS";
    my $T_DIG = "$DIG $DIGOPTS $TERSEOPTS";

    # so we pass args to dig to work out what type of dig to do
    &debug (3,"dig reqest =  [@_]");
    my ($server,$query,$type,$verbose) = @_ ;

    my $COMM ;

    if ($verbose) {
       $COMM = "$V_DIG \@$server $query $type";
    }
    else {
       $COMM = "$T_DIG \@$server $query $type";
    }

    &debug (2,"dig comm =  [$COMM]");
    print "\n";
    system("$COMM");
    print "\n";


}

############################################3

sub cidrfind {
    # match up netmasks to cidr syntax
    my ($cidr) = @_ ;
    my %mlook = (
       8 =>  '255.0.0.0' ,
       9 =>  '255.128.0.0' ,
       10 => '255.192.0.0' ,
       11 => '255.224.0.0' ,
       12 => '255.240.0.0' ,
       13 => '255.248.0.0' ,
       14 => '255.252.0.0' ,
       15 => '255.254.0.0' ,
       16 => '255.255.0.0' ,
       17 => '255.255.128.0' ,
       18 => '255.255.192.0' ,
       19 => '255.255.224.0' ,
       20 => '255.255.240.0' ,
       21 => '255.255.248.0' ,
       22 => '255.255.252.0' ,
       23 => '255.255.254.0' ,
       24 => '255.255.255.0' ,
       25 => '255.255.255.128' ,
       26 => '255.255.255.192' ,
       27 => '255.255.255.224' ,
       28 => '255.255.255.240' ,
       29 => '255.255.255.248' ,
       30 => '255.255.255.252' ,
    ) ;

    &debug(3,"CIDR is [$cidr]");
    &debug(3,"MASK is [$mlook{$cidr}]");

    return($mlook{$cidr}) ;
}

sub debug {
    # we're passed a message and a level
    # if this level is <= the CURRENT DEBUG level 
    # we print the data
    my $level = shift @_ ;

    if ($level <= $DEBUG) {
           print "($level) DEBUG: @_\n";
    }

}

###########################################################

# $Log: ibcli,v $
# Revision 1.7  2003/09/22 19:24:30  horne
# *** empty log message ***
#
# Revision 1.6  2003/09/21 23:04:29  horne
# added ambiguous commands
# prints now wrapped for cli or batch
# batch commands now work
#
# Revision 1.5  2003/09/20 01:22:36  horne
# First full working version with the abstracted argument parser.
# there is still a lot of gumpf in here, but most of the repeatable code is
# now packed into subroutines
#
# Revision 1.4  2003/09/18 02:28:56  horne
# *** empty log message ***
#
# Revision 1.3  2003/09/16 23:17:25  horne
# *** empty log message ***
#
# Revision 1.2  2003/09/09 22:58:27  horne
# *** empty log message ***
#
# Revision 1.1  2003/08/11 23:31:57  horne
# INFOBLOX version, re-set the CVS counters
#
# Revision 1.9  2001/06/07 16:45:47  horne
# major rewrite of the arg parser - ripped out all the RE's to a much better
# process.
# delete commands disabled
#
# Revision 1.8  2001/05/31 05:28:15  horne
# *** empty log message ***
#
# Revision 1.7  2001/05/24 00:17:54  horne
# Added RE's to handle shortened commant words, not however that this is
# still buggy, typos, as long as they are unique will still work. thus
#  - password, p , pa , ps , pdfgt = password
# I need to find a better command parser
#
# Revision 1.6  2001/05/23 19:39:11  horne
# working version - waiting for updates from infoblox to see if they have
# changed the API syntax
#
# Revision 1.5  2001/05/19 06:08:13  horne
# iblox ready version, but no connections to servers work
#
# Revision 1.4  2001/05/19 04:59:19  horne
# All base commands are being parsed and netmasks are being applied.
# Now we need to hit the infoblox engine for real
#
# Revision 1.3  2001/05/19 03:43:45  horne
# added the DEBUG option before i started to drown in a lot of messy print
# statements
#
# Revision 1.2  2001/05/19 03:34:34  horne
# Basic version, config file parsing is functional.
#
# Revision 1.1  2001/05/19 03:33:56  horne
# *** empty log message ***
#
