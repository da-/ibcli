#!/usr/bin/perl
#
my $ID  = q$Id: ibcli,v 3.2.2.1 2005/09/29 17:20:24 horne Exp $ ;
my $REV = q$Revision: 3.2.2.1 $;
# $Date: 2005/09/29 17:20:24 $
#

# (c) Copyright: Geoff horne, SLC 2001-2005
#               All rights reserved
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. So there...
#
# THIS TICKET IS SOLD SUBJECT TO THE SELLERS CONDITIONS OF SALE OF COPY
# WHICH IS AVAILABLE FOR INSPECTION AT TIME OF PURCHASE AND/OR CONDITIONS
# OF THIS TICKET AND ALSO (TO THE EXTENT THAT THEY ARE NOT INCONSISTENt
# WITH THE SELLERS CONDITIONS OF SALE) THE FOLLOWING:
# 
# 1: A CHANGE IN CONDITIONS OF THE PURCHASER DOES NOT ENTITLE THE PURCHASER
#    TO RETURN OR EXCHANGE TICKET.
# 
# 2: THE SELLER RESERVES THE RIGHT TO:
#    - ADD, WITHDRAW OR SUBSTITUTE ARTISTS
#    - VARY ADVERTISED PROBRAMMES, SEATING ARRANGEMENT AND AUDIENCE
#      CAPACITY , AND:
#    - REFUSE ADMISSION WITH REASONABLE CAUSE
#
# 3: CAMERAS AND TAPE RECORDERS MAY NOT BE PERMITTED. LATE ARRIVALS MAY
#    RESULT IN NON-ADMITTANCE UNTIL A SUITABLE BREAK IN PERFORMANCE. THE
#    SELLER REQUESTS THAT ALL PAGERS AND MOBILE PHONES BE TURNED OFF BEFORE
#    ENTRY.
#
# 4: IF AN OUTDOOR PERFORMANCE IS CANCELLED DUE TO ADVERSE WEATHER OR ANy
#    OTHER CAUSE REASONABLY BEYOND THE SELLERS CONTROL, THERE IS NO RIGHT 
#    TO A REFUND OR EXCHANGE, AND THE SELLER IS NOT OBLIGED TO ARRANGE A 
#    SUBSTITUTE SERVICE, EVENT OR PERFORMANCE
#
# StreetLevel Communications
#
#            support@slc.com.au
#            ph: +1-650-483-0998
#
###############################################################################


# Perl CGI common chunks
#
use strict ;
no strict "refs" ;

# work out where i am
use FindBin qw($Bin $Script);
my ($BASE,$NAME)=($Bin,$Script) ;

BEGIN {
   push (@INC, "lib");
   push (@INC, "$FindBin::Bin");
   push (@INC, "$FindBin::Bin/lib");
};

# use Term::EditLine qw(CC_EOF CC_NEWLINE CC_ARGHACK CC_CURSOR CC_REDISPLAY);
use Term::EditLine qw(CC_EOF CC_REFRESH CC_REDISPLAY);
use Text::Abbrev ;
use Data::Dumper ;
use Getopt::Long;
use Infoblox ;

# globals
$Data::Dumper::Sortkeys = 1 ;

# [ ] aliases
# [ ] history

##########################################################
#
# The word list lookup table
# we'll create a big hash of all commandline alternatives then
# abbreviate all of them. This will give you conditional cmpctl and still
# hopefully be easy to read

# the hash is $COMMANDS { "<string>" } { "words|func|help" }
#             $COMMANDS { "<string>" } { "words" }

# the LHS is a regex matching the WHOLE expanded comand line
# the RHS is the list of next possible words as a string which
# will get carved into array values as part of get_context()

# we grep from the LHS the WHOLE STRING (^..$) ensure uniqieness

# [x] how do you handle options than can come in any order ?
#      use '|' syntax "word|word|word"
# [x] how do you handle option/value pairs ?
#      use '|=' syntax "word=<spec>|word=<spec>|word=<spec>"
# [ ] some options can be repeated, some need to end with them.
#     so we need a val|val syntax and a val?|val? syntax
#     ( use perlre's '?' for 0 or 1 )


my %COMMANDS = (

    'NULL' => { 
           words => "help quit history restart download configure show test", },
    'test' => { 
#            words => "configure zone network", 
           words => "configure add adc|bb zone network", 
#            words => "comment=<comment> <cr> <name,ip> delay=<num> aa|bb bad|member=<ip>|import=<svr> zone network", 
           func => "cli_test", },
    'quit' => { 
           func => "cli_exit", },
    'history' => { 
           func => "cli_history", },
    'show' => { 
           words => "zone network debug",  },

    'help' => { 
           words => "all",
           func => "print_help", },
    'help all' => { 
           func => "print_perldoc", },

    'show debug' => { 
           words => "session commands",  },
    'show debug commands' => { 
           func => "debug_commands", },
    'show debug session' => { 
           func => "debug_commands", },

    'show zone' => { 
           words => "<cr> forward|reverse",  
           func => "cli_show_zone", },
    'show network' => { 
           func => "cli_show_network", },

    'download' => { 
           words => "database",  },
    'download database' => { 
           words => "<file>",  },
    'download database <file>' => { 
           func => "cli_download", },
    'restart' => { 
           words => "dns dhcp",  },
    'restart dns' => { 
           words => "delay=<num>",  
           func => "cli_restart", },
    'restart dhcp' => { 
           words => "delay=<num>",  
           func => "cli_restart", },

    'configure' => { 
           words => "debug server zone network" , },

    'configure debug' => { 
           words => "<num>", },
    'configure debug <num>' => { 
           func => "set_debug", },

    'configure server' => { 
           words => "<value>", },

    'configure server <value>' => { 
           words => "user=<value>", },
    'configure server <value> user <value>' => { 
           words => "password=<value>", 
           func => "cli_add_server", },

    'configure zone' => { 
           words => "add delete <zone>", },

    'configure zone delete' => { 
           words => "<zone>", },
    'configure zone delete <zone>' => { 
           func => "cli_delete_zone", },

    'configure zone add' => { 
           words => "<zone>", },
    'configure zone add <zone>' => { 
           words => "<cr> import=<ip>|forward_to=<ip>|ext_secondary=<name,ip>|ext_primary=<name,ip>|primary=<ip>|secondary=<ip,ip>",  
           func => "cli_add_zone", },

    'configure zone <zone>' => { 
           words => "add delete", },

    'configure zone <zone> add' => { 
           words => "host a_record bulkhost cname ptr_record", },
    'configure zone <zone> delete' => { 
           words => "host a_record bulkhost cname ptr_record", },

    'configure zone <zone> delete host' => { 
           words => "<name>", },
    'configure zone <zone> delete host <name>' => { 
           func => "cli_del_host", },

    'configure zone <zone> delete a_record' => { 
           words => "<name>=<ip>", },
    'configure zone <zone> delete a_record <name> <ip>' => { 
           func => "cli_del_a_rec", },

    'configure zone <zone> delete bulkhost' => { 
           words => "<name>", },
    'configure zone <zone> delete bulkhost <name>' => { 
           words => "<ip>", },
    'configure zone <zone> delete bulkhost <name> <ip>' => { 
           words => "<ip>", },
    'configure zone <zone> delete bulkhost <name> <ip> <ip>' => { 
           func => "cli_del_bulk", },

    'configure zone <zone> delete cname' => { 
           words => "<name>", },
    'configure zone <zone> delete cname <name>' => { 
           words => "<canonical>", },
    'configure zone <zone> delete cname <name> <canonical>' => { 
           func => "cli_del_cname", },

    'configure zone <zone> delete ptr_record' => { 
           words => "<ip>", },
    'configure zone <zone> delete ptr_record <ip>' => { 
           words => "<name>", },
    'configure zone <zone> delete ptr_record <ip> <name>' => { 
           func => "cli_del_ptr", },

    'configure zone <zone> add host' => { 
           words => "<name>=<ip>", },
    'configure zone <zone> add host <name> <ip>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_host", },
    'configure zone <zone> add host <name> <ip> comment <comment>' => { 
           func => "cli_add_host", },

    'configure zone <zone> add a_record' => { 
           words => "<name>=<ip>", },
    'configure zone <zone> add a_record <name> <ip>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_a_rec", },
    'configure zone <zone> add a_record <name> <ip> comment <comment>' => { 
           func => "cli_add_a_rec", },

    'configure zone <zone> add bulkhost' => { 
           words => "<name>", },
    'configure zone <zone> add bulkhost <name>' => { 
           words => "<ip>", },
    'configure zone <zone> add bulkhost <name> <ip>' => { 
           words => "<ip>", },
    'configure zone <zone> add bulkhost <name> <ip> <ip>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_del_bulk", },
    'configure zone <zone> add bulkhost <name> <ip> <ip> comment <comment>'=> { 
           func => "cli_add_bulk", },

    'configure zone <zone> add cname' => { 
           words => "<name>", },
    'configure zone <zone> add cname <name>' => { 
           words => "<canonical>", },
    'configure zone <zone> add cname <name> <canonical>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_cname", },
    'configure zone <zone> add cname <name> <canonical> comment <comment>'=> { 
           func => "cli_add_cname", },

    'configure zone <zone> add ptr_record' => { 
           words => "<ip>", },
    'configure zone <zone> add ptr_record <ip>' => { 
           words => "<name>", },
    'configure zone <zone> add ptr_record <ip> <name>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_ptr", },
    'configure zone <zone> add cname <ip> <name> comment <comment>'=> { 
           func => "cli_add_ptr", },

    'configure network' => { 
           words => "add delete <n.n.n.n/mm>", },

    'configure network delete' => { 
           words => "<n.n.n.n/mm>", },
    'configure network delete <n.n.n.n/mm>' => { 
           func => "cli_delete_network", },

    'configure network add' => { 
           words => "<n.n.n.n/mm>", },
    'configure network add <n.n.n.n/mm>' => { 
           words => "<cr> comment=<comment>|member=<ip>|option=<name,value>",  
           func => "cli_add_network", },

    'configure network <n.n.n.n/mm>' => { 
           words => "split add delete ", },

    'configure network <n.n.n.n/mm> add' => { 
           words => "network fixed range",  },
    'configure network <n.n.n.n/mm> delete' => { 
           words => "network fixed range",  },

    'configure network <n.n.n.n/mm> split' => { 
           words => "</cidr>",  },
    'configure network <n.n.n.n/mm> split </cidr>' => { 
           words => "<cr> required all",  
           func => "cli_split_network", },
    'configure network <n.n.n.n/mm> split </cidr> required' => { 
           func => "cli_split_network", },
    'configure network <n.n.n.n/mm> split </cidr> all' => { 
           func => "cli_split_network", },

    'configure network <n.n.n.n/mm> delete fixed' => { 
           words => "<ip>=<mac>",  },
    'configure network <n.n.n.n/mm> delete fixed <ip> <mac>' => { 
           func => "cli_del_fixed_address", },

    'configure network <n.n.n.n/mm> delete range' => { 
           words => "<ip>=<ip>",  },
    'configure network <n.n.n.n/mm> delete range <ip> <ip>' => { 
           func => "cli_del_dhcp_range", },

    'configure network <n.n.n.n/mm> add network' => { 
           words => "<n.n.n.n/mm>",  },
    'configure network <n.n.n.n/mm> add network <n.n.n.n/mm>' => { 
#            words => "option member",  
           func => "cli_add_sub_network", },

    'configure network <n.n.n.n/mm> add fixed' => { 
           words => "<ip>=<mac>",  },
    'configure network <n.n.n.n/mm> add fixed <ip> <mac>' => { 
           words => "<cr> comment=<comment>",  
           func => "cli_add_fixed_address", },

    'configure network <n.n.n.n/mm> add range' => { 
           words => "<ip>=<ip>",  },
    'configure network <n.n.n.n/mm> add range <ip> <ip>' => { 
           words => "<cr> comment=<comment>|failover=<value>|member=<ip>|option=<name,value>",  
           func => "cli_add_dhcp_range", },

   );

# print Dumper ( \%COMMANDS ) ;

### ---  PRE canned regexes --- ###
#
#  we can force syntax HERE by matching args to regexes
#

            # quoted comments
my $REcomm = '("[^"]*")|\S+' ;
            # zones
my $REzone = '(\w|\.)+';
            # a complete IP address
my $REip  = '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}';
            # a complete n.n.n.n/mm
my $REcidr = '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2}';
           # MAC address 
my $REmac  = '[\w:]+';
           # incomplete form of an IP address
           # match 'N' then praps '.N' then praps '.' or '.N'
my $REpartip = '\d{1,3}(\.\d{1,3}){0,2}(\.|\.\d{1,3})?';

# this is a hash of regexes to use for special keywords
my %SPECOPS = (
     '<mac>' => "^$REmac\$",
     '<num>' => '^\d+$',
     '<svr>' => '^\S+$',
     '<file>' => '^\S+$',
     '<name>' => '^\S+$',
     '<value>' => '^\S+$',
     '<name,value>' => '^\S+$',
     '<canonical>' => '^\S+$',
     '<comment>' => "^$REcomm\$",
     '<name,ip>' => "^$REzone,*($REpartip)*\$",
     '<ip,ip>'   => "$REpartip|,",
     '<ip>'      => "^$REpartip\$",
                     # incomple n.n.n.n/mm
     '<n.n.n.n/mm>' => "^($REpartip|$REip\\\/|$REcidr)\$",
     '<cidr>'       => "^($REpartip|$REip\\\/|$REcidr)\$",
     '</cidr>'      => '^\/\d{1,2}$',
     '<zone>'   => '^\S+$',
   );

# Alternate words are set of a global lookup table

my %ALTERNATES = (
     "configure" => "set",
);

### ---  end ------------------ ###

# [ ] connected
my $ONLINE ;
my $SESSION ;
my $MASTER_IP ;

my $DEBUG = 0 ;
my $LIST_COMM = 0 ;

my ( $S_ID , $S_PASS , $S_USER ) ;

GetOptions (
    "s=s" => \$S_ID , 
    "p=s" => \$S_PASS ,
    "u=s" => \$S_USER ,
    "t+"  => \$LIST_COMM ,
    "V|version+"    => sub { print "\n$ID\n$REV\n\n"; exit ; },
    "d=s"     => \$DEBUG,
);

# bailout if we just want commands
if ( $LIST_COMM ) {
   foreach my $comm ( sort keys %COMMANDS ) {
      print "$comm\n";
   }
   exit ;
}

##########################################################

# create the object
my $el = Term::EditLine->new('progname');

# set the prompt ;
my $PROMPT = 'server ? > ';
$el->set_prompt ("$PROMPT");

# other useful commands are
#      $el->insertstr("aaaa");
# inserts text, but may not print it.


##########################################################

# sigint (ctrl-c) has to be caught by perl, before the term.
# $SIG{INT} = sub { print "\nYou hit ^C... Aaayyy it hurts\n"; };
# $SIG{INT} = sub { $el->reset ; return CC_CURSOR };
$SIG{INT} = 'IGNORE';
# ctrl-c reset
# $el->add_fun ('undo','reset', 
#              sub { print "\n" ; $el->reset ; return CC_REDISPLAY }) ;


########################################
# define input functions
#
# these occur based on character input...
#
########################################

# quit on '^D'
# CC_EOF kills the input (end of file)
# $el->add_fun ('bye','desc',sub { print "q\nquitting...bye\n"; return CC_EOF; });
$el->add_fun ('bye','desc', \&cli_exit );

# print help
$el->add_fun ('help','desc', \&print_help );

# completion control
$el->add_fun ('cmpcl','desc', \&cmpctl ) ;

sub cli_exit {
    # quit and cleanup
    print "\nexiting...bye\n"; 
#     $el->history_save(".clihistory") || die "cant" ;
    exit ;
#     return CC_EOF;
}


########################################
# add key bindings
# 'q' to quit is really an arg function
# $el->parse('bind','q\n','bye');

$el->parse('bind','-e');
$el->parse('bind','^D','bye');

# "\" clear the line ( can't use CRTL-C ?? )
$el->parse('bind','\\\\','ed-start-over');

# inline help
$el->parse('bind','?','help');

# tab ?
$el->parse('bind','\t','cmpcl');

# show them all
# $el->parse('bind','-a');

########################################

# load the history
# $el->history_load(".clihistory");

########################################

# do a connection from the git go ?
if ( $S_ID and $S_PASS and $S_USER ) {
   &cli_add_server ( "configure server $S_ID user $S_USER password $S_PASS" ) ;
}

# main loop

# print a startup message
print " 
#####################################################################
#
# the Infoblox CLI $REV (this is alpha code, ymmv)
#
#####################################################################

 ( press <tab> for help )
";

# [ ] reading from a file ?
while (defined($_ = $el->gets())) {

    # only history non-blank lines
    chomp ( my ( $in ) = $el->line ) ;
    if ( $in ) {
       # save the line WITH the cr.
       $el->history_enter($_);
    }

    # now do something
#     exit if /^quit|q$/;
    chomp ;

    # cleanup the line, do something, and redraw
    # we can only do redraws on a 'return()' so everything is in a sub{}
    &process_line ( $_ ) ;

    # now flush the buffer
    $el->deletestr( length ( $in ) );

}


#####################################################################
# perldoc goes here

=head1 NAME

The INFOBLOX CLI, a users guide

=head1 Synopsis

*A guide for commandline junkies*

=head1 Description

This is 
$Revision: 3.2.2.1 $
there were previous versions that were even worse, this one is pretty bad,
it really is beta code.  But it is a start.

So why do this, what is this CLI for ? Well there were a few primary
reasons:

=over

=item Quick changes are now easy,

You don't need to wait for a GUI to start or get the right version
of java functional, this allows you to quickly get into the database
and make some simple and efficient changes

=item Abstract command set

Now you don't need to know the intricacies of the API, a few simple
commands will achieve the same effect, if you are a user that
doesn't know PERL you can still drive the CLI and get the results
you need. This may not be an advantage if you are reading data from
another system to import into an Infoblox unit (since you still need
to write software to parse the data, eg PERL) but it may still help
and end user that can convert this data in to the CLI command set
but not know enough to write PERL.

=item Customers wanted it

    Need I say more ?

=back 

Lastly, why is this called 'ibcli' and not 'DNScli' ? Well, this is just
a wrapper to any API we like, it is not really DNS specific.


=head1 Quickstart

Simple example, adding a zone

   server ? > conf server 10.0.1.224 user admin pass infoblox
   admin@10.0.1.224 > conf zone add infoblox.com
   admin@10.0.1.224 > conf zone add sales.infoblox.com

A more detailed example

   server ? > conf server 10.0.1.224 user admin pass infoblox
   admin@10.0.1.224 > conf zone add com
   admin@10.0.1.224 > conf zone add foo.com
   admin@10.0.1.224 > conf zone foo.com add host test 1.2.3.4
   admin@10.0.1.224 > conf zone delete bar.com

A complex example, multiple connections

   server ? > conf server 10.0.1.224 user admin pass infoblox
   admin@10.0.1.224 > conf zone add sales.foo.com

   # now switch servers
   admin@10.0.1.224 > conf server 10.0.1.200 user admin1 pass infoblox1
   admin1@10.0.1.220 > conf zone add biz.foo.com

=head1 Installation

It should run 'as is' from a uniz machine. 

If you have a windows OS then you will have a few hurdles to cross:

=over

=item * Rename the script to 'ibcli.pl'. 

I still don't understand why Windows uses file suffix to type its data
rather than doing something intelligent like looking at the contents of
the file, but then, we are dealing with people who thought 8.3 was all
you'd ever need as a file namespace and 640K for ram...

=item * Make sure you have the necessary libraries installed, 

you'll need:

   o Getopt::Long

   o Text::Abbrev

   o Term::EditLine

=back

=head1 Getting started

Run the ibcli - it is a perl script, you will get a prompt

    % ./ibcli
    server ? >

Ideally, you should now connect the CLI to a server somewhere, to do
this you give it the server and a user and a password, you can do these in
either order, it just tries to eventually connect when it has enough data.

    server ? > conf server 10.0.1.224 user admin password infoblox
    admin@10.0.1.224 >

Or you can also do this from the initial invocation:

    % ./ibcli -s 10.0.1.230 -u admin -p infoblox 

"HOLD ON A SEC", I hear you ask, "Why am i connecting to a server, isn't
this CLI running on a console somewhere ?". No, Grasshopper, the CLI is
just a wrapper to the Infoblox.pm so you can run it from anywhere in
the world. This gives you the added advantage of being able to work on
MANY servers from the one CLI.

=head1 Setting the debug level

    server ? > conf debug 3
    server ? >

Or you can also do this from the initial invocation:

    % ./ibcli -d 3


=head1 Other Gritty Details

OK, so what can I do from here ?

=head2 Members and secondaries

By default all stuff is added to just the Grid Master, the API guesses
this from the SERVER setting. If you explicitly want to add stuff to
certain members you need to append the members to the command arg :

   conf zone add foo.com member 1.2.3.4
   conf zone add foo.com member 1.2.3.4 member 1.2.3.5

=head2 Laziness

The command parser accepts abbreviations

    se z a foo.com

is the same as

    conf zone add foo.com

=head2 TAB completion

The cli uses a full line editor with history and the usual bells ans
whistles. commend completion can be achieved by pressing <tab>

=head2 BATCH processing

TBD

=cut

########################################
# subs
########################################

sub cli_history {
    # [ ] History

#     my $hsize = ${ $el->history_get_size } ;
#     my $hobj = $el->history_get_curr ;

    print "--HISTORY not supported--\n";
}

sub print_help { 
    # [ ] contextual help
    my ( $context ) = $el->line ;
    chomp $context;

    print "\nhelp for [$context] TBD
 press :
   <tab> for options and word completion
   '\\' to clear the line
   'q' to quit\n\n";
    return CC_REDISPLAY
};

sub print_perldoc { 
    # dumpmyself to perldoc

#     print "doc : $0 \n";
    system ( "perldoc $0 | less" );

    return CC_REDISPLAY
};

sub process_line {
    # expand the line, drop errors
    my ( $line ) = @_ ;

    &debug_cli (1,"");
    my ( $expanded , $error , $matchline ) = &expand_line ( $line ) ;
    &debug_cli (2,"linec m[$matchline]");
    &debug_cli (2,"linec e[$expanded]");

    if ( $error ) {
       print "$error\n"
    }
    else {

       # now go do it
       my $func = $COMMANDS{ $matchline }{"func"} ;
       &debug_cli (2,"linec call ($func) ($expanded)");
       if ( $func ) {
          # catch undefined arrays
          if ( defined ( &$func ) ) {
             &$func ( $expanded ) ;
          }
          else {
             print " NOT implemented ($func)\n";
          }
       }
       else {
          if ( $line ) {
             my $words = $COMMANDS{ $matchline }{"words"} ;
#              print "  Incomplete : $line ($words)\n";
             # cleanup some syntaxes
             $words =~ s/=/ /g;
             print "  Incomplete : $expanded ($words)\n";
          }
       }
    }

    # may need a re-display here...
#     return CC_REDISPLAY
    return CC_REFRESH
}

sub expand_line {
    # if a user hasn't been presing <tab> we may have valid syntax that
    # still needs to be pumped through the abbreviation parser.
    # 
    # this is a tad tricky because each word needs to be walked through
    # the command tree to make sure it is in context
    #
    # but given input :
    #
    #   co z foo.com a
    #
    # we need to see that this is BOTH :
    #
    #   configure zone foo.com add  (expanded)
    #   configure zone <zone> add   (used for matching)
    # 
    # we do this by returning $expline and $matchline

    my ( $line ) = @_ ;
    &debug_cli (3,"linex input [$line]");

    # protect stuff in quotes by inserting '%20s'
    my ( $comment ) = $line =~ /"([^"]*)"?/;
    ( my $pcomment = $comment ) =~ s/\s/%20s/g;
    $line =~ s/$comment/$pcomment/;

    # walk each word ( split on <space> )
    my $expline ;
    my $matchline ;
    my $error ;
    foreach my $thisarg ( split ( /\s+/ , $line ) ) {

       &debug_cli (3,"linex -------");

       my $origarg  = $thisarg ;
#        # [ ] alternate words - we need to undo them here
#        #     but we can't because the word wasnt expanded
#        foreach my $alt ( keys %ALTERNATES ) {
#           my $other = $ALTERNATES{$alt};
#           if ( $other eq $origarg ) {
#              # undo the alternate word
#              $thisarg = $alt ;
#           }
#        }

       &debug_cli (3,"linex arg     a($thisarg)<-($origarg)");
       &debug_cli (3,"linex partial e[$expline]");
       &debug_cli (3,"linex partial m[$matchline]");

       # hide special chars (stops us exiting)
       $thisarg =~ s/\[|\]|\(|\)/!/;

       # we now have the short word, 
       # we have to look at the matchline to get some context
       # then we can expand the word

       # we need the contect so we know what the next word is

       my ( @words ) = get_context ( $matchline ) ;

       my ($done,$sptype,$expword,@matches) = &expand_word ($thisarg,@words) ;

       &debug_cli (3,"linex match [$done][$sptype] exp($expword)or[@matches]");
       &debug_cli (3,"linex exp   [$thisarg]->[$expword]");

       if ( $expword and @matches ) {
          # ambiguous line, drop an error, exit
          $error = "  Ambiguous : $expline(@matches)";

          # break out of the arg reading loop..
          return ( $expline , $error , $matchline) ;

       }

       elsif ( $sptype ) {
          # we're a special, record this for regex matching
          $expline .= "$expword " ;
          $matchline .= "$sptype " ;
       }

       elsif ( ! $expword ) {
          # NO MATCH, Bad word
          $expline .= "$thisarg" ;
          $matchline .= "$thisarg" ;

          # find out where the error was.. (kinda tricky)
          # the bad word will be at the end of $expanded
          ( my $good = $line ) =~ s/(.*)$thisarg.*$/$1/;

          # and unclean comments
          $good =~ s/%20s/ /g ;

          # and use this to put a marker at the right place
          my $slen = length ( $PROMPT) + length ( $good ) ;
          my $spc = sprintf ( "%*s^" , $slen , " " ) ;
          &debug_cli (3,"linex estrip [$thisarg] from [$good] [$spc]");

          # create the error string.
          $error = "$spc\n  Unknown argument at '^'";

          return ( $expline , $error , $matchline) ;
       }

       else {
          # standard word
          $expline .= "$expword" ;
          $matchline .= "$expword" ;

       }

    }

    # now clean it up
    $expline =~ s/\s+$//;
    $matchline =~ s/\s+$//;
    # and unclean comments
    $expline =~ s/%20s/ /g;
    $matchline =~ s/%20s/ /g;

    return ( $expline , $error , $matchline ) ;

}

sub lastarg {
    # given a string, determine what the last arg is.

    my ($line) = @_ ;

    # we need the last 2 words to get context 
    #  - last complete word
    #  - last incomplete word
    # this string can be any combination of :
    # ''
    # '<str>'
    # '<str> '
    # '..<str> <srt>'
    # '..<str> <srt> '

    # if there is trailing space - that is the last arg
    # if there is no trailing space, the last word is the lastarg

    # we also return the previous word, as this is useful sometimes

    &debug_cli (4,"lastarg line  l($line)");

    my ( $prearg , $lastarg ) = $line =~ /(\S+)\s+(\S+)$/ ;
    if ( $line =~ /(\S+)\s+$/ ) { $prearg = $1 , $lastarg = "" };
    if ( $line =~ /^(\S+)$/ ) { $prearg = "NULL" , $lastarg = $1 };
    if ( $line =~ /^$/ ) { $prearg = "NULL" , $lastarg = $1 };

    return ( $prearg , $lastarg ) ;

}

sub add_context {
    # shove an new context into the hash
    my  ( $context , $words , $add_func , $copyfrom ) = @_ ;

    # only create NEW structures
#     unless ( $COMMANDS{ $context }{"words"} ) {
    unless ( $COMMANDS{ $context } ) {
       $COMMANDS{ $context }{"words"} = $words ;

       # there should already be a context for $line
       # so we may choose to copy the function
       # ( we DON'T do this for things like the lhs of <word>=<var> )
       my $func = $COMMANDS{ $copyfrom }{"func"} ;
       if ( $add_func ) {
          $COMMANDS{ $context }{"func"} = $COMMANDS{ $copyfrom }{"func"} ;
       }

       &debug_cli (4,"addcon f($func) ($context) [$words]");
    }

}

sub get_context {

    # we are passed a string which SHOULD be the whole line EXCEPT for
    # THE LAST ARG, we use this to get some sort of context and the next
    # list of possible words

    my ( $line , $lastarg ) = @_ ;
    $line =~ s/\s+$//;
    &debug_cli (3,"contxt line [$line]");

    # we need to check is we're at the beginnning of the line
    if ( ! $line ) { $line = "NULL" } ;

    # the hash is $COMMANDS { "<string>" } { "words|func|help" }
    #             $COMMANDS { "<string>" } { "words" }
    #
    # Can't use an undefined value as an ARRAY reference

    # now find a matching line of context in the commend hash.
    my @words ;
    if ( $COMMANDS{"$line"}{'words'} ) {
       my $wordlist = $COMMANDS{"$line"}{'words'} ;

#        # [ ] alternate words - we could insert them here
#        # but we need to un-insert them here as well
#        foreach my $alt ( keys %ALTERNATES ) {
#           my $other = $ALTERNATES{$alt};
#           &debug_cli (4,"contxt alt ($alt) + ($other)");
# 
#           # and sub it in
#           $wordlist =~ s/$alt /$alt $other /;
#        }

       # We need to clean up some of the odd syntaxes the list
       # of words, so we do neat things before creating an array

       # 'word=<var>' pair : if that's the case we have to get a
       # tad clever and dynamically add new matches to the context array.
       # this is easier that generating all permutations at compile time
       # we'll just add new contextes at run time.

       # walk the words one at a time
       foreach my $cw ( split ( /\s+/ , $wordlist ) ) {
          if ( $cw =~ /\|/ ) {
             # word|word|word :
             # add an additional context with the same arg list
             foreach my $alt ( split /\|/ , $cw ) {

                # now check for 'word=<var>|word=<var>|word' :
                if ( $alt =~ /(\S+)=(<\S+>)/ ) {
                   push ( @words , $1 ) ;
                   # add a context for lhs (with no func)
                   &add_context ( "$line $1" , $2 , 0 , 0 ) ;
                   # and the rhs with the original list
                   &add_context ( "$line $1 $2" , $wordlist , 1 , $line ) ;
                }
                else {
                   # just add the word
                   push ( @words , $alt ) ;

                   # add a context for the altword
                   &add_context ( "$line $alt" , $wordlist , 1 , $line ) ;
                }
             }
          }
          elsif ( $cw =~ /(\S+)=(<\S+>)/ ) {
             # word=<var> :
             # drop '=<var>' , add an additional context
             push ( @words , $1 ) ;

             # add a context for lhs
             &add_context ( "$line $1" , $2 , 0 , 0 ) ;
             # add a terminating context for rhs
             &add_context ( "$line $1 $2" , "<cr>" , 1 , $line ) ;
          }

          else {
             # normal word
             push ( @words , $cw ) ;
          }
          
       }

    }
    else {
       @words = ( "<cr>" ) ;
    }
    &debug_cli (4,"contxt words c(@words) ");

    return ( sort @words ) ;

}

################
# TAB completion
# This is complex in its simplicity
################

sub cmpctl {
    # completion control... called when we <tab>
    print "\n" if $DEBUG ;

    # first, we have to get the last input
    my ( $line , $icur , $ilast ) = $el->line ;
    chomp $line ;

    # [-] how do you handle a line that has been edited ?
    #     like you press <tab> before an existing word ?
    #     A) you ignore it, and don't complete the word

    # Next possible completions : 
    #       configure download exit get 
                                                                                
    
    # now we have to expand this line and parse it
    # this seems redundant, but there may be words in the line that were
    # not previously <tab> completed. 

    # WE only expand

    my ( $expanded , $exerr , $matchline ) = &expand_line ( $line ) ;
    &debug_cli (3,"cmpctl -------");
    &debug_cli (3,"cmpctl e[$expanded]");
    &debug_cli (3,"cmpctl m[$matchline]");
    
    # [-] now - expandline may drop an error if we made a typo
    # EARLIER in the wordlist.
    # if so we should STOP and report the syntax error
    if ( $exerr =~ /unknown/i ) {
       # find out where the error was.. (kinda tricky)
       # the bad word will be at the end of $expanded

       print "\n$exerr\n";
       return CC_REDISPLAY  ;
    }

    # so we now have expanded the line, we can use this to get the
    # context (again), but we have to rip out the last arg from it

    my ( $prearg , $lastarg ) = &lastarg ($line ) ;
    &debug_cli (3,"cmpctl lastarg p($prearg) l($lastarg)");

    my $checkline = $matchline ;
    if ( $prearg eq "NULL" ) { $checkline = "NULL" }
    elsif ($lastarg ) {
       # now we so some tricky substitution
       # putting the last arg back as it was
       $checkline =~ s/\s($lastarg)\S*$/ /;

       # or cleansing special markers ( <net> etc )
       $checkline =~ s/\s<\S*>$/ /;
    }

    &debug_cli (3,"cmpctl chkline  [$checkline]");

    # we pass the last arg to get_context anyway, as we may need it
    my ( @words ) = get_context ( $checkline , $lastarg ) ;

    # then we call expand_word() which will find a match and return
    # - the expanded word (unique match)
    # - no change ( a special word )
    # - no change ( ambiguous , list of matches )
    # - nothing ( no match , list of matches )

    my ($done,$sptype,$expword,@matches) = &expand_word ($lastarg,@words) ;
    &debug_cli (3,"cmpctl match [$done][$sptype] ($expword) alt[@matches]");

    # based on this, do something useful
    if ( $expword and $done ) {
       # finish the line, add the missing charagters
       &debug_cli (3,"cmpctl uniq ($lastarg)+[$expword]");

       ( my $append = $expword ) =~ s/^$lastarg//i ;
       # BUT only do it if the cursor is in the right place
       if ( $icur = $ilast ) {
          $el->push("$append");
       }
    }
    elsif ( $expword and @matches ) {
       # print matching options
       &debug_cli (3,"cmpctl ambig ($expword) [@matches]");

       print "\n@matches\n";
    }
    elsif ( $expword ) {
       # do nothing (NOTE, specials match AFTER uniqs )
       &debug_cli (3,"cmpctl spec ($expword) [@matches]");
    }
    # [-] i don't think we ever get here
    #     no, it gets caught by errors with expandline
    elsif ( ! $expword ) {
       # delete the string , print all options
       my $len = length ( $lastarg ) ;
       &debug_cli (3,"cmpctl cut ($expword)-[$len]");

       $el->deletestr( $len );
       print "\n@matches\n";
    }

    # Redisplay entire input line
    return CC_REDISPLAY  ;
}

sub expand_word {
    # given an input and a list of matches, return either
    # - the bit to append word (unique match)
    # - no change ( a special word )
    # - no change ( ambiguous , list of matches )
    # - nothing ( no match )

    my ( $inword , @words ) = @_ ;

    # then force an error if there are illegal characters
    # by not making the regex match anything
    # ( this catches words like '<ip>' )
    $inword =~ s/^</!/;
#     $inword =~ s/\[|\]|\(|\)/!/;

    # we need to create a version of inword that is regex friendly
    # so special chars have to be protected
    ( my $regex = $inword ) =~ s/(\[|\]|\.|\/)/\\$1/g ;

    &debug_cli (5,"wordx arg [$inword] regex #$regex#");

    # generate abbreviations
    my %abbrevs = abbrev ( @words ) ;
    # if this is an abbrev of a word...
    my $expword = $abbrevs{ lc($inword) } ;
    my @matches ;
    my $completed = 0 ;
    my $spectype ;

    if ( $expword ) {

       # we have a match, stop here, append a <spc>
       $expword .= " ";
       &debug_cli (4,"wordx uniq ($inword) -> [$expword]");
       $completed = 1 ;
    }
    else {

       # no match , find alternatives
       @matches = sort grep ( /^$regex/ , @words ) ;
       my @specials = sort grep ( /^</ , @words ) ;

       if ( @matches ) {
          # we have an abiguous word (or a blank)
          &debug_cli (4,"wordx ambig ($inword) [@matches]+[@specials]");
          $expword = $inword ;

          if ( $regex ) { @matches = ( @specials , @matches ) ; }
       }
       else {
          # no match, catch special strings or remove the bad word

          my $havespecial ;
          foreach my $smatch ( sort keys %SPECOPS ) {
             # if the special is valid in this context
             # and it has the right regex, ...

             # we lookup the regex to use based on the keyword
             my $regex = $SPECOPS{$smatch};
             &debug_cli (5,"wordx spe regex ($smatch) ( $regex ) ");

             if ( grep ( /$smatch/ , @words ) and $inword =~ /$regex/ ) {
                # delete nothing
                &debug_cli (4,"wordx is spe ($smatch) [$inword]");
                $expword = $inword ;
                $havespecial ++ ;
                $spectype = $smatch ;
             }
          }

          unless ( $havespecial ) {

             # scrub the word
             $expword = "" ;
             &debug_cli (4,"wordx cut [$inword] -> ($expword)");
             @matches = sort @words ;

          }

       }

    }

    # return the results
    &debug_cli (4,"wordx word  ($inword)>[$expword]");
    return ( $completed , $spectype , $expword , @matches ) ;
}

###########################################
#
# call an infoblox function, ONLY if we're connected
#

sub do_func {

    # assume we are passed a single object
    #
    my ( $method , @data ) = @_ ;
#     &debug_cli(1,"do_func ($method)");

    # [ ] format the data for pretty printing
    if ( $DEBUG >= 2 ) {
       print Dumper ( \@data ) ;
    }

    my @ret_objects ;

       # actually try and run it
       if ( $ONLINE ) {

          # call by indirection
          @ret_objects = $SESSION->$method ( @data ) ;

          # get errors
          my $result = $SESSION->status_code();
          my $response = $SESSION->status_detail();

          if ( $result > 0 ) {
             # We got error...
             print "  Error : $response ($result)\n";
          }
       }
       else {
          print "  CANNOT EXECUTE - no connection is in place\n";
       }

    return ( @ret_objects ) ;
}


###########################################
#
# actual API calling functions.
#
###########################################

=head1 GENERAL COMMAND REFERENCE

The syntax mostly matches the API syntax. Also, since this is based on
the API (duh) the same restrictions about required arguments applies.
Don't expect the cli to work around requiring dumb extra arguments. When
you look deep into the API you realise why they are there.

=cut

=head2 Add a Zone

Zones can be added as either forward or reverse. If you add a zone of the
form n.n.n.n/mm it will assume it is a reverse zone

Add a forward zone

   conf zone add foo.com

Add a reverse zone

   conf zone add 10.0.1.0/24

Add a zone to specific members

   conf zone add foo.com primary 1.2.3.4 secondary 1.2.3.5 sec 1.2.3.6

Add a zone with external primary

   conf zone add foo.com ext_primary ns1.foo.com,1.2.3.4 

=head2 Import a zone

Zones can be imported as either forward or reverse. You just add an extra
argument of the import source

Import a forward zone

   conf zone add foo.com import 45.0.1.220

Import a reverse zone

   conf zone add 10.0.1.0/24 import 45.0.1.220

=cut

sub cli_add_zone {

    # essentially all options are passed as name value pairs
    # 
    my ( $line ) = @_ ;

    # get the args from the line
    my ($zone)     = $line =~/zone add (\S+)/ ;
    my ($import)   = $line =~/ import (\S+)/ ;
    my ($pri)   = $line =~/ primary (\S+)/ ;

    my (@ext_pri) = $line =~/ ext_primary (\S+)/g ;
    my (@forwarders) = $line =~/ forward_to (\S+)/g ;
    my (@sec)     = $line =~/ secondary (\S+)/g ;
    my (@ext_sec) = $line =~/ ext_secondary (\S+)/g ;

    &debug_cli (1,"addz z($zone) i($import) p($pri) ep(@ext_pri) s(@sec) es(@ext_sec)");

    # create the zone...
    my $obj = Infoblox::DNS::Zone->new ( "name" => $zone, );


    # find a member to be the primary (external or otherwise)
    # or is it a forward zone...
    if ( @forwarders ) {

       # external primaries
       my @fwd_svrs ;
       foreach my $fwd_ip ( @forwarders ) {
          push @fwd_svrs , Infoblox::DNS::Nameserver->new(
                             "ipv4addr" => $fwd_ip ,
                             );

          &debug_cli (2,"addz z($zone) fwd($fwd_ip)");
       }

       $obj->forward_to( \@fwd_svrs ) ;

       # [ ] and add the right members...

    }
    else {
    if ( $pri ) {
       # member primary
       my $pri_ns = Infoblox::DNS::Member->new ( 'ipv4addr' => $pri, );
       $obj->primary( $pri_ns ) ;

       &debug_cli (2,"addz z($zone) mem-p($pri)");
    }
    elsif ( @ext_pri ) {
       # external primaries
       my @ext_svrs ;
       foreach my $external ( @ext_pri ) {
          # we override with an external primary
          my ( $nsname , $ip ) = split ( /,/ , $external ) ;

          &debug_cli (2,"addz z($zone) ext-p($nsname)($ip)");
          my $primary = Infoblox::DNS::Nameserver->new ( 
                     'name' => $nsname, 
                     'ipv4addr' => $ip, 
                      );

          push @ext_svrs , $primary ;
       }

       $obj->primary( \@ext_svrs ) ;

    }
    elsif ( $MASTER_IP ) {
       # use the server as the primary
       my $pri_ns = Infoblox::DNS::Member->new ( 'ipv4addr' => $MASTER_IP, );

       $obj->primary( $pri_ns ) ;
       &debug_cli (2,"addz z($zone) mas-p($MASTER_IP)");
    }

    # find secondaries
    my @sec_svrs ;

    foreach my $sec_ip ( @sec ) {
       # normaal members
       push @sec_svrs , Infoblox::DNS::Member->new(
#                              "name" => $value ,
                             "ipv4addr" => $sec_ip ,
                             );
       &debug_cli (2,"addz z($zone) sec($sec_ip)");
    }

    foreach my $ext_ip ( @ext_sec ) {
       # external secondaries
       my ( $nsname , $ip ) = split ( /,/ , $ext_ip ) ;

       # IP is optional (kinda)
       if ( ! $ip ) { $ip = "255.255.255.255" }

       my $secondary = Infoblox::DNS::Nameserver->new ( 
                        'name' => $nsname, 
                        'ipv4addr' => $ip, 
                      );

       push @sec_svrs , $secondary ;
       &debug_cli (2,"addz z($zone) ext-s($nsname)($ip)");
    }

    # add any secondaries we found parsing the args
     
    $obj->secondaries ( \@sec_svrs ) ;

    # do we import ?
    if ( $import ) {
       $obj->import_from ( $import ) ;
       &debug_cli (2,"addz z($zone) imp($import)");
    }
    } # not a forward ?

    # now add the damn thing
    &do_func("add",$obj);

}

=head2 Remove a zone

Forward or reverse, the syntax follows the same logic as add zone

Remove a forward zone

   conf zone del foo.com

Remove a reverse zone

   conf zone del 10.0.1.0/24

=cut

sub cli_delete_zone {
    my ( $line ) = @_ ;

    # get the args from the line
    ( my $zone)     = $line =~/zone delete (\S+)/ ;
    &debug_cli(1,"remz n($zone)");

    my $obj = Infoblox::DNS::Zone->new (
                  "name" => $zone,
    );

    &do_func("remove",$obj);

}

=head2 Add a host to a zone

   conf zone foo.com add host test 1.2.3.4

   conf zone foo.com add host test 1.2.3.4 comment "this is a comment"

=cut

sub cli_add_host {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host , $ip ) = $line =~/add host (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    my $name="$host.$zone";

    &debug_cli(1,"addh n($name) n($ip) c($comment)");

    # create the object
    my $obj = Infoblox::DNS::Host->new (
                  "name" => $name,
                  "ipv4addrs" => [ $ip ],
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a host from a zone

   conf zone foo.com delete host test

=cut

sub cli_del_host {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host ) = $line =~/host (\S+)/ ;

    my $name="$host.$zone";

    &debug_cli(1,"delh n($host.$zone) ");

    # create the object
    my $obj = Infoblox::DNS::Host->new (
                  "name" => "$host.$zone",
    );

    # addit
    &do_func("remove",$obj);

}

=head2 Add an A record to a zone

   conf zone foo.com add A test 1.2.3.4

=cut

sub cli_add_a_rec {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host , $ip ) = $line =~/ a_record (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    my $obj = Infoblox::DNS::Record::A->new (
                  "name" => "$host.$zone",
                  "ipv4addr" => "$ip",
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    &debug_cli(1,"add_a n($host) n($ip) c($comment)");

    # addit
    &do_func("add",$obj);

}

=head2 Remove An A record from a zone

   conf zone foo.com delete A test 1.2.3.4

=cut

sub cli_del_a_rec {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host , $ip ) = $line =~/ a_record (\S+) (\S+)/ ;

    my $obj = Infoblox::DNS::Record::A->new (
                  "name" => "$host.$zone",
                  "ipv4addr" => "$ip",
    );

    &debug_cli(1,"del_a n($host) n($ip) ");

    # addit
    &do_func("remove",$obj);

}

=head2 Add a bulk host to a zone

   conf zone foo.com add bulkhost my_prefix 1.2.3.10 1.2.3.20

   conf zone foo.com add bulkhost my_prefix 1.2.3.10 1.2.3.20 comment "bah"

=cut

sub cli_add_bulk {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $prefix , $fip , $lip ) = $line =~/ bulkhost (\S+) (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    &debug_cli(1,"addbh z($zone) p($prefix) n($fip,$lip) c($comment)");

    my $obj = Infoblox::DNS::BulkHost->new (
                   "zone" => $zone ,
                   "prefix" => $prefix ,
                   "start_addr" => $fip ,
                   "end_addr" => $lip ,
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a bulk host from a zone

   conf zone foo.com del bulkhost my_prefix 1.2.3.10 1.2.3.20

=cut

sub cli_del_bulk {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $prefix , $fip , $lip ) = $line =~/ bulkhost (\S+) (\S+) (\S+)/ ;

    &debug_cli(1,"delbh z($zone) p($prefix) n($fip,$lip) ");

    my $obj = Infoblox::DNS::BulkHost->new (
                   "zone" => $zone ,
                   "prefix" => $prefix ,
                   "start_addr" => $fip ,
                   "end_addr" => $lip ,
      );

    # addit
    &do_func("remove",$obj);

}

=head2 Add a CNAME to a zone

   conf zone foo.com add CNAME alias real.foo.com

=cut

sub cli_add_cname {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $alias , $cname ) = $line =~/ cname (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    &debug_cli(1,"addcn z($zone) a($alias) cn($cname) c($comment)");

    my $obj = Infoblox::DNS::Record::CNAME->new (
                  "name" => "$alias.$zone",
                  "canonical" => "$cname",
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a CNAME from a zone

   conf zone foo.com delete CNAME alias

=cut

sub cli_del_cname {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $alias , $cname ) = $line =~/ cname (\S+) (\S+)/ ;

    &debug_cli(1,"delcn z($zone) n($alias) cn($cname)");

    my $obj = Infoblox::DNS::Record::CNAME->new (
                  "name" => "$alias.$zone",
                  "canonical" => "$cname",
    );

    # addit
    &do_func("remove",$obj);

}

=head2 Add a PTR to a zone

   conf zone 10.0.0.0/24 add PTR 10.0.0.20 ns2.foo.com

Add a PTR with comments

   conf zone 10.0.0.0/24 add PTR 10.0.0.20 ns2.foo.com comment "string"

=cut

sub cli_add_ptr {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $ip , $host ) = $line =~/ ptr_record (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    &debug_cli(1,"addptr n($zone) ip($ip) h($host) c($comment)");

    my $obj = Infoblox::DNS::Record::PTR->new (
                  "ipv4addr" => $ip ,
                  "ptrdname" => "$host",
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a PTR from a zone

   conf zone 10.0.0.0/24 del PTR 10.0.0.20 ns2.foo.com

=cut

sub cli_del_ptr {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $ip , $host ) = $line =~/ ptr_record (\S+) (\S+)/ ;

    &debug_cli(1,"delptr n($zone) ip($ip) h($host)");

    my $obj = Infoblox::DNS::Record::PTR->new (
                  "ipv4addr" => $ip ,
                  "ptrdname" => "$host",
    );

    # addit
    &do_func("remove",$obj);

}

=head2 Add a network

   conf network add 1.1.1.0/24

Add a network with members

   conf network add 1.1.1.0/24 member 1.1.1.2,1.1.1.4

Add a network with options

   conf network add 1.1.1.0/24 option 82,"some data"

Add a network with comments (comments must come last)

   conf network add 1.1.1.0/24 comment "comment string"

=cut

# direct options :
# [ ] lease_time , domain_name , etc etc

sub cli_add_network {
    # essentially all options are passed as name value pairs
    # 
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network add (\S+)/ ;
    my ( $parent )  = $line =~/ parent (\S+)/ ;
    my ( $comment ) = $line =~/ comment "?([^"]+)"?/ ;

    my @options  = $line =~/ option (\S+)/g ;
    my @members  = $line =~/ member (\S+)/g ;

    &debug_cli (1,"addnet n($network) p($parent) m(@members) o(@options) c($comment)");

    # create the network object :

    my $net = Infoblox::DHCP::Network->new (
                   "network" => $network ,
                   "comment" => $comment ,
                   "network_container" => $parent ,
                );

    # members :
    if ( @members ) {
       my @memsvrs ;
       foreach my $memval ( @members ) {
          # split on ',' get all the IPs
          &debug_cli(2,"addnet mem($memval)");
          push @memsvrs, Infoblox::DHCP::Member->new("ipv4addr"=>$memval);
       }
       # and add them to the object
       $net->members ( \@memsvrs ) ;
    }
    elsif ( $MASTER_IP ) {
       # just add the grid master
       &debug_cli(2,"addnet mem($MASTER_IP)");
       my $DHMASTER = Infoblox::DHCP::Member->new ('ipv4addr' => $MASTER_IP);
#        my @memsvrs = ( $DHMASTER ) ;
#        $net->members ( \@memsvrs ) ;
       $net->members ( [ $DHMASTER ] ) ;
    }

    # options
    if ( @options ) {

       my @opt_list ;
       foreach my $optval ( @options ) {
          # set some custom options;
          # split on the ','
          my ( $opt , $val ) = $optval =~  /^(.*?),(.*)/ ;
   
          &debug_cli(2,"addnet o($opt) v($val)");
   
          my ($opt_obj,$key)=make_dhcp_option($DEBUG,$opt,$val) ;
          push @opt_list , $opt_obj ;
       }

#        $net->options ( \@opt_list ) ;

    }

    # add the object 
    &do_func("add",$net);

}

=head2 Remove a network

   conf network del 1.1.1.0/24

=cut

sub cli_delete_network {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network delete (\S+)/ ;

    &debug_cli(1,"delnet n($network)");

    my $net = Infoblox::DHCP::Network->new (
                   "network" => $network ,
                );

    &do_func("remove",$net);

}

=head2 Split a network

You need to specify the netmaks of the children networks when you are
doing a split. So to split a /16 into /20 networks :

   conf network 1.1.0.0/16 split /24

Split a network and add all children

   conf network 1.1.0.0/16 split /24 all

=cut

sub cli_split_network {
    #
    # splitting either creates ALL networks or only the ones
    # we have to have (which could be none)

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $ncidr ) = $line =~/ split \/(\S+)/ ;
    my ( $type )  = $line =~/ split \/\S+ (\S+)/ ;

    &debug_cli(2,"splitnet n($network) s($ncidr) t($type)");

    # create the split object
    my $obj = Infoblox::DHCP::SplitNetwork->new (
                   "network" => $network ,
                   "prefix" => $ncidr ,
                );

    # check the type
    if ( $type eq "required" ) { 
       $obj->add_all_subnetworks ( "false" ) ;
    }
    if ( $type eq "all" ) { 
       $obj->add_all_subnetworks ( "true" ) ;
    }

    &do_func("add",$obj);

}

=head2

When you split a network and want to add children you just add them to
the parent network. All other options are the same as for adding networks

   conf network 1.1.0.0/16 add 1.1.4.0/22 

=cut

sub cli_add_sub_network {
    my ( $line ) = @_ ;

    # we hack this by change the arg list to the correct syntax
    # and just calling cli_add_network

    # [ ] Add options , (or use mod_net ?)

    my ( $par , $sub ) = $line =~/ network (\S+) add network (\S+)/ ;

    $line =~ s/ network $par add network $sub/ network add $sub parent $par/;

    &debug_cli(2,"addsn pn($par) cn($sub)");
    &debug_cli(2,"addsn l[$line]");

    &cli_add_network ( $line ) ;

}

=head2 Add a fixed address

   conf network 10.0.1.0/24 add fixed 10.0.1.4 aa:bb:cc:11:22:33 

Add a fixed address with comments

   conf net 10.0.1.0/24 add fixed 10.0.1042 aa:bb:cc:11:22:33 "comment string"

=cut

sub cli_add_fixed_address {
    my ( $line ) = @_ ;

    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $ip , $mac ) = $line =~/ add fixed (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/ comment "?([^"]+)"?/ ;

    &debug_cli(1,"addfix n($network) ip($ip) mac($mac) c($comment)");

    my $obj = Infoblox::DHCP::FixedAddr->new (
                  "network" => $network ,
                  "ipv4addr" => $ip ,
                  "mac" => $mac ,
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a fixed address

For some clever reason, you don't really need to specify the parent
network to remove a fixed address, but we enforct it here to keep people
sane (In reality, any bogus string for the network name will work)

   conf network 10.0.1.0 delete fixed 1.2.3.4

=cut

# [ ] remove fixed does not work
sub cli_del_fixed_address {
    my ( $line ) = @_ ;

    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $ip ) = $line =~/ fixed (\S+)/ ;
    my ( $mac ) = $line =~/ fixed \S+ (\S+)/ ;

    &debug_cli(2,"delfix ip($ip) mac($mac)");

    my $obj = Infoblox::DHCP::FixedAddr->new (
                  "network" => $network ,
                  "ipv4addr" => $ip ,
                  "mac" => $mac ,
    );

    # addit
    &do_func("remove",$obj);

}

=head2 Add a dhcp range to a network

Dhcp ranges, by default, will get added to the Grid master unless you
override that setting with the 'member <ip>' syntax

   conf network 10.1.1.1/24 add range 10.1.1.20 10.1.1.40

Failover associations are an additional argument

   conf net 10.1.1.1/24 add range 10... failover "my_peering"

As are adding the member 

   conf net 10.1.1.1/24 add range 10... member 1.1.1.2

=cut

sub cli_add_dhcp_range {
    # essentially all options are passed as name value pairs
    # 
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $fip , $lip )  = $line =~/ add range (\S+) (\S+)/ ;
    my ( $failover )  = $line =~/ failover (\S+)/ ;
    my ( $member )  = $line =~/ member (\S+)/ ;
    my ( $comment ) = $line =~/ comment "?([^"]+)"?/ ;

    my @options  = $line =~/ option (\S+)/g ;

    &debug_cli (1,"addrng n($network) s($fip) e($lip) o(@options)");
    &debug_cli (1,"addrng n($network) m($member) c($comment) f($failover)");

    # create the object
    my $obj = Infoblox::DHCP::Range->new (
                   "network" => $network ,
                   "start_addr" => $fip ,
                   "end_addr" => $lip ,
#                    "comment" => $comment ,
#                    "options" => \@opt_list ,
#                    "member" => $member ,
                );

    # add the optional extras
    if ( $comment ) { $obj->comment ( $comment ) }

    # you can't assign failover and members, you have to choose one.
    if ( $failover ) { 
         $obj->failover_assoc ( $failover ) 
    }
    else {
       # find a member to put this range on
       if ( $member ) {
          # not the grid master
          &debug_cli(2,"addrng mem($member)");
          my $memobj = Infoblox::DHCP::Member->new("ipv4addr"=>$member);
          $obj->member ( $memobj ) ;
       }
       elsif ( $MASTER_IP ) {
          &debug_cli(2,"addrng mem($MASTER_IP)");
          my $DHMASTER = Infoblox::DHCP::Member->new ('ipv4addr'=>$MASTER_IP);
          $obj->member ( $DHMASTER ) ;
       }
    }


    # options
    if ( @options ) {

       my @opt_list ;
       foreach my $optval ( @options ) {
          # set some custom options;
          # split on the ','
          my ( $opt , $val ) = $optval =~  /^(.*?),(.*)/ ;
   
          &debug_cli(2,"addnet o($opt) v($val)");
   
          my ($opt_obj,$key)=make_dhcp_option($DEBUG,$opt,$val) ;
          push @opt_list , $opt_obj ;
       }

#        $net->options ( \@opt_list ) ;

    }

    # add the object
    &do_func("add",$obj);

}

=head2 Remove a dhcp range

   conf net 1.1.1.1/24 delete range 1.1.1.20 1.1.1.40

=cut

sub cli_del_dhcp_range {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $fip , $lip )  = $line =~/ range (\S+) (\S+)/ ;

    &debug_cli (1,"delrng n($network) s($fip) e($lip)");

    my $obj = Infoblox::DHCP::Range->new (
                   "network" => $network ,
                   "start_addr" => $fip ,
                   "end_addr" => $lip ,
                );

    &do_func("remove",$obj);

}

# [ ] broken until i get syntax to set the Grid name

=head2 add global DHCP settings

   conf grid <name> add dhcp lease-time 3600

Custom optons

   conf grid <name> add dhcp option 82,"opt 82 string" 

Set the type for a custom option
   
   conf grid <name> add dhcp option 82 type IPADDRESS

Remove a custom option

   conf grid <name> delete dhcp option 82

=cut

###########
# my $option1 = Infoblox::DHCP::Option->new(
#                    "type" => "lease-time",
#                    "seconds" => "50"
#                    );
# my $option1 = Infoblox::DHCP::Option->new(
#                    "type" => "routers",
#                    "ipv4addrs" => [ "1.4.1.1" , "2.2.2.2" ],
#                    );
# 
# my $option2 = Infoblox::Cluster::DHCP::Custom_option->new(
#                    "num" => "1",
#                    "type" => "ip-address",
#                    "value" => "255.0.0.0",
#                    );
# 
# $dhcp->options( [ $option1 , $option2 ] );
###########

sub cli_add_global_dhcp {

    my ( $opt , $val , $type , @extra ) = @_ ;
    if ( (! $opt ) or ( ! $val ) ) {
       &missing_arg("<option> <'type'|value>")  ;
       return ;
    }

    # all these custom opts are conditional, damn
    my @opts = ( "lease-time","custom_option",
                 "routers","nameservers","domain-name",
                 "broadcast",
                );

    # but we can at least abbrev them.
    my %optlist = abbrev ( @opts ) ;
    my $eopt = $optlist{ lc($opt) } ;
    # sput error
    if ( ! $eopt ) { 
          &missing_arg(@opts );
          return ;
    }

    # look for 'type' (or anything else)
    # we don't abbrev to avoid namespace conflicts
    # if we find it, we shuffle the args

    my $etype ;
    if ( $eopt eq "custom_option" ) {
       if ( $type =~ /^type$/i ) {
          $etype = $type ;
       }
       else {
          unshift @extra , $type ;
       }
    }

    # now match quoted strings ( $etype will be undef )
    my ( $data , @extra ) = &get_comment ( @extra ) ;

    &debug_cli(2,"modglob o($eopt) v($val) t($etype) d($data)");

    # ok , now we have the conditional loop to build the options
    my $obj ;

    if ( $eopt eq "lease-time" ) {
       $obj = Infoblox::DHCP::Option->new(
                      "type" => "lease-time",
                      "seconds" => $val,
                   );
    }
    elsif ( $eopt eq "routers" ) {
       my @iplist = split ( "," , $val ) ;
       $obj = Infoblox::DHCP::Option->new(
                      "type" => "routers",
                      "ipv4addrs" => \@iplist,
                   );
    }
    elsif ( $eopt eq "nameservers" ) {
       my @iplist = split ( "," , $val ) ;
       $obj = Infoblox::DHCP::Option->new(
                      "type" => "nameservers",
                      "ipv4addrs" => \@iplist,
                   );
    }
    elsif ( $eopt eq "broadcast" ) {
       $obj = Infoblox::DHCP::Option->new(
                      "type" => "broadcast",
                      "ipv4addr" => $val,
                   );
    }
    elsif ( $eopt eq "domain-name" ) {
       $obj = Infoblox::DHCP::Option->new(
                      "type" => "domain-name",
                      "name" => $val,
                   );
    }

    # customss
    elsif ( $eopt eq "custom_option" ) {
       if ( $etype ) {
          # just set the type
          &debug_cli(2,"modglob adding custom type");
          $obj = Infoblox::Cluster::DHCP::Custom_option->new(
                   "num" => $val,
                   "type" => $data,
                   "value" => "",
                   );
       }
       else {
          &debug_cli(2,"modglob adding custom value");
          $obj = Infoblox::DHCP::Option->new(
                      "type" => $val,
                      "value" => $data,
                   );
       }
    }

    # now we have to get the global props and re-set them.
    # [GDH] - unhardcode the cluster name
    my %args = (
                         "object" => "Infoblox::Cluster::DHCP",
                         "cluster" => "Infoblox",
    );

    
    my ( $cluster ) = &do_func("get", %args ) ;

    if ( $cluster ) {
        # add the option, make the changes;
        $cluster->options( [ $obj ] ) ;
    print Dumper ( \$cluster ) ;
        &do_func("modify", $cluster ) ;
    }


}

=head2 Remove a custom option

   conf network global delete custom_option 82
   conf network global delete lease_time

=cut

sub cli_del_global_dhcp {
}

=head2 modify a network

TBD

=cut

sub cli_mod_network {
}

# End -- API ---

#
# show stuff
#

=head1 SHOW commands

=head2 Showing Zones

Show all zones

    show zone

Show all forward zones

    show zone forward

Show all reverse zones

    show zone reverse

Show just 1 zone

    show zone foo.com

=cut


sub cli_show_zone {
    #
    # [ ] show needs some cleanup
    # splitting either creates ALL networks or only the ones
    # we have to have (which could be none)

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $type ) = $line =~/ zone (\S+)/ ;

    &debug_cli(2,"showz t($type)");

    # get all the zones
    my %opthash = (
           "object" => "Infoblox::DNS::Zone", 
           "name" => ".*" 
    );

    my @zones = &do_func("search", %opthash );

    # we can't sort on oid, we have to sort on name
    my @forzones ;
    my @revzones ;
    foreach my $zone (@zones) {
      my $name = $zone->name();
      if ( $name =~ /\/\d+$/ ) {
         push @revzones , "  $name\n";
      }
      else {
         push @forzones , "  $name\n";
      }
    }

    # now print them (sorted)
    if ( $type eq "forward" ) { print sort @forzones ; }
    elsif ( $type eq "reverse" ) { print sort by_ip @revzones ; }
      # specific zone ?
    elsif ( $type ) { }
    else { 
       print sort @forzones ; 
       print sort by_ip @revzones ; 
    }
    
}

=head2 Showing networks

=cut

sub cli_show_network {
    #
    # splitting either creates ALL networks or only the ones
    # we have to have (which could be none)

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $net ) = $line =~/ network (\S+)/ ;

    &debug_cli(2,"shown n($net)");

    # get all the zones
    my %opthash = (
           "object" => "Infoblox::DHCP::Network", 
           "network" => ".*" 
    );

    my @nets = &do_func("search", %opthash );

    my @netlist ;
    foreach my $net (@nets) {
      my $name = $net->name();
      push @netlist , "  $name\n";
    }

    # now print them (sorted)
    print sort @netlist ; 
    
}

=head2 Showing leases

Show a lease

    show lease ip 1.1.1.1
    show lease mac aa:aa:aa

=cut

# [ ] get a lease with a regex...

=head2 Showing records

Show a host

    show host test.foo.com

=cut

=head2 Showing ranges

=cut

#
# SERVER CONNECTION STUFF.....
#

=head1 Server Management

=head2 Connect to a server

    conf server <SERVER> user <USERNAME> password <PASSWD>

Select a server to talk to

    server ? > conf server 10.0.1.230 
    10.0.1.20 >

Supply the username and or password
   
    server ? > conf ser 10.0.1.230 user admin pass infoblox
    admin@10.0.1.20 >
        
=cut

sub cli_add_server {

    my ( $line ) = @_ ;

    # get the args from the line
    ( my $server)  = $line =~/server (\S+)/ ;
    ( my $user)    = $line =~/user (\S+)/ ;
    ( my $passwd)  = $line =~/password (\S+)/ ;

    &debug_cli (2,"add svr s($server) u($user) p($passwd)");

    $MASTER_IP = $server ;

    # create the session handler
       $SESSION = Infoblox::Session->new( 
                     "master" => $server,
                     "username" => $user,
                     "password" => $passwd ,
                  );

      if ( $SESSION->status_code() ) {
          my $result = $SESSION->status_code();
          my $response = $SESSION->status_detail();

          print "  Error : $response ($result)\n";
      }
      else {
         $ONLINE = 1 ;
         $PROMPT = "$user\@$server > " ;
         $el->set_prompt ( $PROMPT );
      }

#     if ( $ONLINE ) {
#     }
#     else {
#       print "OFFLINE!\n" ;
#     }
 
    # update the prompt ;

    

}

=head2 Restarting services

the cli will not restart services, you have to do that manually

   restart dns
   restart dhcp

IF you want to delay the restart you can do that also

   restart dns delay 10

=cut

sub cli_restart {

    my ( $line ) = @_ ;

    # get the args from the line
    ( my $service)  = $line =~/restart (\S+)/ ;
    ( my $delay)  = $line =~/delay (\S+)/ ;

    &debug_cli (2,"restart s($service) d($delay)");

    my %opthash ;
    $opthash{'service'}=$service;
    $opthash{'when'}=0;
    if ( $delay ) {
       $opthash{'delay'}=$delay;
    }

    my @function=("restart",%opthash);
    &do_func(@function);

}

=head2 Export the database

    download database <file>

=cut

sub cli_download {

    my ( $line ) = @_ ;
    # get the args from the line
    ( my $dest)  = $line =~/database (\S+)/ ;

    my %opthash = (
          "path" => $dest ,
          "type" => "backup",
          "format" => "tar",
    );

    print "DOWNLOADING ALL DATABASE data as $dest ...\n";

    my @function=("export_data",%opthash);
    &do_func(@function);

    print "DONE\n";
}


###########################################
#
# END API calling functions.
#
###########################################

sub make_dhcp_option {
    print "  OPTIONS not supported\n";
}

sub by_ip {
    # used for sorting (by_ip)
    &abs_ip($a) <=> &abs_ip($b) ;
}

sub abs_ip {
    # get an IP as a real absval
    my ( $ip ) = @_ ;

    # strip cidr crap
    $ip =~ s/\/.*//;

    my @octets = split(/\./,$ip) ;

    my $absval = $octets[3] + ( 2 ** 8 * $octets[2] ) ;
       $absval = $absval + ( 2 ** 16 * $octets[1] ) ;
       $absval = $absval + ( 2 ** 24 * $octets[0] ) ;

    return ($absval) ;
}


sub debug_commands {
    my ( $line ) = @_ ;
    # get the args from the line
    ( my $type)  = $line =~/debug (\S+)/ ;

    if ( $type eq "commands" ) {
       # dump crap to tty
       print Dumper ( \%COMMANDS );
    }
    if ( $type eq "session" ) {
       # dump crap to tty
       print Dumper ( \$SESSION );
    }
}

sub set_debug {
                
    my ( $line ) = @_ ;
    # get the args from the line
    ( my $level)  = $line =~/debug (\S+)/ ;

    print "DEBUG = $level\n";
    $DEBUG = $level ;
}

=head2 Debugging :

  configure debug <level>

The higher the debug level, the more junk gets spat to the tty. You
probably don't want anything higher than (2) unless you are debugginh the
completion control parser.

=cut



sub debug_cli {
    # we're passed a message and a level
    # if this level is <= the CURRENT DEBUG level 
    # we print the data
    my $level = shift @_ ;

    if ($level <= $DEBUG) {
#         if ( $MAKE ) { print "# " ; }
        print "($level) DEBUG: @_\n";
    }

}

#############################

# $Log: ibcli,v $
# Revision 3.2.2.1  2005/09/29 17:20:24  horne
# *** empty log message ***
#
# Revision 3.1.2.5  2005/09/29 17:18:13  horne
# *** empty log message ***
#
# Revision 3.1.2.4  2005/09/26 22:16:29  horne
# added support for failover and forwarders
#
# Revision 3.1.2.3  2005/08/15 20:44:42  horne
# added the rest of the perldoc
#
# Revision 3.1.2.2  2005/08/15 01:23:12  horne
# some rearranging of coments, mostly
#
# Revision 3.1.2.1  2005/08/14 23:31:43  horne
# *** empty log message ***
#
# Revision 3.1  2005/08/14 23:14:23  horne
# Bumped the rev#
#
# Revision 2.11  2005/08/14 23:13:11  horne
# *** empty log message ***
#
# Revision 2.10  2005/08/14 23:07:23  horne
# last version, this now gets replaced by complt with Readline
#
# Revision 2.9  2005/07/13 05:07:06  horne
# major fixes of some of the parser bits
# added additional functions to add zone
#
# Revision 2.8  2005/04/22 20:09:17  horne
# *** empty log message ***
#
# Revision 2.7  2005/03/22 01:01:18  horne
# *** empty log message ***
#
# Revision 2.6  2005/03/05 19:27:15  horne
# added support for custom options
#
# Revision 2.5  2004/12/22 20:52:05  horne
# fixed the commit prompt
# changed commit to 'reatart'
# really cleaned up the connection handler
# changed all 'set' to 'conf'
# cleaned up pod examples
#
# Revision 2.4  2004/12/20 15:57:03  horne
# *** empty log message ***
#
# Revision 2.3  2004/12/18 12:53:46  horne
# Ripped out all the recursive hash print stuff and replaced it with
# Data::Dumper instead (much cleaner)
#
# Revision 2.2  2004/12/18 12:10:13  horne
# this version has perldoc
#
# Revision 2.1  2004/12/14 05:09:01  horne
# first round of bug testing
# also added member support
# also add import zone
#
# Revision 2.0  2004/11/03 19:58:48  horne
# new code suporting the infoblox V3 API
# major rewrite
#
# Revision 1.18  2004/10/20 16:44:39  horne
# broken checkin - ignore
#
# Revision 1.17  2004/08/13 05:21:09  horne
# Added correct connection handling
#
# Revision 1.16  2004/08/13 03:57:45  horne
# Major changes to the arg parsers, args are now sent as arrays and the
#   do_ib_func does the formatting/prettyprinting
# Added conection syntax to hanvle V3 connections
# Added a whole bag of RADIUS commands
#
# Revision 1.15  2004/08/01 19:34:03  horne
# Added 'peer_assoc' support for V2.5
#
# Revision 1.14  2004/06/16 20:19:46  horne
# added comments to ptrs
# added modify global dhcp opts
#   conf dhcp global
# added fixed addresses
# added modify network options
#   conf net x.x.x.x/mm modify opt value
# added non-auth networks
#
# Revision 1.13  2004/02/13 20:11:21  horne
# added the command lister
#
# Revision 1.12  2003/11/26 01:29:09  horne
# *** empty log message ***
#
# Revision 1.11  2003/11/06 07:31:28  horne
# server and password now live on the same commandline
# upload and download database
# import zone
# conf zone add now takes additional options
#
# the software now writes its own code
#
# Revision 1.10  2003/10/16 21:41:25  horne
# un hardcoede dig
# changed password syntax
# added a -V -v option (version)
# added download commands
#
# Revision 1.9  2003/09/24 01:43:08  horne
# added dhcp range stuff
# cleaned up the dig pre-processing
#
# Revision 1.8  2003/09/22 21:37:30  horne
# added prt functions
# cleaned up show network
#
# Revision 1.7  2003/09/22 19:24:30  horne
# *** empty log message ***
#
# Revision 1.6  2003/09/21 23:04:29  horne
# added ambiguous commands
# prints now wrapped for cli or batch
# batch commands now work
#
# Revision 1.5  2003/09/20 01:22:36  horne
# First full working version with the abstracted argument parser.
# there is still a lot of gumpf in here, but most of the repeatable code is
# now packed into subroutines
#
# Revision 1.4  2003/09/18 02:28:56  horne
# *** empty log message ***
#
# Revision 1.3  2003/09/16 23:17:25  horne
# *** empty log message ***
#
# Revision 1.2  2003/09/09 22:58:27  horne
# *** empty log message ***
#
# Revision 1.1  2003/08/11 23:31:57  horne
# INFOBLOX version, re-set the CVS counters
#
# Revision 1.9  2001/06/07 16:45:47  horne
# major rewrite of the arg parser - ripped out all the RE's to a much better
# process.
# delete commands disabled
#
# Revision 1.8  2001/05/31 05:28:15  horne
# *** empty log message ***
#
# Revision 1.7  2001/05/24 00:17:54  horne
# Added RE's to handle shortened commant words, not however that this is
# still buggy, typos, as long as they are unique will still work. thus
#  - password, p , pa , ps , pdfgt = password
# I need to find a better command parser
#
# Revision 1.6  2001/05/23 19:39:11  horne
# working version - waiting for updates from infoblox to see if they have
# changed the API syntax
#
# Revision 1.5  2001/05/19 06:08:13  horne
# iblox ready version, but no connections to servers work
#
# Revision 1.4  2001/05/19 04:59:19  horne
# All base commands are being parsed and netmasks are being applied.
# Now we need to hit the infoblox engine for real
#
# Revision 1.3  2001/05/19 03:43:45  horne
# added the DEBUG option before i started to drown in a lot of messy print
# statements
#
# Revision 1.2  2001/05/19 03:34:34  horne
# Basic version, config file parsing is functional.
#
# Revision 1.1  2001/05/19 03:33:56  horne
# *** empty log message ***
#
