#!/usr/bin/perl
#
# (c) Copyright: Geoff horne, SLC 2001-2005
#               All rights reserved
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. So there...
#
# THIS TICKET IS SOLD SUBJECT TO THE SELLERS CONDITIONS OF SALE OF COPY
# WHICH IS AVAILABLE FOR INSPECTION AT TIME OF PURCHASE AND/OR CONDITIONS
# OF THIS TICKET AND ALSO (TO THE EXTENT THAT THEY ARE NOT INCONSISTENt
# WITH THE SELLERS CONDITIONS OF SALE) THE FOLLOWING:
# 
# 1: A CHANGE IN CONDITIONS OF THE PURCHASER DOES NOT ENTITLE THE PURCHASER
#    TO RETURN OR EXCHANGE TICKET.
# 
# 2: THE SELLER RESERVES THE RIGHT TO:
#    - ADD, WITHDRAW OR SUBSTITUTE ARTISTS
#    - VARY ADVERTISED PROBRAMMES, SEATING ARRANGEMENT AND AUDIENCE
#      CAPACITY , AND:
#    - REFUSE ADMISSION WITH REASONABLE CAUSE
#
# 3: CAMERAS AND TAPE RECORDERS MAY NOT BE PERMITTED. LATE ARRIVALS MAY
#    RESULT IN NON-ADMITTANCE UNTIL A SUITABLE BREAK IN PERFORMANCE. THE
#    SELLER REQUESTS THAT ALL PAGERS AND MOBILE PHONES BE TURNED OFF BEFORE
#    ENTRY.
#
# 4: IF AN OUTDOOR PERFORMANCE IS CANCELLED DUE TO ADVERSE WEATHER OR ANy
#    OTHER CAUSE REASONABLY BEYOND THE SELLERS CONTROL, THERE IS NO RIGHT 
#    TO A REFUND OR EXCHANGE, AND THE SELLER IS NOT OBLIGED TO ARRANGE A 
#    SUBSTITUTE SERVICE, EVENT OR PERFORMANCE
#
# StreetLevel Communications
#
#            support@slc.com.au
#            ph: +1-650-483-0998
#
###############################################################################

#### work out where i am
# these 3 varables can then be used to find config files
# and keep the code portable

use FindBin qw($Bin $Script);
my ($BASE,$NAME)=($Bin,$Script) ;

#   $Id: ibcli,v 2.6 2005/03/05 19:27:15 horne Exp $
my $REV = "\n$BASE/$NAME" . '
$Revision: 2.6 $
$Date: 2005/03/05 19:27:15 $
';
$REV =~ s/\$//g;

# uncomment the following two lines to see what the options hash contains
#[ ] use Data::Dumper;
#[ ] print Dumper \%options;

# Perl CGI common chunks
#
use strict ;
no strict "refs" ;
use Getopt::Long ;
use Text::Abbrev ;

# include infoblox , find the path ???
# this is done at compile time so we need to use a method...
use lib "$FindBin::Bin";

use Infoblox::InfobloxDNS;
use Infoblox::RADIUSOne ;
use Infoblox;
use MIGRATION;

######################
#
# define some globals
#
my $DNS_VER = 3 ;

my $DEBUG = 0 ;
my $CLI = 0 ;
my $MADE_CHANGES = "!" ;

my $IPRE = '\d+\.\d+\.\d+\.\d+';

my %CONN_INFO ;
my $PUB_SESS ;
my $PRI_SESS ;

my $CONNECTED ;
my $CONFIG ;
my $MAKE ;
my $LIST_COMM ;
my $GET_VERSION ;
my @LIST_BRANCH ;

my $GOOD_COMMAND ;
my $LINE ;

my $SAVE_HIST ;
my @CLIST ;
my @WORDS ;
my @HISTORY ;

my $PROMPT ;

my @P_ARGS ;

#
# WTF is P_ARGS ??
#
# Well, grasshopper, some subroutines need to know some of the earlier
# arguments, so we keep these in a stack and pass them around where
# necessary. it is a global because all sorts of subs will want to play
# with it...
#

# optional args
# -f <config file>
# -s <server>
# -p <password>
# -d <debug level>
# -m make a script

my $S_ID ;
my $S_USER ;
my $S_PASS ;

GetOptions(
      "s=s" => \$S_ID , 
      "p=s" => \$S_PASS ,
      "u=s" => \$S_USER ,
      "f=s" => \$CONFIG ,
      "d=s" => \$DEBUG ,
      "l=s" => \$DNS_VER ,
      "m+"  => \$MAKE ,
      "t+"  => \$LIST_COMM ,
      "v|V"   => \$GET_VERSION ,
   );

   #

if ( $GET_VERSION ) {
   &show_version ;
   exit 0 ;
}

## NOTE - to make a better CLI version we should have a wrapper loop that
#  checks if you are coming in as a file or STD in. The primary loop in
#  either case should pass to the actual arg parser

# catch fools who forget to do a '-f'
if ( @ARGV ) { $CONFIG = shift ; }

# are we in make mode ?
if ( $MAKE ) { &script_header }

&err_print("Using Version [$DNS_VER] Syntax");

# check if we need to do any initial conections
# use temp vars to avoid a clobbering problem
#
# the existece of variables is checked in the called sub

$PROMPT = "no server > " ; 
# a successfull connect success changes the prompt

if ( $S_ID ) {
   &add_server($S_ID,"user",$S_USER,"password",$S_PASS);
}

#
# are we interactive or in batch mode ?
#
if ( ! $CONFIG ) {
   print "CLI version\n";
   $CLI = 1 ;
   # unflush the buffer
   $| = 1 ;

   # set initial prompt
   &print_prompt ;
}

if ( $CONFIG ) { 
   # make 'while(<>)' still work...
   push @ARGV , $CONFIG  ;
}

#####################################################################
# perldoc goes here

=head1 NAME

The INFOBLOX CLI, a users guide

=head1 Synopsis

*A guide for Infoblox SEs and other commandline junkies*

=head1 Description

This is 
$Revision: 2.6 $
there were previous versions that were even worse, this one is pretty bad,
it really is beta code.  But it is a start.

So why do this, what is this CLI for ? Well there were a few primary
reasons:

=over

=item Quick changes are now easy,

You don't need to wait for a GUI to start or get the right version
of java functional, this allows you to quickly get into the database
and make some simple and efficient changes

=item Abstract command set

Now you don't need to know the intricacies of the API, a few simple
commands will achieve the same effect, if you are a user that
doesn't know PERL you can still drive the CLI and get the results
you need. This may not be an advantage if you are reading data from
another system to import into an Infoblox unit (since you still need
to write software to parse the data, eg PERL) but it may still help
and end user that can convert this data in to the CLI command set
but not know enough to write PERL.

=item Customers wanted it

    Need I say more ?

=back 

Lastly, why is this called 'ibcli' and not 'DNScli' ? Well, this is just
a wrapper to any API we like, it is not really DNS specific.


=head1 Quickstart

Simple example, adding a zone

   [0] ! no server > conf server 10.0.1.224 user admin pass infoblox
   [0]   admin@10.0.1.224 > conf zone add infoblox.com
   [0] * admin@10.0.1.224 > conf zone add sales.infoblox.com

A more detailed example

   [0] ! no server > conf server 10.0.1.224 user admin pass infoblox
   [0]   admin@10.0.1.224 > conf zone add com
   [0] * admin@10.0.1.224 > conf zone add foo.com
   [0] * admin@10.0.1.224 > conf zone foo.com add host test 1.2.3.4
   [0] * admin@10.0.1.224 > conf zone delete bar.com

A complex example, multiple connections

   [0] ! no server > conf server 10.0.1.224
   [0] ! 10.0.1.224 > conf server user admin
   [0] ! 10.0.1.224 > conf server pass infoblox
   [0]   admin@10.0.1.224 > conf zone add sales.foo.com

   # now switch servers
   [0]   admin@10.0.1.224 > conf server 10.0.1.200
   [0]   admin@10.0.1.220 > conf server user admin1
   [0]   admin1@10.0.1.220 > conf server pass infoblox1
   [0]   admin1@10.0.1.220 > conf zone add biz.foo.com

=head1 Installation

It should run 'as is' from a uniz machine. 

If you have a windows OS then you will have a few hurdles to cross:

=over

=item * Rename the script to 'ibcli.pl'. 

I still don't understand why Windows uses file suffix to type its data
rather than doing something intelligent like looking at the contents of
the file, but then, we are dealing with people who thought 8.3 was all
you'd ever need as a file namespace and 640K for ram...

=item * Make sure you have the necessary libraries installed, 

you'll need:

   o Getopt::Long

   o Text::Abbrev

=item * Get access to 'dig' 
      ...If you want the 'show' commands to work.

=back

=head1 Getting started

Run the ibcli - it is a perl script, you will get a prompt

    % ./ibcli
    CLI version
    [0] ! no server >

Ideally, you should now connect the CLI to a server somewhere, to do
this you give it the server and a user and a password, you can do these in
either order, it just tries to eventually connect when it has enough data.

    [0] ! no server > conf server 10.0.1.224
    [0] ! 10.0.1.224 > conf server user admin
    [0] ! 10.0.1.224 > conf server pass infoblox
    [0]   admin@10.0.1.224 >

Or you can also do this from the initial invocation:

    % ./ibcli -s 10.0.1.230 -u admin -p infoblox 

"HOLD ON A SEC", I hear you ask, "Why am i connecting to a server, isn't
this CLI running on a console somewhere ?". No, Grasshopper, the CLI is
just a wrapper to the Infoblox.pm so you can run it from anywhere in
the world. This gives you the added advantage of being able to work on
MANY servers from the one CLI.

=head1 Setting the debug level

    [0] ! no server > conf debug 3
    [3] ! no server >

Or you can also do this from the initial invocation:

    % ./ibcli -d 3


=head1 Other Gritty Details

OK, so what the hell can I do from here ?

=head2 Members and secondaries

By default all stuff is added to just the Cluster Master, the API guesses
this from the SERVER setting. If you explicitly want to add stuff to
certain members you need to append the members to the command arg :

   conf zone add foo.com members 1.2.3.4
   conf zone add foo.com members 1.2.3.4,1.2.3.5

=head2 Laziness

The command parser accepts abbreviations

    se z a foo.com

is the same as

    conf zone add foo.com

There is also command ambiguity. since the command parser uses seperate
code to the actual library calls it is easy to make multiple commands
mean the same thing.

    * 'show' or 'get' mean the same thing
    * 'set' or 'configure' mean the same thing
    * 'delete' or 'remove' mean the same thing


=head2 BATCH processing

You can read a set of commands from a file, and then pass them to the
CLI via the -f option

   # 
   # meta input language for infoblox DNSOne scripts
   #
   # SAMPLE input file
   #
   
   # set the debug level
   conf DEBUG 1
   
   # server likes either names or IP's
   #
   conf SERVER 45.0.12.20
   conf SERVER USER admin
   conf SERVER PASSWORD infoblox
   
   conf zone add foo.com
   conf zone foo.com add host 2-bulktest 45.103.1.2
   conf zone foo.com add host 3-bulktest 45.103.1.3
   conf zone foo.com add host 4-bulktest 45.103.1.4
   conf zone foo.com add host 5-bulktest 45.103.1.5
   
   # scripts commit and disconnect by default.
   #
  

And then just run the script

    % ./ibcli -f sample.in


=head2 Write your own code

In the essence of a recursive 'eat your own dogfood' mentality, it is
actually possible to get the CLI to write out self executing perl
scripts. You do this with the -m option

    ibcli -m -f <config_file>

You may not see the immediate benefit of this, but it really helps if you
can't recall the API syntax. It also helps if you are in a
situation where you have set up a CLI config file but want to give 
someone else reproducable programmes without giving them the CLI tool
you will understand the value of this.

Perhaps an example would work. Given this input :

   # 
   # meta input language for infoblox DNSOne scripts
   #
   # SAMPLE input file
   #
   # server likes either names or IP's
   #
   conf SERVER 45.0.12.20
   conf SERVER USER admin
   conf SERVER PASSWORD infoblox
   
   conf zone add foo.com
   conf zone foo.com add host 2-bulktest 45.103.1.2
   conf zone foo.com add host 3-bulktest 45.103.1.3
   conf zone foo.com add host 4-bulktest 45.103.1.4
   conf zone foo.com add host 5-bulktest 45.103.1.5

   # scripts commit and disconnect by default.
   #
  

The CLI will produce the following perl script

  #!/usr/bin/perl
  #
  # AUTOGENERATED from ibcli 
  #
  
  use Infoblox::InfobloxDNS;
  use Infoblox::RADIUSOne;
  use Infoblox;
  
  # Using Version [3] Syntax : 
  print "Infoblox::Session->new \n";
    my $result = Infoblox::Session->new ( $SESSION ,
       {
         'UserName' => 'admin',
         'cli_type' => 'dns',
         'UserPassword' => 'infoblox',
         'Host' => '45.0.12.20'
       }
     );
  
  print "add_zone \n";
    my $result = add_zone ( $SESSION ,
       {
         'cluster_primary' => undef,
         'name' => 'foo.com',
         'type' => 'Authoritative'
       }
     );
  print "add_host \n";
    my $result = add_host ( $SESSION ,
       {
         'zone' => 'foo.com',
         'name' => '2-bulktest',
         'address_list' => [
           {
             'address' => '45.103.1.2'
           }
         ]
       }
     );
  print "add_host \n";
    my $result = add_host ( $SESSION ,
       {
         'zone' => 'foo.com',
         'name' => '3-bulktest',
         'address_list' => [
           {
             'address' => '45.103.1.3'
           }
         ]
       }
     );
  print "add_host \n";
    my $result = add_host ( $SESSION ,
       {
         'zone' => 'foo.com',
         'name' => '4-bulktest',
         'address_list' => [
           {
             'address' => '45.103.1.4'
           }
         ]
       }
     );
  print "add_host \n";
    my $result = add_host ( $SESSION ,
       {
         'zone' => 'foo.com',
         'name' => '5-bulktest',
         'address_list' => [
           {
             'address' => '45.103.1.5'
           }
         ]
       }
     );
  
  
  
  exit ; 

=cut

##########################################
   
# read the lines
# the datastructure is kinda nested, but the command set is still small
# enough to avoid some sort of lexical overhead subroutine
#
# also if you build this as a hash it becomes harder to read, you need to
# visualise each argument block in one chunk

# set the first level command set
my %commands = ( 
            'history' => 'show_history',
            'restart' => 'restart',
#             'connect' => 'connect',
#             'disconnect' => 'disconnect',
            'download' => 'download_commands',
#             'upload' => 'upload_commands',
            'set' => 'set_commands' ,
            'configure' => 'set_commands' ,
            'show' => 'show_commands' ,
            'get' => 'show_commands' ,
            'exit' => 'do_exit' ,
            'quit' => 'do_exit' ,
) ;

# if we were called with a "-c" we are dumping the command parsing tree
if ( $LIST_COMM ) {
   print "$REV\n";

   &walk_tree(%commands) ;
   exit ;
}

#
# time to read commands, line at a time...
#

while (<>) {

   # strip blanks, comments etc
   if ( /^\s*#/ ) { 
      if ( $MAKE ) { print $_ ; }
         &print_prompt ; 
         next ; 
   } ;

   if ( /^\s*$/ ) { 
      if ( $MAKE ) { print $_ ; }
         &print_prompt ; 
         next ; 
   } ;

   $GOOD_COMMAND = 1 ;
   $SAVE_HIST = "" ;

   chomp ;

   #
   # Pattern matching, we want 'fuzzy' matches but only in the form of
   # abbreviations, if the command is 'server', 'ser' and 'serv' should
   # match but not 'serf'. FORTUNATELY, there seems to be a perlmodule
   # for this. ( Text::Abbrev )
   #
   # and the nice thing is that we can build up a hash
   # of command to subroutine matching, the abbrev code will
   # find the right command to call, then we can pass the WHOLE line to
   # the required routine.
   #
   # HOWEVER, the additional args at the end of the line will break the
   # abbrev match, so we still need to eat the line - 1 word at a time
   # and branch apropriately
   #
   # if the abbrev gets an ambiguous match, we return '0'...

   # we have a problem in that if we get a match on the first arg we are
   # still in 2 states
   #  - execute
   #  - check for more args
   #  - check for more commands
   #
   # after the branching we still keep track of :
   #  - the original command (for history)
   #  - the optional args
   # and IF WE GET A MATCH, we say the command is good and THEN execute


   # SO break the commandline into components
   #
   # @WORDS is a global, because we want to keep eating the array
   # regardless of what routine we are in. At the end of the parsing, we
   # should end up with the command ($SAVE_HIST) and the args (@WORDS)
   #
   # SO, if there are more args that need to be checked, the subroutine
   # to call should be a simple one that just resets $commands and makes
   # another call to 'shift_Arg'
   #
   $LINE = $_ ;

   # [ ] need a way to find strings protected by quotes ( "xxx yyy" )
   @WORDS  = split /\s+/ ;
   @P_ARGS = () ;
   my $arg = shift @WORDS ;

   &shift_arg($arg,%commands);

   # history - if kosher
   # ( done at the end, after all other line processing... )
   if ( $GOOD_COMMAND ) {
      &addhistory($SAVE_HIST , @WORDS);
   }

   # lastly - the prompt
   &print_prompt ;
   
}

# just in case
&do_exit ;

################################################################

# 
# EXIT
#
sub do_exit {
    $LINE = "exit" ;
    if ( $CONNECTED ) { 
#        &commit ;
    }

    if ( $MAKE ) { &script_footer }

    exit ;
}

#
# shift arg, once we've set up a new %commands hash
# we just want to call shift_arg to do the rest of the processing
#
# THIS is the guts of the command line parser, for each ARG in a line
# shift_arg looks at this word, does an apprev match, and if it is ok
# then calls the hashed subroutine.
#
# The nice thing about this is that the subroutines can either be end
# points (do this feature) or subroutines that set possibilities for the
# next arg value. This has more power then putting ALL the commands in a
# treed hash since we can jump around tween subs as much as we like
#
# [ you just have to keep track of the parser subroutines :-) ]
#
sub shift_arg {

   my ( $arg , %commands ) = @_ ;

   if ( $LIST_COMM ) { &walk_tree(%commands) ; return ; }

   # generate the abbreviation list for these args
   @CLIST = sort keys %commands ;
   my %clookup = abbrev ( @CLIST ) ;

   # $full_comm does the abbreviation lookup and gets the
   # ACTUAL full comand name, or returns '0' so the expansion
   # is automatic, but sometimes full_comm can be a wildcard
   # so we check the existence of the subroutine to call instead.
   #
   # and we hack history accordingly
   
   my $full_comm = $clookup{ lc($arg) };
   &debug (4,"shift: h($SAVE_HIST) arg($arg) com[$full_comm]");

   # we set $call_sub , coz we risk re-setting $full_com ;
   my $call_sub = $commands{$full_comm} ;
   if ( $call_sub ) {
      &debug (4,"shift: sub($call_sub)");

      # catch wildcards...
      # and save them as arguments , not commands
      if ( ! $full_comm ) { 
         $full_comm = $arg  ;
         push @P_ARGS , $arg ;
      }
      $SAVE_HIST .= "$full_comm " ;

      &rd_line($call_sub) ;
   }
   else {
      &missing_arg(@CLIST)  ;
   }
}

# parse a line, this is called EVERYTIME we press <cr> so we can
# do things like print the prompt
# we abstract this to keep it in one place
#
sub rd_line {

    # we're passed :
    #  the subroutine to call
    #  the subroutine arguments
    #
    #  if we are eating more of the args, we append to savehistory...

    my ($command) = @_ ;

    &debug (4,"rd_line b: c[$command] h[$SAVE_HIST] , go_c [$GOOD_COMMAND]");
    &debug (4,"           p_args[@P_ARGS] words[@WORDS]");

    # call the command (and any prev args...)
    &$command(@P_ARGS,@WORDS);

    #
    &debug (4,"rd_line a: c[$command] h[$SAVE_HIST] , go_c [$GOOD_COMMAND]");
    &debug (4,"           p_args[@P_ARGS] words[@WORDS]");


}

sub walk_tree {
   my ( %commands ) = @_ ;

   foreach my $cmd ( sort keys %commands ) {
      my $call = $commands{$cmd};

      &debug(1,"arg : $cmd => ($call) [@LIST_BRANCH] [$cmd]");

      # a few sanity checks
      if ( $cmd eq "" ) { $cmd = "<value>" ; }
      if ( $cmd eq "set" ) { next ; }
      if ( $cmd eq "remove" ) { next ; }

      push ( @LIST_BRANCH , $cmd ) ;

      if ( $call =~ /commands/ ) {
         &$call("foo","foo");
      }

      if ( @LIST_BRANCH ) { print "@LIST_BRANCH\n"; }

      pop @LIST_BRANCH ;
   }
}


# PARSER : show xxx
sub show_commands {
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                'zone' => 'show_zone',
                'network' => 'show_network',
                'host' => 'show_host',
                'version' => 'show_version',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : download xxx
sub download_commands {
   &debug (4,"sub = download_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "database" => 'get_database',
#                 "logs" => 'get_logs',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : upload xxx
sub upload_commands {
   &debug (4,"sub = upload_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
#                 "database" => 'put_database',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf xxx
#
# note, 'conf dhcp' (for the present) == 'conf network'
sub set_commands {
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                'debug' => 'set_debug',
                'server' => 'add_server',
#                 'system' => 'system_commands',
#                 'password' => 'add_pass',
                'zone' => 'zone_commands',
                'realm' => 'realm_commands',
                'network' => 'network_commands',
                'dhcp' => 'network_commands',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf system xxx
sub system_commands {
   &debug (4,"sub = system_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
#                 "default" => 'erase_data',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf realm xxx
sub realm_commands {
   &debug (4,"sub = realm_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_realm',
                "delete" => 'remove_realm',
                "remove" => 'remove_realm',
                "" => 'mod_realm_commands',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf zone xxx
sub zone_commands {
   &debug (4,"sub = zone_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'cli_add_zone',
                "delete" => 'cli_remove_zone',
                "remove" => 'cli_remove_zone',
                "" => 'mod_zone_commands',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf network xxx
sub network_commands {
   &debug (4,"sub = network_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'cli_add_network',
                "delete" => 'cli_remove_network',
                "remove" => 'cli_remove_network',
#                 "global" => 'mod_global_dhcp',
                "" => 'set_network_commands',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf network <n.n.n.n/mm> xxx
sub set_network_commands {
   &debug (4,"sub = set_net ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "split" => 'cli_split_network',
                "add" => 'add_to_network_commands',
                "remove" => 'delete_from_network_commands',
                "delete" => 'delete_from_network_commands',
                "modify" => 'modify_network',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf network <n.n.n.n/mm> add xxx
sub add_to_network_commands {
   &debug (4,"sub = add_to_network ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "fixed" => 'cli_add_fixed_address',
                "address" => 'cli_add_fixed_address',
                "network" => 'add_sub_network',
                "range" => 'cli_add_dhcp_range',
                "dhcprange" => 'cli_add_dhcp_range',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf network <n.n.n.n/mm> delete xxx
sub delete_from_network_commands {
   &debug (4,"sub = delete_from_network ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "fixed" => 'del_fixed_address',
                "range" => 'del_dhcprange',
                "dhcprange" => 'del_dhcprange',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf realm <realm> xxx
sub mod_realm_commands {
   &debug (4,"sub = mod_realm ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_to_realm_commands',
                "delete" => 'remove_from_realm_commands',
                "remove" => 'remove_from_realm_commands',
                "modify" => 'modify_realm_commands',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf zone <zone> xxx
sub mod_zone_commands {
   &debug (4,"sub = mod_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_to_zone_commands',
                "delete" => 'remove_from_zone_commands',
                "remove" => 'remove_from_zone_commands',
#                 "import" => 'import_to_zone',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> modify xxx
sub modify_realm_commands {
   &debug (4,"sub = modify_realm ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "user" => 'mod_realm_opt',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> modify user xxx
sub mod_realm_opt {
   &debug (4,"sub = mod_realm_opt ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "" => 'modify_realm_user',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> modify user <user> xxx
sub modify_realm_user {
   &debug (4,"sub = mod_realm_usr ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "add" => 'modify_realm_user_add',
                "delete" => 'modify_realm_user_delete',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> modify user <user> add xxx
sub modify_realm_user_add {
   &debug (4,"sub = mod_realm_usr_add ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "attribute" => 'modify_realm_user_add_att',
        ) ;
   &shift_arg($arg,%commands);

}

sub modify_realm_user_delete {
   &debug (4,"sub = mod_realm_usr_del ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "attribute" => 'modify_realm_user_del_att',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> add xxx
sub add_to_realm_commands {
   &debug (4,"sub = add_to_realm ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "attribute" => 'add_attrib_to_realm',
                "user" => 'add_user_to_realm',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf zone <zone> add xxx
sub add_to_zone_commands {
   &debug (4,"sub = add_to_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "host" => 'cli_add_host',
                "cname" => 'add_cname',
                "a" => 'add_a_rec',
                "ptr" => 'add_zone_ptr',
                "bulkhost"   => 'add_bulkhost',
                "nameserver" => 'NOT_READY',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf zone <zone> remove xxx
sub remove_from_zone_commands {
   &debug (4,"sub = remove_from_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "host" => 'cli_remove_host',
                "cname" => 'remove_cname',
                "bulkhost" => 'remove_bulkhost',
                "a" => 'remove_a_rec',
                "ptr" => 'del_zone_ptr',
                "nameserver" => 'NOT_READY',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf realm <realm> remove xxx
sub remove_from_realm_commands {
   &debug (4,"sub = remove_from_realm ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "user" => 'remove_user_from_realm',
                "attribute" => 'remove_attrib_from_realm',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : default
sub NOT_READY {
    print "***-  NOT IMPLEMENTED\n";
}

###########################################
#
# here endith the arg parsers
#
###########################################

# 2 functions here (and more damn globals - hmm...)
# do_pub_conn calls the public function
# do_priv_conn calls the priv function

#
# call an infoblox function, ONLY if we're connected
#
sub do_pub_func {

    # assume we are passed a single hash
    #
    my ( $ib_call , %hash ) = @_ ;
    &debug (1,"do_pub_func ($ib_call)");

    # format the data for pretty printing
    my $hash_ptr = \%hash ;

#     my $fstring = &format_ib_func($ib_call,$hash_ptr);
    &print_data($ib_call,$hash_ptr);

    if ( ! $MAKE ) {
       # actually try and run it
       if ( $CONNECTED ) {
          # type cast correctly and prepend the SESSION
#           my $result = &$ib_call ( $PUB_SESS , { @fargs } ) ;
          my $ib_result = &$ib_call ( $PUB_SESS , $hash_ptr ) ;
          my $result = $ib_result->get_status_code();
          my $response = $ib_result->get_error_details();

          if ( $result > 0 ) {
             # We got error...
#              &debug (1,"result [$result] ($response)");
             print "failed [$result] $response\n";
             return $result
          }
          else {
             $MADE_CHANGES = "*" ;
          }

       }
       else {
          &err_print("CANNOT EXECUTE - no connection is in place");
       }

    }
}

sub do_priv_func {
    # private functions need a different session handler
    my ( $ib_call , $key_ptr , $mod_ptr ) = @_ ;
    &debug (1,"do_priv_func ($ib_call)");

    # format the data for pretty printing
#     &print_data($ib_call,$key_ptr);
    print "DUMPER needs updating for multi hashes...\n";

    if ( ! $MAKE ) {
       # actually try and run it
       if ( $CONNECTED ) {
          # type cast correctly and prepend the SESSION

          my ( $res , $info ) = &$ib_call ( $PRI_SESS , $key_ptr , $mod_ptr ) ;
       }
       else {
          &err_print("CANNOT EXECUTE - no connection is in place");
       }

    }
}

sub do_nothing {
    my ( $ib_call , @fargs ) = @_ ;
    &debug (1,"do_nothing ($ib_call) [@fargs]");

    # format the data for pretty printing
#     my $fstring = &format_ib_func($ib_call,@fargs);
    &print_data($ib_call,@fargs);

    if ( ! $MAKE ) {
          &err_print("CANNOT EXECUTE - NOT IMPLEMENTED");
    }
}

# sub format_ib_func {
# 
#     my ( $ib_call , @fargs ) = @_ ;
# 
#     my $p_comm ;
# 
#     # V3 code passes args as a hash or many hashes
# 
#     my $syntax ;
#     foreach my $ptr ( @fargs ) {
#        my %hash = %{ $ptr } ;
# 
#        # format each hash
#        $syntax .= &dump_hash( 0 , "HASH" , %hash );
#     }
# 
#     $p_comm = "my \$result = $ib_call ( \$SESSION ,\n $syntax    );\n\n";
# 
# 
#     # do we print out code instead...
#     if ( $MAKE ) {
#        print "\nprint '" . $ib_call . "'.\"\\n\";\n" ;
# 
#        print "$p_comm ;\n" ;
#     }
# 
#     # return the formatted string (in case we need it)
#     return ( $p_comm );
# }


###########################################
#
# actual API functions.
#
###########################################

=head1 GENERAL COMMAND REFERENCE

The syntax mostly matches the API syntax. Also, since this is based on
the API (duh) the same restrictions about requires arguments applies.
Don't expect the cli to work around requiring dumb extra arguments. When
you look deep into the API you realise why they are there.

=cut

# sub get_logs {
#     #
#     # download the logs to the current dir
#     #
#     my ( $dest ) = @_ ;
# #     chomp($dest = `pwd`);
# #     $dest="$dest/IB_files";
#     if ( ! $dest ) {
#        &missing_arg("<dir>")  ;
#        return ;
#     }
# 
#     &err_print("DOWNLOADING ALL LOGS data to $dest ...");
#     if ( ! -d $dest ) { mkdir($dest,0755); }
# 
#     my @function = ("ib_export_logs",$dest);
#     &do_nothing(@function);
# 
#     &err_print("DONE ");
# 
# }

=head2 Export the database

    download database

=cut

sub get_database {
    #
    # download the database to the current dir
    #
    my ( $dest ) = @_ ;
#     chomp($dest = `pwd`);
#     $dest="$dest/IB_files";
    if ( ! $dest ) {
       &missing_arg("<file>")  ;
       return ;
    }

    &err_print("DOWNLOADING ALL DATABASE data as $dest ...");
#     if ( ! -d $dest ) { est,0755); }

    my %opthash ;
    $opthash{'path'}=$dest;

#     # build the rest ad name value pairs
#     while ( my $key = shift @type_opts ) {
#        my $value = shift @type_opts ;
#        $opthash{$key} = $value ;
#     }

    my @function = ("backup_system",%opthash);

    &do_pub_func(@function);

    &err_print("DONE ");

}

# sub put_database {
#     #
#     # upload the database from the spec'd dir
#     #
#     my ( $dest ) = @_ ;
#     if ( ! $dest ) {
#        &missing_arg("<dir>")  ;
#        return ;
#     }
# 
#     &err_print("UPLOADING ALL DATABASE data from $dest ...");
#     if ( ! -d $dest ) { 
#        &err_print("NO such location");
#        return ;
#     }
# 
#     my @function = ("ib_import_database" , $dest ) ;
#     &do_nothing(@function);
# 
#     &err_print("DONE ");
# 
# }

# sub erase_data {
# 
#     &err_print("ERASING ALL DATABASE data ...");
# 
#     # we may want an 'are you sure here...'
#     my @function = ("ib_erase_dns_data");
#     &do_nothing(@function);
# 
#     &err_print("DONE ");
# }

sub import_to_zone {
    ## DEPRICATED - see 'cli_add_zone' ;
    my ( $zone , $ip , $opt ) = @_ ;
    if ( ! $ip ) {
       &missing_arg("<ip> [noptr]")  ;
       return ;
    }

    &debug (2,"importing z($zone) ip($ip) ");

    my @function = ("ib_import_zone",$zone,$ip,$opt);
    &do_nothing(@function);

}

=head2 Add a Zone

Zones can be added as either forward or reverse. If you add a zone of the
form n.n.n.n/mm it will assume it is a reverse zone

Add a forward zone

   conf zone add foo.com

Add a reverse zone

   conf zone add 10.0.1.0/24

Add a zone to specific members

   conf zone add foo.com members 1.2.3.4,1.2.3.5,1.2.3.6

=head2 Import a zone

Zones can be imported as either forward or reverse. You just add an extra
argument of the import source

Import a forward zone

   conf zone add foo.com import 45.0.1.220

Import a reverse zone

   conf zone add 10.0.1.0/24 import 45.0.1.220

=cut

sub cli_add_zone {

    # [ ] need a post cli deeper arg parser
    # essentially all options are passed as name value pairs
    # after the required options
    # so we pass this array to an abbrev validator that looks at each
    # second word and abbrev/expands and validates
    # 
    # the validator has to be passed an array, and a list of keywords
    # (ARRG!! - 2 arrays...)
    # 
    # for the moment we'll not bother to validate

    my ( $zone , $type , @type_opts) = @_ ;

    if ( ! $zone ) { &missing_arg("<zone>") ; return }

    &debug (2,"addz n($zone) t($type) oo(@type_opts)");

    #
    # etype is the expanded version of whatever we typed for $type
    # We'll only allow authorative zones for present
    #
    my $etype ;
    if ( $type ) {
#        my @opts = ( "authoritative","delegated","secondary");
       my @opts = ( "Authoritative","import" );
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "Authoritative" ) ; }

    # format the type opts
    # ..... (code goes here) ...

    my %opthash ;
    $opthash{'type'}=$etype;
    $opthash{'cluster_primary'}=$S_ID ;

    # do we import ?
    if ( $etype eq "import" ) {
       $opthash{'type'}="Authoritative";
       $opthash{'import_source'}=shift @type_opts ;
    }

    # are we forward or reverse
    my @function ;
    if ( $zone =~ /$IPRE\/\d+/ ) {
       # reverse zone
       $opthash{'network'}=$zone;
       @function=("add_reverse_zone",%opthash);
    }
    else {
       $opthash{'name'}=$zone;
       @function=("add_zone",%opthash);
    }

    &do_pub_func(@function);

}

=head2 Remove a zone

Forward or reverse, the syntax follows the same logic as add zone

Remove a forward zone

   conf zone del foo.com

Remove a reverse zone

   conf zone del 10.0.1.0/24

=cut

sub cli_remove_zone {
    my ( $zone ) = @_ ;
    if ( ! $zone ) { &missing_arg("<zone>") ; return }
    &debug (2,"remz n($zone)");

    my %opthash ;
    $opthash{'name'}=$zone;
    $opthash{'network'}=$zone;

#     $opthash{'type'}="Delegated" ;
#     $opthash{'is_reverse_zone'}="false" ;

    my @function=("remove_zone",%opthash);
    &do_pub_func(@function);

}

=head2 Add a host to a zone

   conf zone foo.com add host test 1.2.3.4

=cut

sub cli_add_host {
    my ( $zone , $host , $ip , $comment ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"addh n($name) n($ip) c($comment)");

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'name'}=$host;
    if ( $comment ) { $opthash{'comment'}=$comment; }

    # add the IP address
    push @{ $opthash{"address_list"} } , {( "address" , $ip )};

    my @function = ("add_host",%opthash);

    &do_pub_func(@function);

}

=head2 Remove a host from a zone

   conf zone foo.com delete host test

=cut

sub cli_remove_host {
    my ( $zone , $host ) = @_ ;
    if ( ! $host ) {
       &missing_arg("<host>")  ;
       return ;
    }
    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'name'}=$host;

    my @function = ("remove_host",%opthash);
    &debug (2,"addh n($host) ");

    &do_pub_func(@function);

}

=head2 Add an A record to a zone

   conf zone foo.com add A test 1.2.3.4

=cut


sub add_a_rec {
    my ( $zone , $host , $ip , $comment ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'name'}=$host;
    $opthash{'address'}=$ip;
    if ( $comment ) { $opthash{'comment'}=$comment; }

    &debug (2,"add1h n($host) n($ip) ");

    my @function = ("add_rr_a",%opthash);
    &do_pub_func(@function);

}

=head2 Remove An A record from a zone

   conf zone foo.com delete A test 1.2.3.4

=cut


sub remove_a_rec {
    my ( $zone , $host , $ip ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'name'}=$host;
    $opthash{'address'}=$ip;

    &debug (2,"add1h n($host) n($ip) ");

    my @function = ("remove_rr_a",%opthash);
    &do_pub_func(@function);

}

=head2 Add a bulk host to a zone

   conf zone foo.com add bulkhost my_prefix 1.2.3.10 1.2.3.20

=cut

sub add_bulkhost {
    my ( $zone , $prefix , $fip , $lip , $comment ) = @_ ;

    if ( $zone and $prefix and $fip and $lip ) {

       &debug (2,"addbh n($zone) p($prefix) n($fip,$lip) ");

       my %opthash ;
       $opthash{'zone'}=$zone;
       $opthash{'prefix'}=$prefix;
       $opthash{'start_address'}=$fip;
       $opthash{'end_address'}=$lip;
       if ( $comment ) { $opthash{'comment'}=$comment; }

       my @function=("add_bulk_host",%opthash);
       &do_pub_func(@function);
    }
    else {
       &missing_arg("<prefix> <start_ip> <end_ip>")  ;
       return ;
    }

}

=head2 Remove a bulk host from a zone

   conf zone foo.com del bulkhost my_prefix 1.2.3.10 1.2.3.20

=cut

sub remove_bulkhost {
    my ( $zone , $prefix , $fip , $lip ) = @_ ;

    if ( $zone and $prefix and $fip and $lip ) {

       &debug (2,"addbh n($zone) p($prefix) n($fip,$lip) ");

       my %opthash ;
       $opthash{'zone'}=$zone;
       $opthash{'prefix'}=$prefix;
       $opthash{'start_address'}=$fip;
       $opthash{'end_address'}=$lip;

       my @function=("remove_bulk_host",%opthash);
       &do_pub_func(@function);
    }
    else {
       &missing_arg("<prefix> <start_ip> <end_ip>")  ;
       return ;
    }
}

=head2 Add a CNAME to a zone

   conf zone foo.com add CNAME alias real.foo.com

=cut

sub add_cname {
    my ( $zone , $alias , $cname , $comment ) = @_ ;
    if ( (! $alias ) or ( ! $cname ) ) {
       &missing_arg("<alias> <cname>")  ;
       return ;
    }

    &debug (2,"addh a($alias) cn($cname) ");

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'alias'}=$alias;
    $opthash{'canonical_name'}=$cname;
    if ( $comment ) { $opthash{'comment'}=$comment; }

    my @function=("add_rr_cname",%opthash);
    &do_pub_func(@function);

}

=head2 Remove a CNAME from a zone

   conf zone foo.com delete CNAME alias

=cut

sub remove_cname {
    my ( $zone , $alias ) = @_ ;
    if ( ! $alias ) {
       &missing_arg("<alias>")  ;
       return ;
    }

    &debug (2,"addh n($alias) ");

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'alias'}=$alias;

    my @function=("remove_rr_cname",%opthash);
    &do_pub_func(@function);

}

=head2 Add a PTR to a zone

   conf zone 10.0.0.0/24 add PTR 10.0.0.20 ns2.foo.com

Add a PTR with comments

   conf zone 10.0.0.0/24 add PTR 10.0.0.20 ns2.foo.com "comment string"

=cut

sub add_zone_ptr {
    my ( $network , $ip , $host , $comment ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<ip> <host>")  ;
       return ;
    }
#     my ($net,$cidr) = split(/\//,$parent) ;
#     my $mask = &cidrfind($cidr) ;

    &debug (2,"addnp n($network) ip($ip) h($host)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'name'}=$ip;
    $opthash{'host'}=$host;
    if ( $comment ) { $opthash{'comment'}=$comment; }

    my @function=("add_rr_ptr",%opthash);
    &do_pub_func(@function);

}

=head2 Remove a PTR from a zone

   conf zone 10.0.0.0/24 del PTR 10.0.0.20 ns2.foo.com

=cut

sub del_zone_ptr {
    my ( $network , $ip , $host ) = @_ ;
    if ( ( ! $ip ) or ( ! $host ) ) {
       &missing_arg("<ip> <host>")  ;
       return ;
    }
    &debug (2,"remnp n($network) ip($ip) ho($host)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'name'}=$ip;
    $opthash{'host'}=$host;

    my @function=("remove_rr_ptr",%opthash);
    &do_pub_func(@function);

}

=head2 Modify global DHCP settings

TBD

=cut

# sub mod_global_dhcp {
#     my ( $opt , $val , @extra ) = @_ ;
#     if ( (! $val ) or ( ! $opt ) ) {
#        &missing_arg("<option> <value>")  ;
#        return ;
#     }
#     # clean up any custom option args
#     my $custom= join ( '","' , @extra );
# 
#     # clean some options
#     $val=~s/["']*//g ;
#     $custom=~s/""/"/g ;
# 
#     &debug (2,"modglob o($opt) v($val) c($custom)");
# 
#     #
#     # GLOBAL custom props have to ALL be on one line, or stuff gets dropped
#     #
#     # ib_modify_global_dhcp_options
#     #         ("10.34.8.0","255.255.252.0","router","10.34.8.1");
#     # OR
#     # ib_modify_global_dhcp_options
#     #         ("10.54.0.0","255.255.252.0","custom_option",
#     #           "netbios-name-servers","","10.23.60.20");
#     my $comm="ib_modify_global_dhcp_options";
#     my @function=($comm,$opt,$val);
# 
#     if ( $opt eq "custom_option" ) {
#        @function=($comm,"custom_option",$val,$custom);
#     }
#        
# 
#     &do_pub_func(@function);
# 
# }

=head2 Add a network

   conf network add 1.1.1.0/24

Add a network with members

   conf network add 1.1.1.0/24 members 1.1.1.2,1.1.1.3,1.1.1.4

Add a network with comments

   conf network add 1.1.1.0/24 comment "comment string"

When you split a network and want to add children you just add them to
the parent network. All other options are the same as for adding networks

   conf network 1.1.0.0/16 add 1.1.4.0/22 

=cut

sub add_sub_network {
    my ( $network , $subnet ) = @_ ;
    if ( ! $subnet ) { &missing_arg("<n.n.n.n/mm>") ; return }

    &debug (2,"addsn pn($network) n($subnet)");

    my %opthash ;
    $opthash{'network'}=$subnet;
    $opthash{'network_container'}=$network;

    my @function=("add_subnetwork",%opthash);
    &do_pub_func(@function);

}

sub cli_add_network {
    my ( $network , @type_opts ) = @_ ;

    if ( ! $network ) { 
            &missing_arg("<n.n.n.n/mm>") ; 
            return 
    }

    &debug (2,"addn n($network)");

    my %opthash ;
    $opthash{'network'}=$network;

    # set the list of acceptable options
    my @opts = ( "member" , "comment" , "option" );
    my %optlist = abbrev ( @opts ) ;

    # build the rest as name value pairs
    while ( my $type = shift @type_opts ) {
       my $value = shift @type_opts ;
       my $etype = $optlist{ lc($type) } ;

       &debug (3,"addrng t($type) et($etype) v($value) oo(@type_opts)");

       if ( ! $etype || ! $value ) { 
          &missing_arg(@opts );
          return ;
       }

       # check for custom options ?
       if ( $etype eq "option" ) {
          # set some custom options;
          # split on the FIRST '='
          my ( $opt , $val ) = $value =~  /^(.*?)=(.*)/ ;

          &debug (3,"addrng o($opt) v($val) oo(@type_opts)");

          my ($key,$item)=make_dhcp_option($DEBUG,$opt,$val) ;

          # add a custom option to the hash
          if ( $key =~ /^Option / ) {
                 push @{ $opthash{'custom_options'} } , $item ;
          }
          # general options are returned as the full object
          elsif ( $key ) {
                 $opthash{$key}=$item ;
          }

       }
       # multiple members
       elsif ( $etype eq "member" ) {
          &debug (3,"addrng mem($value) oo(@type_opts)");

          push @{ $opthash{"members"} } , {( "member" , $value )};
       }

       else {
          # just set the hash
          $opthash{$etype}=$value;
       }

    }

    # add to the default member, if required
    if ( ! $opthash{'members'} ) {
       push @{ $opthash{"members"} } , {( "member" , $S_ID )};
    }

    my @function=("add_network",%opthash);
    &do_pub_func(@function);

}

=head2 Remove a network

   conf network del 1.1.1.0/24

=cut

sub cli_remove_network {
    my ( $network ) = @_ ;
    if ( ! $network ) { &missing_arg("<n.n.n.n/mm>") ; return }

    &debug (2,"remn n($network)");

    my %opthash ;
    $opthash{'network'}=$network;

    my @function=("remove_network",%opthash);
    &do_pub_func(@function);

}

=head2 modify a network

TBD

=cut

sub modify_network {

    # THIS IS A PRIVATE FUNCTION...
    #
    my ( $parent , $opt , @opt_args ) = @_ ;

    if ( (! $opt ) or ( ! @opt_args ) ) {
       &missing_arg("<option> <arg> [arg]")  ;
       return ;
    }
    # clean up the netmask
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    # so we are forced to use the same crappy arg parser that was
    # in the 2.x code.. unless we can get clever, but different args
    # require more or less options and the setting of flags
    # [ ]
    # first order pass we will only accept one option per command,
    # but you can call this command many times

    my $eopt ;
    if ( $opt ) {
       my @opts = ( "name_servers","custom","routers","lease_time");
       my %optlist = abbrev ( @opts ) ;
       $eopt = $optlist{ lc($opt) } ;

       if ( ! $eopt ) { 
          &missing_arg(@opts);
          return ;
       }
    }

#     # clean some options
#     $val=~s/["']*//g ;
#     $custom=~s/["']*//g ;

    &debug (2,"modnet n($net) m($mask) o($eopt) a(@opt_args)");

    # build the hash
    my %keyhash ;
    $keyhash{"address"} = $net;
    $keyhash{"netmask"} = $mask;

    my %opthash ;
    $opthash{"address"} = $net;
    $opthash{"netmask"} = $mask;

    # dammit - i hate doing this... this gets fixed if it is not private
    if ( $eopt eq "name_servers" ) {
       $opthash{"override_domain_servers"} = "true";
       my $pos = 0 ;
       foreach my $lopt ( @opt_args ) {
          push @{ $opthash{"domain_name_server_list"} } ,
                  {( "position" , $pos, 
                     "address" , $lopt )};
          $pos++ ;
      }

    }
    elsif ( $eopt eq "lease_time" ) {
       $opthash{"lease_time"} = shift @opt_args;
       $opthash{"override_lease_time"} = "true";
    }
    elsif ( $eopt eq "routers" ) {
       $opthash{"override_routers"} = "true";
       my $pos = 0 ;
       foreach my $lopt ( @opt_args ) {
          push @{ $opthash{"router_list"} } ,
                  {( "position" , $pos, 
                     "address" , $lopt )};
          $pos++ ;
      }
    }
    # custom options
    elsif ( $eopt eq "custom" ) {
       $opthash{"override_custom_options"} = "true";
       my ( $option , $value ) = @opt_args ;
       my $name = &rename_custom_option ( $option ) ;

          push @{ $opthash{"network_custom_option_list"} } ,
                  {( "name" , $name, 
                     "value" , $value )};
    }

    # careful here - we need 2 hashes... key and mod
    my $kptr = \%keyhash ;
    my $optr = \%opthash;

    my @function=("update_network",$kptr,$optr);
     
    &do_priv_func(@function);
}

=head2 Add a fixed address

   conf network 10.0.1.0/24 add fixed 10.0.1.4 aa:bb:cc:11:22:33 

Add a fixed address with comments

   conf net 10.0.1.0/24 add fixed 10.0.1042 aa:bb:cc:11:22:33 "comment string"

=cut


sub cli_add_fixed_address {
    my ( $network , $ip , $mac , $comment ) = @_ ;
    if ( (! $ip ) or ( ! $mac ) ) {
       &missing_arg("<ip> <mac>")  ;
       return ;
    }
    &debug (2,"addfix n($network) ip($ip) mac($mac) c($comment)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'ip_address'}=$ip;
    $opthash{'mac_address'}=$mac;
    if ( $comment ) { $opthash{'comment'}=$comment; }

    my @function=("add_fixed_address",%opthash);
    &do_pub_func(@function);

}

=head2 Remove a fixed address

For some clever reason, you don't really need to specify the parent
network to remove a fixed address, but we enforct it here to keep people
sane (In reality, any bogus string for the network name will work)

   conf network 10.0.1.0 remove fixed 1.2.3.4

=cut

sub del_fixed_address {
    my ( $network , $ip ) = @_ ;
    if ( ! $ip  ) {
       &missing_arg("<ip>")  ;
       return ;
    }
    &debug (2,"remfix ip($ip)");

    # we don't actually eed the network value...

    my %opthash ;
    $opthash{'ip_address'}=$ip;

    my @function=("remove_fixed_address",%opthash);
    &do_pub_func(@function);

}

=head2 Add a dhcp range to a network

Dhcp ranges, by default, will get added to the cluster master unless you
override that setting with the member <member> syntax

   conf network 10.1.1.1/24 add dhcp_range 10.1.1.20 10.1.1.40

Ranges can also take alternative (lazy) syntax

   conf network 10.1.1.1/24 add range 10.1.1.20 10.1.1.40

Failover associations are an additional argument

   conf net 10.1.1.1/24 add range 10... failover "my_peering"

As are adding the member

   conf net 10.1.1.1/24 add range 10... member 1.1.1.2

=cut

sub cli_add_dhcp_range {
    my ( $network , $fip , $lip , @type_opts ) = @_ ;
    if ( (! $fip ) or ( ! $lip ) ) {
       &missing_arg("<first_ip> <last_ip>")  ;
       return ;
    }

    &debug (2,"addrng n($network) s($fip) e($lip) oo(@type_opts)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'start_address'}=$fip;
    $opthash{'end_address'}=$lip;
    $opthash{'member'}=$S_ID;

    # set the list of acceptable options
    my @opts = ( "member" , "comment" , "failover_association" , "option" );
    my %optlist = abbrev ( @opts ) ;

    # build the rest as name value pairs
    while ( my $type = shift @type_opts ) {
       my $value = shift @type_opts ;
       my $etype = $optlist{ lc($type) } ;

       &debug (3,"addrng t($type) et($etype) v($value) oo(@type_opts)");

       if ( ! $etype || ! $value ) { 
          &missing_arg(@opts );
          return ;
       }

       # check for custom options ?
       if ( $etype eq "option" ) {
          # set some custom options;
          # split on the FIRST '='
#           my ( $opt , $val ) = split ( /=/ , $value ) ;
          my ( $opt , $val ) = $value =~  /^(.*?)=(.*)/ ;

          &debug (3,"addrng o($opt) v($val) oo(@type_opts)");

          my ($key,$item)=make_dhcp_option($DEBUG,$opt,$val) ;

          # add a custom option to the hash
          if ( $key =~ /^Option / ) {
                 push @{ $opthash{'custom_options'} } , $item ;
          }
          # general options are returned as the full object
          elsif ( $key ) {
                 $opthash{$key}=$item ;
          }

       }
       else {
          # just set the hash
          $opthash{$etype}=$value;
       }

    }

    my @function=("add_dhcp_range",%opthash);
    &do_pub_func(@function);

}

=head2 Remove a dhcp range

   conf net 1.1.1.1/24 delete range 1.1.1.20 1.1.1.40

=cut

sub del_dhcprange {
    my ( $network , $fip , $lip ) = @_ ;
    if ( ( ! $fip ) or ( ! $lip )  ) {
       &missing_arg("<first_ip> <last_ip>")  ;
       return ;
    }

    # we don't need the network..
    &debug (2,"remrng n($network) s($fip) e($lip)");

    my %opthash ;
    $opthash{'start_address'}=$fip;
    $opthash{'end_addresss'}=$lip;

    my @function=("remove_dhcp_range",%opthash);
    &do_pub_func(@function);

}

=head2 Split a network

You need to specify the netmaks of the children networks when you are
doing a split. So to split a /16 into /20 networks :

   conf network 1.1.0.0/16 split /24

Split a network and add all children

   conf network 1.1.0.0/16 split /24 all

=cut

sub cli_split_network {
    #
    # the split arg of split_network is a bitshift RELATIVE
    # to the original mask, so there is some math involved
    #
    # splitting either creates ALL networks or only the ones
    # we have to have (which could be none)

    my($network,$ncidr,$type) = @_ ;

    # the bitshift code will change, so we calc for now until it 
    # becomes redundant
    my($pnet,$pcidr)= split(/\//,$network );
       $ncidr =~ s/\/// ;
    my $bitshift = $ncidr ;
#     my $pmask = &cidrfind($pcidr);

    &debug (3,"split net [$pnet] [$pcidr] [$ncidr] ($bitshift)\n");
    &debug (2,"split net ($network) nb ($ncidr)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'netmask_bits'}=$bitshift;

    # check for optional args...
    my $etype ;
    if ( $type ) {
       my @opts = ( "all","required");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
#     else { 
#          # don't add networks
#          $opthash{'add_all_sunetworks'} = "false" 
#     }

    if ( $etype eq "required" ) { 
            $opthash{'add_all_sunetworks'} = "false" 
    }
    if ( $etype eq "all" ) { 
            $opthash{'add_all_sunetworks'} = "true" 
    }

    my @function=("split_network",%opthash);
    &do_pub_func(@function);

}

##########################################################
#
# RADIUS commands
#
##########################################################

=head1 RADIUS commands

The cli will also speak to a RADIUS One...

=head2 Adding a realm

   conf realm add my_realm

Add a realm with options

   conf realm add my_realm <option> <value> <option> <value>

=cut

sub add_realm {
    my ( $realm , @type_opts) = @_ ;

    # only "name" is required
    if ( ! $realm ) { &missing_arg("<realm>") ; return }

    &debug (2,"addrm n($realm) oo(@type_opts)");

    #
    # type_opts is a list of name value pairs, we just eat these into a
    # hash and shove them into the request
    #

    # format the type opts
    my %opthash ;
    $opthash{'name'}=$realm;

    # build the rest ad name value pairs
    while ( my $key = shift @type_opts ) {
       my $value = shift @type_opts ;
       $opthash{$key} = $value ;
    }

    my @function = ("RADIUSOne::realm_insert",%opthash);

    &do_pub_func(@function);

}

=head2 Removing a realm

   conf realm delete "my_realm"

=cut

sub remove_realm {
    my ( $realm ) = @_ ;

    # only "name" is required
    if ( ! $realm ) { &missing_arg("<realm>") ; return }

    &debug (2,"delrm n($realm)");

    my %opthash ;
    $opthash{'name'}=$realm;

    my @function = ("RADIUSOne::realm_delete",%opthash);

    &do_pub_func(@function);

}

=head2 Adding an attribute to a realm

You need to specify if this is a CHECK or RELPY item

   conf realm myrealm add attribute check name value

   conf realm ms.com add attr check Nas-IP-Address 45.0.0.1
   conf realm ms.com add attr reply framed-ip-netmask 255.255.255.0

=cut

# add an attribute to a realm
sub add_attrib_to_realm {
    #
    my ( $realm , $type , $name , $value ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "check","reply");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    &debug (2,"add2r n($realm) t($type) et($etype) ($name)=($value)");

    if ( ! $etype ) { 
       &missing_arg(@opts);
       return ;
    }

    if ( ! $name or ! $value ) { 
       &missing_arg("<name> <value>");
       return ;
    }

    # convert opts to a hash
    my %opthash;
    $opthash{'name'}=$realm;
    $opthash{'check_reply'}=$etype;
    $opthash{'attribute'}=$name;
    $opthash{'value'}=$value;

    my @function = ("RADIUSOne::realm_av_pair_insert",%opthash);
    &do_pub_func(@function);

}

=head2 Removing an attribute from a realm

You need to specify if this is a CHECK or REPLY item

   conf realm myrealm del attribute check name value

   conf realm ms.com del attr check Nas-IP-Address 45.0.0.1
   conf realm ms.com del attr reply framed-ip-netmask 255.255.255.0

=cut

# delete an attribute to a realm
sub remove_attrib_from_realm {
    #
    my ( $realm , $type , $name , $value ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "check","reply");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    &debug (2,"add2r n($realm) t($type) et($etype) ($name)=($value)");

    if ( ! $etype ) { 
       &missing_arg(@opts);
       return ;
    }

    if ( ! $name or ! $value ) { 
       &missing_arg("<name> <value>");
       return ;
    }

    # convert opts to a hash
    my %opthash;
    $opthash{'name'}=$realm;
    $opthash{'check_reply'}=$etype;
    $opthash{'attribute'}=$name;
    $opthash{'value'}=$value;

    my @function = ("RADIUSOne::realm_av_pair_delete",%opthash);
    &do_pub_func(@function);

}

=head2 Adding a user to a realm

   conf realm foo.com add user brian password xxxx

To add the default user:

   conf realm foo.com add user default

=cut

# add an user to a realm
sub add_user_to_realm {
    #
    my ( $realm , $name , $popt , $passwd ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "password");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($popt) } ;

    &debug (2,"add2r n($realm) n($name) p($popt) ep($etype) ($passwd)");

    if ( ! $name ) { 
       &missing_arg("<name>");
       return ;
    }

    # convert opts to a hash
    my %opthash;

    $opthash{'realm'}=$realm;
    # default user ?
    if ( $name =~ /^default$/i ) {
       $opthash{'default'}="true";
    }
    else {
       # check for password
       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
       if ( ! $passwd ) { 
          &missing_arg("<password>");
          return ;
       }

       # set values
       $opthash{'default'}="false";
       $opthash{'name'}=$name;
       $opthash{'user_password'}=$passwd;
    }

    my @function = ("RADIUSOne::radius_user_insert",%opthash);
    &do_pub_func(@function);

}

=head2 Remove a user from a realm

   conf realm foo.com del user brian

=cut

# remove an user to a realm
sub remove_user_from_realm {
    #
    my ( $realm , $name ) = @_ ;

    &debug (2,"del2r n($realm) n($name)");

    if ( ! $name ) { 
       &missing_arg("<name>");
       return ;
    }

    # convert opts to a hash
    my %opthash;

    $opthash{'realm'}=$realm;
    # default user ?
    if ( $name =~ /^default$/i ) {
       $opthash{'default'}="true";
    }
    else {
       # set values
       $opthash{'default'}="false";
       $opthash{'name'}=$name;
    }

    my @function = ("RADIUSOne::radius_user_delete",%opthash);
    &do_pub_func(@function);

}

=head2 Adding an attribute to a user

You must specify CHECK or REPLY

   conf realm foo modify user brian add attrib check foo 1.2.3.4

=cut

sub modify_realm_user_add_att {
    #
    my ( $realm , $name , $type , $att , $value ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "check","reply");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    &debug (2,"modru r($realm) n($name) t($type) et($etype) ($att)=($value)");

    if ( ! $etype ) { 
       &missing_arg(@opts);
       return ;
    }

    if ( ! $name or ! $value ) { 
       &missing_arg("<name> <value>");
       return ;
    }

    # convert opts to a hash
    my %opthash;
    $opthash{'realm'}=$realm;
    $opthash{'check_reply'}=$etype;
    $opthash{'attribute'}=$att;
    $opthash{'value'}=$value;

    # is this the default user ?
    $opthash{'default'}="false";
    if ( $name =~ /^default$/i ) {
       $opthash{'default'}="true";
    }
    else {
       $opthash{'radius_user'}=$name;
    }


    my @function = ("RADIUSOne::user_av_pair_insert",%opthash);
    &do_pub_func(@function);

}

=head2 Removing an attribute from a user

You must specify CHECK or REPLY

   conf realm foo modify user brian del attrib check foo 1.2.3.4

=cut

sub modify_realm_user_del_att {
    #
    my ( $realm , $name , $type , $att , $value ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "check","reply");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    &debug (2,"modru r($realm) n($name) t($type) et($etype) ($att)=($value)");

    if ( ! $etype ) { 
       &missing_arg(@opts);
       return ;
    }

    if ( ! $name or ! $value ) { 
       &missing_arg("<name> <value>");
       return ;
    }

    # convert opts to a hash
    my %opthash;
    $opthash{'realm'}=$realm;
    $opthash{'check_reply'}=$etype;
    $opthash{'attribute'}=$att;
    $opthash{'value'}=$value;

    # is this the default user ?
    $opthash{'default'}="false";
    if ( $name =~ /^default$/i ) {
       $opthash{'default'}="true";
    }
    else {
       $opthash{'radius_user'}=$name;
    }


    my @function = ("RADIUSOne::user_av_pair_delete",%opthash);
    &do_pub_func(@function);

}

###########################################3
#
###########################################3

sub missing_arg {
    &debug(4,"MISS ARG call");
    if ( $CLI ) {
       print "Next possible completions : \n\t@_\n";
    }
    else {
       &err_print("UNRECOGNISED command");
    }
    $GOOD_COMMAND = 0 ;
}

#
# PROMPT
#
sub print_prompt {
    if ( $CLI ) {
       print "[$DEBUG] $MADE_CHANGES $PROMPT" ;
    }
}

#
# ERRORS
#
sub err_print {
    if ( $CLI ) {
       print "@_\n" ;
    }
    else {
       # comment if making..
       if ( $MAKE ) { print "# " }
       print "@_ : $LINE\n";
    }
}

=head2 Change (or Set) the debug level

   conf debug <level>

=cut

#
# SET DEBUG
#
sub set_debug {

    if ( "@_" =~ /\d+/ ) {
       $DEBUG = shift @_ ;
    }
    else {
       &missing_arg("$SAVE_HIST <level>");
    }
}

#
# SHOW THE HISTORY:
#

sub addhistory {
    my ($line) = "@_" ;

    #cleanup spacing
    $line =~ s/^\s*//;
    $line =~ s/\s+/ /g;
    $line =~ tr/A-Z/a-z/;

    push @HISTORY , $line ;

}

=head2 Show the history

    [0] * 10.0.1.230 > history

=cut

sub show_history {
    my $lineno = 1 ;

    # walk through the history array and print what we input
    print "\n-- COMMAND HISTORY --\n";
    foreach my $command ( @HISTORY ) {
       print "-- $lineno\t$command\n";
       $lineno ++ ;
    }
    print "\n";

#     $GOOD_COMMAND = 1 ;

}

#
# SERVER CONNECTION STUFF.....
#

=head2 Connect to a server

    CONF SERVER <SERVER> USER <USERNAME> PASSWORD <PASSWD>

Select a server to talk to

    [0] ! no server > conf server 10.0.1.230 

Supply the username and or password

    [0] ! no server > conf server 10.0.1.230 user admin
    [0] ! no server > conf server 10.0.1.230 password infoblox

All on one line

    [0] ! no server > conf ser 10.0.1.230 user admin pass infoblox
        
=cut
        
sub add_server {
    my ($type,@args) = @_ ;
    # save the server id and see if we have enough info to connect
    # password can be passed on this line, if not specified, assume
    # no password

    &debug (2,"adding server t[$type] args[@args]");

    # bootstrap defaults
    my ( $server , $pass , $user ) ;

    # set some defaults
    $CONN_INFO{'cli_type'}="dns";

    # if we don't recognise the arg, 
    # then we assume it is a servername

#     if ( $type !~ /^$IPRE$/) {

    # must be a server type, check the syntax
    # syntax check next arg...
    my $etype ;
    my @opts = ( "dns","radius","user","password");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    # Set the servername
    if ( ! $etype ) { 
       # must be a servername
       $server = $type ;
       $CONN_INFO{'Host'} = $server ;
       &debug (3,"conf server s($server)");
    }
    else {
       # hack things by fudging the arglist
       # we make 'conf server user brian'
       # look like 'conf server xxx user brian'

       unshift ( @args , $type ) ;
       &debug (3,"conf server push t[$type] args[@args]");
    }

=pod

IF you change any of the settings, the others are kept. this lets you do
potentially usefull (dangerous) things like keep the username and password
between different servers

    [0] ! no server > conf server 1.2.3.4 user admin passwd infoblox
   
    # switch servers, same user and pass.
    [0] ! 1.2.3.4 > conf server 1.2.4.20

=cut
    
    # walk the rest of the arg list
    while ( my $arg = shift @args ) {

       # do we have a match ?
       my $earg = $optlist{ lc($arg) } ;

       if ( ! $earg ) {
          &missing_arg(@opts);
          return ;
       }

       # grab the user
       if ( $earg eq "user" ) {
          $user = shift @args ;
          $CONN_INFO{'UserName'} = $user ;
          &debug (3,"conf server arg($arg) u($user)");
       }
       # grab the password
       if ( $earg eq "password" ) {
          $pass = shift @args ;
          $CONN_INFO{'UserPassword'} = $pass ;
          &debug (3,"conf server arg($arg) p($pass)");
       }

       # [ ] insert stuff here for radius
       if ( $earg eq "radius" or $earg eq "dns" ) {
          $CONN_INFO{'cli_type'}=$earg ;
          &debug (3,"conf server arg($arg) t($earg)");
       }

    }

    my $c_type = $CONN_INFO{'cli_type'};
    &debug (2,"adding server t[$c_type] s($server) p($pass) u($user)");

    &connect ;

#     # ok - now eat the rest of the data

#        # if we're already connected, sput an error
#        if ( ! $CONNECTED ) {
#           &debug (2,"adding server [$server]");
#           $CONN_INFO{'Host'} = $server ;
# 
#           $PROMPT = "$CONN_INFO{'UserNAme'}\@$CONN_INFO{'Host'} > " ;
# 
#           # when you specify a new server, you need to re-set the
#           # password
#           if ( $pass ) {
#              $CONN_INFO{'UserPassword'} = $pass ;
#           }
#           else {
#              # this is a NON DNSone, DIG only
#              # unset the password
#              $CONN_INFO{'UserPassword'} = "" ;
#           }
#           &debug (2,"adding passwd [$pass]");
# 
#           if ( $user ) {
#              # this is a v3 system
#              $CONN_INFO{'UserName'} = $user ;
#           }
#           &debug (2,"adding user [$user]");
# 
#        }
#        else {
#           &err_print("SERVER :: already connected");
#        }
}

# sub add_pass {
#     my ($passwd) = @_ ;
# 
#     if ($passwd) {
#        # save the server password and see if we have enough info to connect
#        &debug (2,"adding passwd [$passwd]");
#        $CONN_INFO{'UserPassword'} = $passwd ;
# 
#        # attepmt to connect
#        &connect ;
#     }
#     else {
#        &missing_arg("$SAVE_HIST <password>");
#     }
# }

#
# [ ] really need 2 routines here, one for batch mode and one for calls
# to 'connect' from the cli
#
sub connect {
    # make a connection
    # unless we have both server and password,  die

    # all the CLI conf server calls can just
    # poke the hash, that way we can keep the same user, but
    # change the server.
    #

    my $conhash = Dumper( { %CONN_INFO } );
    &debug(3,"conn $conhash");
    
    # try and set the prompt anyway
    if ( $CONN_INFO{'Host'} ) {
        $PROMPT = "$CONN_INFO{'Host'} > " ;
    }

    # otherwise try and connect
      if ( $CONN_INFO{'Host'} 
           && $CONN_INFO{'UserName'}
           && $CONN_INFO{'UserPassword'} ) {

#          if ( $CONNECTED ) {
#             &err_print("SERVER :: already connected");
#             return ;
#          }

         # now set up the correct hashes for connection
         my %priv_hash;
         $priv_hash{'HostIp'} = $CONN_INFO{'Host'};
         $priv_hash{'UserName'} = $CONN_INFO{'UserName'};
         $priv_hash{'UserPassword'} = $CONN_INFO{'UserPassword'};
         $priv_hash{'HostPort'} = "443";
         $priv_hash{'Secure'} = "true";

         # set the prompt
         $MADE_CHANGES = " " ;
         $PROMPT = "$CONN_INFO{'UserName'}\@$CONN_INFO{'Host'} > " ;

#          if ( $CONN_INFO{'UserName'} ) {
#          }
#          else {
#             $PROMPT = "$CONN_INFO{'Host'} > " ;
#          }

         &debug (1,"connect -> $PROMPT");

#          &err_print("SERVER :: connecting");

         # DO a RADIUS connection
         #
         if ( $CONN_INFO{'cli_type'} eq 'radius' ) {
            if ( $MAKE ) {
               # pretty print the hash 
               &print_data("RADIUSOne::server_session_create",%CONN_INFO);
            }
            else {
               my $res ;
               ($res,$PUB_SESS)=RADIUSOne::server_session_create(%CONN_INFO);
            }
         }

         # DO a DNS connection
         #
         # set the global PUB_SESS or PRIV_SESS
         # which we will call later
         else {
            # pretty print the hash 
            if ( $MAKE ) {
               my $cptr = \%CONN_INFO ;
               my $pptr = \%priv_hash ;

               # format the data for pretty printing
#          my $fst=&format_ib_func("Infoblox::Session->new",$cptr);
#          my $fst=&format_ib_func("Infoblox::InfobloxSession->new",$pptr);
               &print_data("Infoblox::Session->new",$cptr);
               &print_data("Infoblox::InfobloxSession->new",$pptr);
            }
            else {
               # set up the handlers
               $PUB_SESS = Infoblox::Session->new( %CONN_INFO );
               $PRI_SESS = Infoblox::InfobloxSession->new( %priv_hash );
            }
         }

   
         # this will never change until you quit
         $CONNECTED = 1 ;

      }
      else {
#          &err_print ("CANNOT CONNECT :: no server|user|password supplied");
         &debug (3,"NOOP - incomplete details for server connection");
      }
}

=head1 RESTARTING services

the cli will not restart services, you have to do that manually

   restart dns
   restart dhcp

IF you want to delay the restart you can do that also

   restart dns delay 10

=cut

sub restart {

    my ( $service , $delay , $timer ) = @_ ;

    my $eopt ;
    my @opts = ( "dns","dhcp");
    my %optlist = abbrev ( @opts ) ;
    $eopt = $optlist{ lc($service) } ;

    if ( ! $eopt ) { 
       &missing_arg(@opts);
       return ;
    }

    &debug (2,"restart t($eopt) [$timer]");

    my %opthash ;
    $opthash{'protocol_type'}=$service;
    $opthash{'delay'}=0;

    # delay ?
    my $edel ;
    if ( $delay ) {
       my @opts = ( "delay");
       my %optlist = abbrev ( @opts ) ;
       $edel = $optlist{ lc($delay) } ;

       if ( ! $edel ) { 
          &missing_arg(@opts);
          return ;
       }

       if ( $timer ) {
          $opthash{'delay'}=$timer;
       }
       else {
          &missing_arg("@opts <time>");
          return ;
       }
    }

    my @function=("restart_service",%opthash);
    &do_pub_func(@function);

    $MADE_CHANGES = " " ;

}

# sub commit {
# 
#     #
#     # call 'publish changes' ??
#     #
# #     &err_print ( "COMMIT -  NOT WORKING");
# 
#     if ( $CONNECTED ) {
#        print "SERVER :: Committing Changes .. ";
# 
#        ib_close_connection();
#        sleep 3 ;
#        ib_open_connection($CONN_INFO{'Host'},$CONN_INFO{'UserPassword'}) ;
# 
# #        ib_update_server();
# 
#        print "DONE.\n";
# 
#        $MADE_CHANGES = " " ;
#     }
#     else {
#        &err_print ("CANNOT COMMIT - no connection is in place");
#     }
# }

# sub disconnect {
# 
#     &err_print ( "Disconnect :: depricated");
# 
#     if ( $CONNECTED ) {
# #        &commit ;
# #        ib_close_connection();
# #    [ ] restart service ??
#        $CONNECTED = 0 ;
# 
#        $PROMPT = "no server > " ;
#     }
# #     else {
# #        &err_print ( "CANNOT DISCONNECT - no connection is in place");
# #     }
# 
# }

#
# DIGS AND GET ROUTINES
#

=head1 SHOW commands

What ? I thought the API didn't support 'show' ? You are correct, the
API doesn't but we can wrap a more abstract syntax around commands like
'dig' and or 'nslookup'. Now, we aren't really interrogating the
database, just the Protocol server, but this is a good thing since we
want to make sure that the data has actually been published anyway.

Show a zone (SOA by default)

    show zone foo.com

Show the full zone file

    show zone foo.com axfr

Show a host

    show host test.foo.com

NOTE, in order to make sure we are getting data from the server, all
queries are non-recursive.

=cut

sub show_host {
    my ($query,$verbose) = @_ ;

    # use dig...

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <host> (verbose)") ;
       return (0) ;
    }

    &debug (2,"showing zone [@_]");

    &do_dig($CONN_INFO{'Host'},$query,$verbose);


}

sub show_zone {
    my ($query,$type,$verbose) = @_ ;

    # use dig...
    # forget about the verbose option for now, dig can do that directly.

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <zone> (type)") ;
       return (0) ;
    }

    &debug (2,"showing zone [@_]");

    if ( ! $type ) { $type = "SOA" }

    &do_dig($CONN_INFO{'Host'},$query,$type,$verbose);
}

sub show_network {
    my ($query,$type,$verbose) = @_ ;

    # use dig...
    # forget about the verbose option for now, dig can do that directly.

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <network> (type)") ;
       return (0) ;
    }

    &debug (2,"showing network [@_]");

    if ( ! $type ) { $type = "SOA" }

    # force a revrse lookup
    $verbose = "reverse" ;
    &do_dig($CONN_INFO{'Host'},$query,$type,$verbose);
}

sub do_dig {
    # use a 'dig' to get zone data.
#     my $DIG = '/usr/bin/dig' ;
    my $DIG = 'dig' ;
    my $DIGOPTS = '+multiline +nostat +nocmd +norecur';
    my $TERSEOPTS = '+noquestion +noauthority +noadditional +nocomments';
    my $REVOPTS = '+noquestion +noadditional +nocomments';

    my $V_DIG = "$DIG $DIGOPTS";
    my $T_DIG = "$DIG $DIGOPTS $TERSEOPTS";
    my $R_DIG = "$DIG $DIGOPTS $REVOPTS";

    # so we pass args to dig to work out what type of dig to do
    &debug (3,"dig reqest =  [@_]");
    my ($server,$query,$type,$verbose) = @_ ;

    my $COMM ;

    # verbose is disabled for now, i'll use it for something else.
    if ($verbose) {
       $COMM = "$V_DIG \@$server $query $type";
       if ( $verbose eq "reverse" ) {
          $COMM = "$R_DIG \@$server -x $query $type";
       }
    }
    else {
       $COMM = "$T_DIG \@$server $query $type";
    }

    &debug (2,"dig comm =  [$COMM]");

#     if ( ! $CONNECTED ) {
#        &err_print( "CANNOT dig - no connection is in place");
#     }
#     else {
#        print "\n";
#        system("$COMM");
#        print "\n";
#     }

    print "\n";
    system("$COMM");
    print "\n";

}

# ib_open_connection(\$SERVER_ID,\$SERVER_PASS);
sub script_header {

    print "#!/usr/bin/perl
#
# AUTOGENERATED from $NAME 
#
\n";
print "use Infoblox::InfobloxDNS;\n";
print "use Infoblox::RADIUSOne;\n";
print "use Infoblox;\n";
print "\n";

}

sub script_footer {

    print "

exit ; \n";

}

sub show_version {
    print "$REV\n";
}


############################################3


sub rename_custom_option {
  # remap some variables
    my $option = shift;
    my %lookup = (
        "1" => "Option  1: subnet-mask",
        "2" => "Option  2: time-offset",
        "3" => "Option  3: router",
        "4" => "Option  4: time-servers",
        "5" => "Option  5: ien116-name-servers",
        "6" => "Option  6: dns_server",
        "7" => "Option  7: log-servers",
        "8" => "Option  8: cookie-servers",
        "9" => "Option  9: lpr-servers",
        "10" => "Option  10: impress-servers",
        "11" => "Option  11: resource-location-servers",
        "12" => "Option  12: host-name",
        "13" => "Option  13: boot-size",
        "14" => "Option  14: merit-dump",
        "15" => "Option  15: default_domain",
        "16" => "Option  16: swap-server",
        "17" => "Option  17: root-path",
        "18" => "Option  18: extensions-path",
        "19" => "Option  19: ip-forwarding",
        "20" => "Option  20: non-local-source-routing",
        "21" => "Option  21: policy-filter",
        "22" => "Option  22: max-dgram-reassembly",
        "23" => "Option  23: default-ip-ttl",
        "24" => "Option  24: path-mtu-aging-timeout",
        "25" => "Option  25: path-mtu-plateau-table",
        "26" => "Option  26: interface-mtu",
        "27" => "Option  27: all-subnets-local",
        "28" => "Option  28: broadcast_address",
        "29" => "Option  29: perform-mask-discovery",
        "30" => "Option  30: mask-supplier",
        "31" => "Option  31: router-discovery",
        "32" => "Option  32: router-solicitation-address",
        "33" => "Option  33: static-routes",
        "34" => "Option  34: trailer-encapsulation",
        "35" => "Option  35: arp-cache-timeout",
        "36" => "Option  36: ieee802-3-encapsulation",
        "37" => "Option  37: default-tcp-ttl",
        "38" => "Option  38: tcp-keepalive-interval",
        "39" => "Option  39: tcp-keepalive-garbage",
        "40" => "Option  40: nis-domain",
        "41" => "Option  41: nis-servers",
        "42" => "Option  42: ntp-servers",
        "43" => "Option  43: vendor-encapsulated-options",
        "44" => "Option  44: netbios-name-servers",
        "45" => "Option  45: netbios-dd-server",
        "46" => "Option  46: netbios-node-type",
        "47" => "Option  47: netbios-scope",
        "48" => "Option  48: font-servers",
        "49" => "Option  49: x-display-manager",
        "50" => "Option  50: dhcp-requested-address",
        "51" => "Option  51: lease_time",
        "52" => "Option  52: dhcp-option-overload",
        "53" => "Option  53: dhcp-message-type",
        "54" => "Option  54: dhcp-server-identifier",
        "55" => "Option  55: dhcp-parameter-request-list",
        "56" => "Option  56: dhcp-message",
        "57" => "Option  57: dhcp-max-message-size",
        "58" => "Option  58: dhcp-renewal-time",
        "59" => "Option  59: dhcp-rebinding-time",
        "60" => "Option  60: vendor-class-identifier",
        "61" => "Option  61: dhcp-client-identifier",
        "62" => "Option  62: nwip-domain",
        "63" => "Option  63: nwip-suboptions",
        "64" => "Option  64: nisplus-domain",
        "65" => "Option  65: nisplus-servers",
        "66" => "Option  66: tftp-server-name",
        "67" => "Option  67: boot_file",
        "68" => "Option  68: mobile-ip-home-agent",
        "69" => "Option  69: smtp-server",
        "70" => "Option  70: pop-server",
        "71" => "Option  71: nntp-server",
        "72" => "Option  72: www-server",
        "73" => "Option  73: finger-server",
        "74" => "Option  74: irc-server",
        "75" => "Option  75: streettalk-server",
        "76" => "Option  76: streettalk-directory-assistance-server",
        "77" => "Option  77: user-class",
        "78" => "Option  78: slp-directory-agent",
        "79" => "Option  79: slp-service-scope",
        "80" => "Option  80: option-80",
        "81" => "Option  81: fqdn",
        "82" => "Option  82: relay-agent-information",
        "83" => "Option  83: option-83",
        "84" => "Option  84: option-84",
        "85" => "Option  85: nds-servers",
        "86" => "Option  86: nds-tree-name",
        "87" => "Option  87: nds-context",
        "88" => "Option  88: option-88",
        "89" => "Option  89: option-89",
        "90" => "Option  90: option-90",
        "91" => "Option  91: option-91",
        "92" => "Option  92: option-92",
        "93" => "Option  93: option-93",
        "94" => "Option  94: option-94",
        "95" => "Option  95: option-95",
        "96" => "Option  96: option-96",
        "97" => "Option  97: option-97",
        "98" => "Option  98: uap-servers",
        "99" => "Option  99: option-99",
        "100" => "Option  100: option-100",
        "101" => "Option  101: option-101",
        "102" => "Option  102: option-102",
        "103" => "Option  103: option-103",
        "104" => "Option  104: option-104",
        "105" => "Option  105: option-105",
        "106" => "Option  106: option-106",
        "107" => "Option  107: option-107",
        "108" => "Option  108: option-108",
        "109" => "Option  109: option-109",
        "110" => "Option  110: option-110",
        "111" => "Option  111: option-111",
        "112" => "Option  112: option-112",
        "113" => "Option  113: option-113",
        "114" => "Option  114: option-114",
        "115" => "Option  115: option-115",
        "116" => "Option  116: option-116",
        "117" => "Option  117: option-117",
        "118" => "Option  118: subnet-selection",
        "119" => "Option  119: option-119",
        "120" => "Option  120: option-120",
        "121" => "Option  121: option-121",
        "122" => "Option  122: option-122",
        "123" => "Option  123: option-123",
        "124" => "Option  124: option-124",
        "125" => "Option  125: option-125",
        "126" => "Option  126: option-126",
        "127" => "Option  127: option-127",
        "128" => "Option  128: option-128",
        "129" => "Option  129: option-129",
        "130" => "Option  130: option-130",
        "131" => "Option  131: option-131",
        "132" => "Option  132: option-132",
        "133" => "Option  133: option-133",
        "134" => "Option  134: option-134",
        "135" => "Option  135: option-135",
        "136" => "Option  136: option-136",
        "137" => "Option  137: option-137",
        "138" => "Option  138: option-138",
        "139" => "Option  139: option-139",
        "140" => "Option  140: option-140",
        "141" => "Option  141: option-141",
        "142" => "Option  142: option-142",
        "143" => "Option  143: option-143",
        "144" => "Option  144: option-144",
        "145" => "Option  145: option-145",
        "146" => "Option  146: option-146",
        "147" => "Option  147: option-147",
        "148" => "Option  148: option-148",
        "149" => "Option  149: option-149",
        "150" => "Option  150: option-150",
        "151" => "Option  151: option-151",
        "152" => "Option  152: option-152",
        "153" => "Option  153: option-153",
        "154" => "Option  154: option-154",
        "155" => "Option  155: option-155",
        "156" => "Option  156: option-156",
        "157" => "Option  157: option-157",
        "158" => "Option  158: option-158",
        "159" => "Option  159: option-159",
        "160" => "Option  160: option-160",
        "161" => "Option  161: option-161",
        "162" => "Option  162: option-162",
        "163" => "Option  163: option-163",
        "164" => "Option  164: option-164",
        "165" => "Option  165: option-165",
        "166" => "Option  166: option-166",
        "167" => "Option  167: option-167",
        "168" => "Option  168: option-168",
        "169" => "Option  169: option-169",
        "170" => "Option  170: option-170",
        "171" => "Option  171: option-171",
        "172" => "Option  172: option-172",
        "173" => "Option  173: option-173",
        "174" => "Option  174: option-174",
        "175" => "Option  175: option-175",
        "176" => "Option  176: option-176",
        "177" => "Option  177: option-177",
        "178" => "Option  178: option-178",
        "179" => "Option  179: option-179",
        "180" => "Option  180: option-180",
        "181" => "Option  181: option-181",
        "182" => "Option  182: option-182",
        "183" => "Option  183: option-183",
        "184" => "Option  184: option-184",
        "185" => "Option  185: option-185",
        "186" => "Option  186: option-186",
        "187" => "Option  187: option-187",
        "188" => "Option  188: option-188",
        "189" => "Option  189: option-189",
        "190" => "Option  190: option-190",
        "191" => "Option  191: option-191",
        "192" => "Option  192: option-192",
        "193" => "Option  193: option-193",
        "194" => "Option  194: option-194",
        "195" => "Option  195: option-195",
        "196" => "Option  196: option-196",
        "197" => "Option  197: option-197",
        "198" => "Option  198: option-198",
        "199" => "Option  199: option-199",
        "200" => "Option  200: option-200",
        "201" => "Option  201: option-201",
        "202" => "Option  202: option-202",
        "203" => "Option  203: option-203",
        "204" => "Option  204: option-204",
        "205" => "Option  205: option-205",
        "206" => "Option  206: option-206",
        "207" => "Option  207: option-207",
        "208" => "Option  208: option-208",
        "209" => "Option  209: option-209",
        "210" => "Option  210: authenticate",
        "211" => "Option  211: option-211",
        "212" => "Option  212: option-212",
        "213" => "Option  213: option-213",
        "214" => "Option  214: option-214",
        "215" => "Option  215: option-215",
        "216" => "Option  216: option-216",
        "217" => "Option  217: option-217",
        "218" => "Option  218: option-218",
        "219" => "Option  219: option-219",
        "220" => "Option  220: option-220",
        "221" => "Option  221: option-221",
        "222" => "Option  222: option-222",
        "223" => "Option  223: option-223",
        "224" => "Option  224: option-224",
        "225" => "Option  225: option-225",
        "226" => "Option  226: option-226",
        "227" => "Option  227: option-227",
        "228" => "Option  228: option-228",
        "229" => "Option  229: option-229",
        "230" => "Option  230: option-230",
        "231" => "Option  231: option-231",
        "232" => "Option  232: option-232",
        "233" => "Option  233: option-233",
        "234" => "Option  234: option-234",
        "235" => "Option  235: option-235",
        "236" => "Option  236: option-236",
        "237" => "Option  237: option-237",
        "238" => "Option  238: option-238",
        "239" => "Option  239: option-239",
        "240" => "Option  240: option-240",
        "241" => "Option  241: option-241",
        "242" => "Option  242: option-242",
        "243" => "Option  243: option-243",
        "244" => "Option  244: option-244",
        "245" => "Option  245: option-245",
        "246" => "Option  246: option-246",
        "247" => "Option  247: option-247",
        "248" => "Option  248: option-248",
        "249" => "Option  249: option-249",
        "250" => "Option  250: option-250",
        "251" => "Option  251: option-251",
        "252" => "Option  252: option-252",
        "253" => "Option  253: option-253",
        "254" => "Option  254: option-254",
    );

    # fix it ?
    if ( $lookup{$option} ) {
       return ( $lookup{$option} );
    }
    else {
       return ( $option );
    }

}


sub cidrfind {
    # match up netmasks to cidr syntax
    # YES, i /KNOW/ i can do this using math, but this took me
    # 20 seconds with cut and paste and it works, so move along
    # there's nothing to see here.
    #  (besides, a hash lookup is probably faster)
    my ($cidr) = @_ ;
    my %mlook = (
       8 =>  '255.0.0.0' ,
       9 =>  '255.128.0.0' ,
       10 => '255.192.0.0' ,
       11 => '255.224.0.0' ,
       12 => '255.240.0.0' ,
       13 => '255.248.0.0' ,
       14 => '255.252.0.0' ,
       15 => '255.254.0.0' ,
       16 => '255.255.0.0' ,
       17 => '255.255.128.0' ,
       18 => '255.255.192.0' ,
       19 => '255.255.224.0' ,
       20 => '255.255.240.0' ,
       21 => '255.255.248.0' ,
       22 => '255.255.252.0' ,
       23 => '255.255.254.0' ,
       24 => '255.255.255.0' ,
       25 => '255.255.255.128' ,
       26 => '255.255.255.192' ,
       27 => '255.255.255.224' ,
       28 => '255.255.255.240' ,
       29 => '255.255.255.248' ,
       30 => '255.255.255.252' ,
    ) ;

    &debug(3,"CIDR is [$cidr]");
    &debug(3,"MASK is [$mlook{$cidr}]");

    return($mlook{$cidr}) ;
}

=head1 More on Debugging :

when the debug level is set high, or if you use the -m (for make) option
you will get the hash data structure dumped back at you in perl parsable
syntax.

However, this does rely on you having Data::Dumper installed

=cut


sub print_data {
    # use the data dumper for pretty printing
    use Data::Dumper ;
    my ($func , $hash ) = @_ ;

    # extra info for '-m'
    my $pre_print = "print \"$func \\n\";";

    # terse removes the $VAL
    # lesser indent and pad x spaces
    $Data::Dumper::Terse = 1 ;
    $Data::Dumper::Indent = 1 ;
    $Data::Dumper::Pad = "     " ;

    # format the hash
    my $p_hash = Dumper($hash);
    
    my $fstring = "  my \$result = $func ( \$SESSION ,\n$p_hash   );";

    if ( $MAKE ) {
       print "$pre_print\n";
       print "$fstring\n";
    }
    else {
       &debug(3,$fstring);
    }
}

# sub dump_hash {
#     # recursively walk a data structure
#     my ($depth,$type,@data) = @_ ;
# 
#     # we're going to stuff all this into a variable
#     my $syntax ;
# 
#     # set the spacer
#     my $spc ;
#     for my $i ( 0 .. $depth ) { $spc .= "    " }
# 
#     # type dependent
#     if ( $type eq "HASH" ) {
#        my %hash = @data ;
#        $syntax .= "$spc { \n";
#        foreach my $key ( sort keys %hash ) {
#           my $value = $hash{$key} ;
# 
#           # do we recurse or print ?
#           if ( $value =~ /^HASH/ ) {
#              $syntax .= "$spc '$key' => \n";
#              $syntax .= &dump_hash ( $depth+1 , "HASH" , %{ $hash{$key} } );
#           }
#           elsif ( $value =~ /^ARRAY/ ) {
#              $syntax .= "$spc '$key' => \n";
#              $syntax .= &dump_hash ( $depth+1 , "ARRAY" , @{ $hash{$key} } );
#           }
#           else {
#             $syntax .= "$spc '$key' => '$value',\n";
#           }
#        }
#        $syntax .= "$spc }, \n";
#     }
# 
#     elsif ( $type eq "ARRAY" ) {
#        $syntax .= "$spc [\n";
#        foreach my $value ( @data ) {
#           if ( $value =~ /^HASH/ ) {
#              $syntax .= &dump_hash ( $depth+1 , "HASH" , %{ $value } );
#           }
#           elsif ( $value =~ /^ARRAY/ ) {
#              $syntax .= &dump_hash ( $depth+1 , "ARRAY" , @{ $value } );
#           }
#           else {
#              $syntax .= "$spc'$value',\n";
#           }
#        }
#        $syntax .= "$spc ], \n";
#     }
# 
#     return ( $syntax ) ;
# 
# }

sub debug {
    # we're passed a message and a level
    # if this level is <= the CURRENT DEBUG level 
    # we print the data
    my $level = shift @_ ;


    if ($level <= $DEBUG) {
        if ( $MAKE ) { print "# " ; }
        print "($level) DEBUG: @_\n";
    }

}

###########################################################

# $Log: ibcli,v $
# Revision 2.6  2005/03/05 19:27:15  horne
# added support for custom options
#
# Revision 2.5  2004/12/22 20:52:05  horne
# fixed the commit prompt
# changed commit to 'reatart'
# really cleaned up the connection handler
# changed all 'set' to 'conf'
# cleaned up pod examples
#
# Revision 2.4  2004/12/20 15:57:03  horne
# *** empty log message ***
#
# Revision 2.3  2004/12/18 12:53:46  horne
# Ripped out all the recursive hash print stuff and replaced it with
# Data::Dumper instead (much cleaner)
#
# Revision 2.2  2004/12/18 12:10:13  horne
# this version has perldoc
#
# Revision 2.1  2004/12/14 05:09:01  horne
# first round of bug testing
# also added member support
# also add import zone
#
# Revision 2.0  2004/11/03 19:58:48  horne
# new code suporting the infoblox V3 API
# major rewrite
#
# Revision 1.18  2004/10/20 16:44:39  horne
# broken checkin - ignore
#
# Revision 1.17  2004/08/13 05:21:09  horne
# Added correct connection handling
#
# Revision 1.16  2004/08/13 03:57:45  horne
# Major changes to the arg parsers, args are now sent as arrays and the
#   do_ib_func does the formatting/prettyprinting
# Added conection syntax to hanvle V3 connections
# Added a whole bag of RADIUS commands
#
# Revision 1.15  2004/08/01 19:34:03  horne
# Added 'peer_assoc' support for V2.5
#
# Revision 1.14  2004/06/16 20:19:46  horne
# added comments to ptrs
# added modify global dhcp opts
#   conf dhcp global
# added fixed addresses
# added modify network options
#   conf net x.x.x.x/mm modify opt value
# added non-auth networks
#
# Revision 1.13  2004/02/13 20:11:21  horne
# added the command lister
#
# Revision 1.12  2003/11/26 01:29:09  horne
# *** empty log message ***
#
# Revision 1.11  2003/11/06 07:31:28  horne
# server and password now live on the same commandline
# upload and download database
# import zone
# conf zone add now takes additional options
#
# the software now writes its own code
#
# Revision 1.10  2003/10/16 21:41:25  horne
# un hardcoede dig
# changed password syntax
# added a -V -v option (version)
# added download commands
#
# Revision 1.9  2003/09/24 01:43:08  horne
# added dhcp range stuff
# cleaned up the dig pre-processing
#
# Revision 1.8  2003/09/22 21:37:30  horne
# added prt functions
# cleaned up show network
#
# Revision 1.7  2003/09/22 19:24:30  horne
# *** empty log message ***
#
# Revision 1.6  2003/09/21 23:04:29  horne
# added ambiguous commands
# prints now wrapped for cli or batch
# batch commands now work
#
# Revision 1.5  2003/09/20 01:22:36  horne
# First full working version with the abstracted argument parser.
# there is still a lot of gumpf in here, but most of the repeatable code is
# now packed into subroutines
#
# Revision 1.4  2003/09/18 02:28:56  horne
# *** empty log message ***
#
# Revision 1.3  2003/09/16 23:17:25  horne
# *** empty log message ***
#
# Revision 1.2  2003/09/09 22:58:27  horne
# *** empty log message ***
#
# Revision 1.1  2003/08/11 23:31:57  horne
# INFOBLOX version, re-set the CVS counters
#
# Revision 1.9  2001/06/07 16:45:47  horne
# major rewrite of the arg parser - ripped out all the RE's to a much better
# process.
# delete commands disabled
#
# Revision 1.8  2001/05/31 05:28:15  horne
# *** empty log message ***
#
# Revision 1.7  2001/05/24 00:17:54  horne
# Added RE's to handle shortened commant words, not however that this is
# still buggy, typos, as long as they are unique will still work. thus
#  - password, p , pa , ps , pdfgt = password
# I need to find a better command parser
#
# Revision 1.6  2001/05/23 19:39:11  horne
# working version - waiting for updates from infoblox to see if they have
# changed the API syntax
#
# Revision 1.5  2001/05/19 06:08:13  horne
# iblox ready version, but no connections to servers work
#
# Revision 1.4  2001/05/19 04:59:19  horne
# All base commands are being parsed and netmasks are being applied.
# Now we need to hit the infoblox engine for real
#
# Revision 1.3  2001/05/19 03:43:45  horne
# added the DEBUG option before i started to drown in a lot of messy print
# statements
#
# Revision 1.2  2001/05/19 03:34:34  horne
# Basic version, config file parsing is functional.
#
# Revision 1.1  2001/05/19 03:33:56  horne
# *** empty log message ***
#
