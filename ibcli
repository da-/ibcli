#!/usr/bin/perl
#
# (c) Copyright: Geoff horne, SLC 2001-2003
#               All rights reserved
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. So there...
#
# THIS TICKET IS SOLD SUBJECT TO THE SELLERS CONDITIONS OF SALE OF COPY
# WHICH IS AVAILABLE FOR INSPECTION AT TIME OF PURCHASE AND/OR CONDITIONS
# OF THIS TICKET AND ALSO (TO THE EXTENT THAT THEY ARE NOT INCONSISTENt
# WITH THE SELLERS CONDITIONS OF SALE) THE FOLLOWING:
# 
# 1: A CHANGE IN CONDITIONS OF THE PURCHASER DOES NOT ENTITLE THE PURCHASER
#    TO RETURN OR EXCHANGE TICKET.
# 
# 2: THE SELLER RESERVES THE RIGHT TO:
#    - ADD, WITHDRAW OR SUBSTITUTE ARTISTS
#    - VARY ADVERTISED PROBRAMMES, SEATING ARRANGEMENT AND AUDIENCE
#      CAPACITY , AND:
#    - REFUSE ADMISSION WITH REASONABLE CAUSE
#
# 3: CAMERAS AND TAPE RECORDERS MAY NOT BE PERMITTED. LATE ARRIVALS MAY
#    RESULT IN NON-ADMITTANCE UNTIL A SUITABLE BREAK IN PERFORMANCE. THE
#    SELLER REQUESTS THAT ALL PAGERS AND MOBILE PHONES BE TURNED OFF BEFORE
#    ENTRY.
#
# 4: IF AN OUTDOOR PERFORMANCE IS CANCELLED DUE TO ADVERSE WEATHER OR ANy
#    OTHER CAUSE REASONABLY BEYOND THE SELLERS CONTROL, THERE IS NO RIGHT 
#    TO A REFUND OR EXCHANGE, AND THE SELLER IS NOT OBLIGED TO ARRANGE A 
#    SUBSTITUTE SERVICE, EVENT OR PERFORMANCE
#
# StreetLevel Communications
#
#            support@slc.com.au
#            ph: +1-650-483-0998
#
###############################################################################


# $Id: ibcli,v 1.4 2003/09/18 02:28:56 horne Exp $
# $Revision: 1.4 $
# $Date: 2003/09/18 02:28:56 $
#

# Perl CGI common chunks
#
use strict ;
no strict "refs" ;
use Getopt::Long ;


# include infoblox
use InfoBloxDNS ;

#### work out where i am
# these 3 varables can then be used to find config files
# and keep the code portable

use FindBin qw($Bin $Script);
my ($BASE,$NAME)=($Bin,$Script) ;

######################
#
# define some globals
#
my $DEBUG = 0 ;
my $CLI = 0 ;
my $CONN_STRING = "!" ;

my $SERVER_ID ;
my $SERVER_PASS ;
my $CONNECTED ;
my $CONFIG ;

my $GOOD_COMMAND ;
# my $NO_COMMAND ;
my $SAVE_HIST ;
my @CLIST ;
my @HISTORY ;

my $PROMPT ;

#
#####################

# read the lines
# the datastructure is kinda nested, but the command set is still small
# enough to avoid some sort of lexical overhead subroutine

## NOTE - to make a better CLI version we should have a wrapper loop that
#  checks if you are coming in as a file or STD in. The primary loop in
#  either case should pass to the actual arg parser
#

# optional args
# -f <config file>
# -s <server>
# -p <password>
# -d <debug level>

GetOptions(
      "s=s" => \$SERVER_ID , 
      "p=s" => \$SERVER_PASS ,
      "f=s" => \$CONFIG ,
      "d=s" => \$DEBUG ,
   );

if ( ! $SERVER_ID ) { $PROMPT = "no server > " ; }
else                { $PROMPT = "$SERVER_ID > " ; }

if ( ! $CONFIG ) {
   print "CLI version\n";
   $CLI = 1 ;
   # unflush the buffer
   $| = 1 ;

   # set initial prompt
   &print_prompt ;
}

#
# time to read commands, line at a time...
#

while (<>) {

   # strip blanks, comments etc
   if ( /^\s*#/ ) { &print_prompt ; next ; } ;
   if ( /^\s*$/ ) { &print_prompt ; next ; } ;

   $GOOD_COMMAND = 1 ;
#    $NO_COMMAND   = 1;

   chomp ;

   #
   # Pattern matching, we want 'fuzzy' matches but only in the form of
   # abbreviations, if the command is 'server', 'ser' and 'serv' should
   # match but not 'serf'. FORTUNATELY, there seems to be a perlmodule
   # for this. ( Text::Abbrev )
   #
   # and the nice thing is that we can build up a hash
   # of command to subroutine matching, the abbrev code will
   # find the right command to call, then we can pass the WHOLE line to
   # the required routine.
   #
   # HOWEVER, the additional args at the end of the line will break the
   # abbrev match, so we still need to eat the line - 1 word at a time
   # and branch apropriately
   #
   # if the abbrev gets an ambiguous match, we return '0'...

   # we have a problem in that if we get a match on the first arg we are
   # still in 2 states
   #  - execute
   #  - check for more args
   #  - check for more commands
   #
   # after the branching we still keep track of :
   #  - the original command (for history)
   #  - the optional args
   # and IF WE GET A MATCH, we say the command is good and THEN execute


   # SO break the commandline into components
   my (@words) = split /\s+/ ;
   my $arg = shift @words ;

   use Text::Abbrev ;
   my %commands = ( 
                'history' => 'show_history',
                'commit' => 'commit',
                'disconnect' => 'disconnect',
                'set' => 'set_commands' ,
                'show' => 'show_commands' ,
        ) ;
   @CLIST = sort keys %commands ;
   my %clookup = abbrev ( @CLIST ) ;

   my $full_comm = $clookup{ lc($arg) };
   &debug (3,"command = [$full_comm]");


   # $full_comm does the abbreviation lookup and gets the
   # ACTUAL full comand name, or returns '0' so the expansion
   # is automatic
   
   if ( $full_comm ) {
      &rd_line($commands{$full_comm},$full_comm,@words) ;
      $SAVE_HIST = "$full_comm" ;
   }
   else {
      print "Ambiguous : $_\n";
      print "\t@CLIST\n";
      $GOOD_COMMAND = 0 ;
   }


   # history - if kosher
   # ( done at the end, after all other line processing... )
   if ( $GOOD_COMMAND ) {
      &addhistory($SAVE_HIST , @words);
   }

   # lastly - the prompt
   &print_prompt ;

   
}

# just in case
if ( $CONNECTED ) { &disconnect } ;

exit ;

################################################################

sub set_commands {
   
   my @words = @_ ;
   my $arg = shift @words ;

   my %commands = ( 
                'debug' => 'set_debug',
                'server' => 'add_server',
                'password' => 'add_pass',
        ) ;
   @CLIST = sort keys %commands ;
   my %clookup = abbrev ( @CLIST ) ;

   my $full_comm = $clookup{ lc($arg) };
   &debug (3,"set command = [$full_comm]");

   if ( $full_comm ) {
      &rd_line($commands{$full_comm},$full_comm,@words)
   }
   else {
      print "Next possible completions :\n";
      print "\t@CLIST\n";
      $GOOD_COMMAND = 0 ;
#       &print_prompt ;
   }
   
   # set commands
   if ($arg =~ /^SE\w*/i) {
      $arg="set";
      &debug(1,"arg=[$arg]");

      if (@words) {
         my $arg1 = shift @words ;

         # DEBUG
         if ($arg1 =~ /^DEB\w*/i) { 
             $arg1 = "debug";
            if (@words) { &rd_line("set_debug","$arg $arg1",@words) }
            else        { &missing_arg("$arg $arg1 <level>"); }
         }

         # SERVER
         if ($arg1 =~ /^SER\w*/i) { 
             $arg1 = "server";
            if (@words) { &rd_line("add_server","$arg $arg1",@words) }
            else        { &missing_arg("$arg $arg1 <server>"); }
         }

         # PASSWORD
         if ($arg1 =~ /^P\w*/i) { 
             $arg1 = "password";
            if (@words) { &rd_line("add_pass","$arg $arg1",@words) }
            else        { &missing_arg("$arg $arg1 <password>"); }
         }

      }
      else        { &missing_arg("set ?"); }
   }

}

sub show_commands {

   my ( $arg , @words ) ;

   # show commands
   if ($arg =~ /^SH\w*/i) {
      $arg="show";
      &debug(1,"arg=[$arg]");

      if (@words) {
          my $arg1 = shift @words ;

          # zone
          if ($arg1 =~ /^Z\w*/i)   { 
             $arg1 = "zone";
             if (@words) { &rd_line("get_zone","$arg $arg1",@words) }
             else        { &missing_arg("$arg $arg1 <zone>"); }
          }
          
          # network
          if ($arg =~ /^N\w*/i)   { 
             $arg1 = "network";
             if (@words) { &rd_line("get_zone","$arg $arg1",@words) }
             else        { &missing_arg("$arg $arg1 <1.2.3.4>"); }
          }
      }
      else        { &missing_arg("show <zone|network>"); }
      
   }
}

sub other_commands {
   
   my ( $arg , @words ) ;

   # add
   if ($arg =~ /^A\w*/i) {
      &debug(1,"[$arg]=add");
      my $arg = shift @words ;
      # zone
      if ($arg =~ /^Z\w*/i)   { &add_zone(@words)   ; &addhistory($_) }
      # network
      if ($arg =~ /^N\w*/i)   { &add_net(@words)    ; &addhistory($_) }
      # subnet
      if ($arg =~ /^S\w*/i)   { &add_sub(@words)    ; &addhistory($_) }
      # host
      if ($arg =~ /^HO\w/i)    { &add_host(@words)   ; &addhistory($_) }
   }

   # delete
   if ($arg =~ /^DEL\w*/i) {
      my $arg = shift @words ;
      # network
      if ($arg =~ /^N\w*/i)  { &remove_net(@words)   ; &addhistory($_) }
      # host
      if ($arg =~ /^H\w*/i)  { &remove_host(@words)  ; &addhistory($_) }
      # zone
      if ($arg =~ /^Z\w*/i)  { &remove_zone(@words)  ; &addhistory($_) }
   }

   # split
   if ($arg =~ /^SP\w*/i) {
      my $arg = shift @words ;
      # network
      if ($arg =~ /^N\w*/i) { &split_net(@words)  ; &addhistory($_) }
   }

}

##########################################################
#
# An important thing to note :
#
# what happens if you issue commands and you do NOT have a connection in
# place yet ? do we rely on the infoblox module to generate errors or
# should we assume the worst ? we don't want to re-invent the wheel
# here...
#
#


###########################################3
#

# parse a line, this is called EVERYTIME we press <cr> so we can
# do things like print the prompt
# we abstract this to keep it in one place
sub rd_line {

    # we're passed :
    #  the subroutine to call
    #  the ORIGINAL LINE (post cleanup)
    #  the subroutine arguments

    my ($command,$hstring,@args) = @_ ;

    &debug (3,"rd_line b: c[$command] h[$hstring] , go_c [$GOOD_COMMAND]");

#     $NO_COMMAND = 1 ;

    # call the command
    &$command(@args);

    #
    &debug (3,"rd_line a: c[$command] h[$hstring] , go_c [$GOOD_COMMAND]");
#     &debug (3,"good_c [$GOOD_COMMAND] , go_c [$GOOD_COMMAND]");

    # prompt
#     &print_prompt ;

}

sub missing_arg {
    print "Next possible completions : @_\n";
    $GOOD_COMMAND = 0 ;
#     $NO_COMMAND = 0 ;

#     &print_prompt ;
}

#
# PROMPT
#
sub print_prompt {
    print "[$DEBUG] $CONN_STRING $PROMPT" ;
}

#
# SET DEBUG
#
sub set_debug {
    if ( "@_" =~ /\d+/ ) {
       $DEBUG = shift @_ ;
#        $GOOD_COMMAND = 1 ;
    }
#     else {
#        &missing_arg("debug <level>");
#     }
}

#
# SHOW THE HISTORY:
#

sub addhistory {
    my ($line) = "@_" ;

    #cleanup spacing
    $line =~ s/^\s*//;
    $line =~ s/\s+/ /g;
    $line =~ tr/A-Z/a-z/;

    push @HISTORY , $line ;

}

sub show_history {
    my $lineno = 1 ;

    # walk through the history array and print what we input
    print "\n-- COMMAND HISTORY --\n";
    foreach my $command ( @HISTORY ) {
       print "-- $lineno\t$command\n";
       $lineno ++ ;
    }
    print "\n";

#     $GOOD_COMMAND = 1 ;

}

#
# SERVER CONNECTION STUFF.....
#

sub add_server {
    my ($arg) = @_ ;
    # save the server id and see if we have enough info to connect

    if ($arg) {
       &debug (2,"adding server [$arg]");
       $SERVER_ID = $arg ;

       $PROMPT = "$SERVER_ID > " ;

       &connect ;
    }
}

sub add_pass {
    my ($arg) = @_ ;

    if ($arg) {
       # save the server password and see if we have enough info to connect
       &debug (2,"adding passwd [$arg]");
       $SERVER_PASS = $arg ;
       &connect ;
    }
}

sub connect {
    # make a connection
    # unless we have both server and password die
    if ( $SERVER_ID && $SERVER_PASS ) {
       &debug (1,"connecting to server [$SERVER_ID] [$SERVER_PASS]");

       print "SERVER :: connecting \n";

       ######
       print "Connections :: DISABLED \n";
       ######

#        ib_open_connection($SERVER_ID,$SERVER_PASS) ;

       my $ibc='ib_open_connection($SERVER_ID,$SERVER_PASS)';
       &debug (3,"ibc [$ibc]");
       eval $ibc ;

       $PROMPT = "$SERVER_ID > " ;
       $CONN_STRING = "*" ;

       $CONNECTED = 1 ;

    }
    else {
       &debug (3,"NOOP - incomplete details for server connection");
    }

}

sub disconnect {
    if ( $CONNECTED ) {
       &commit ;
       print "SERVER :: disconnecting \n";
       ib_close_connection();
       $CONNECTED = 0 ;
    }
    else {
       print "CANNOT DISCONNECT - no connection is in place\n";
    }

}

sub commit {
    if ( $CONNECTED ) {
       &debug (1,"comitting changes");
       print "SERVER :: Comitting Changes .. ";
       ib_update_server();
       print "DONE.\n";

       $CONN_STRING = " " ;
    }
    else {
       print "CANNOT COMMIT - no connection is in place\n";
    }
}

#
# DIGS AND GET ROUTINES
#

sub get_zone {
    # use dig...
    &debug (2,"getting zone [@_]");
    my ($query,$type,$verb) = @_ ;

    if ( ! $type ) { $type = "SOA" }

    if ( ! $SERVER_ID ) {
       print "CANNOT dig - no server is specified\n";
    }
    else {
       &do_dig($SERVER_ID,$query,$type,$verb);
    }


}

sub do_dig {
    # use a 'dig' to get zone data.
    my $DIG = '/usr/bin/dig' ;
    my $DIGOPTS = '+multiline +nostat +nocmd +norecur';
    my $TERSEOPTS = '+noquestion +noauthority +noadditional +nocomments';

    my $V_DIG = "$DIG $DIGOPTS";
    my $T_DIG = "$DIG $DIGOPTS $TERSEOPTS";

    # so we pass args to dig to work out what type of dig to do
    &debug (3,"dig reqest =  [@_]");
    my ($server,$query,$type,$verbose) = @_ ;

    my $COMM ;

    if ($verbose) {
       $COMM = "$V_DIG \@$server $query $type";
    }
    else {
       $COMM = "$T_DIG \@$server $query $type";
    }

    &debug (2,"dig comm =  [$COMM]");
    print "\n";
    system("$COMM");
    print "\n";


}

############################################3

sub cidrfind {
    # match up netmasks to cidr syntax
    my ($cidr) = @_ ;
    my %mlook = (
       8 =>  '255.0.0.0' ,
       9 =>  '255.128.0.0' ,
       10 => '255.192.0.0' ,
       11 => '255.224.0.0' ,
       12 => '255.240.0.0' ,
       13 => '255.248.0.0' ,
       14 => '255.252.0.0' ,
       15 => '255.254.0.0' ,
       16 => '255.255.0.0' ,
       17 => '255.255.128.0' ,
       18 => '255.255.192.0' ,
       19 => '255.255.224.0' ,
       20 => '255.255.240.0' ,
       21 => '255.255.248.0' ,
       22 => '255.255.252.0' ,
       23 => '255.255.254.0' ,
       24 => '255.255.255.0' ,
       25 => '255.255.255.128' ,
       26 => '255.255.255.192' ,
       27 => '255.255.255.224' ,
       28 => '255.255.255.240' ,
       29 => '255.255.255.248' ,
       30 => '255.255.255.252' ,
    ) ;

    &debug(2,"CIDR is [$cidr]");
    &debug(2,"MASK is [$mlook{$cidr}]");

    return($mlook{$cidr}) ;
}

sub debug {
    # we're passed a message and a level
    # if this level is <= the CURRENT DEBUG level 
    # we print the data
    my $level = shift @_ ;

    if ($level <= $DEBUG) {
           print "DEBUG : @_\n";
    }

}

###########################################################

# $Log: ibcli,v $
# Revision 1.4  2003/09/18 02:28:56  horne
# *** empty log message ***
#
# Revision 1.3  2003/09/16 23:17:25  horne
# *** empty log message ***
#
# Revision 1.2  2003/09/09 22:58:27  horne
# *** empty log message ***
#
# Revision 1.1  2003/08/11 23:31:57  horne
# *** empty log message ***
#
# Revision 1.9  2001/06/07 16:45:47  horne
# major rewrite of the arg parser - ripped out all the RE's to a much better
# process.
# delete commands disabled
#
# Revision 1.8  2001/05/31 05:28:15  horne
# *** empty log message ***
#
# Revision 1.7  2001/05/24 00:17:54  horne
# Added RE's to handle shortened commant words, not however that this is
# still buggy, typos, as long as they are unique will still work. thus
#  - password, p , pa , ps , pdfgt = password
# I need to find a better command parser
#
# Revision 1.6  2001/05/23 19:39:11  horne
# working version - waiting for updates from infoblox to see if they have
# changed the API syntax
#
# Revision 1.5  2001/05/19 06:08:13  horne
# iblox ready version, but no connections to servers work
#
# Revision 1.4  2001/05/19 04:59:19  horne
# All base commands are being parsed and netmasks are being applied.
# Now we need to hit the infoblox engine for real
#
# Revision 1.3  2001/05/19 03:43:45  horne
# added the DEBUG option before i started to drown in a lot of messy print
# statements
#
# Revision 1.2  2001/05/19 03:34:34  horne
# Basic version, config file parsing is functional.
#
# Revision 1.1  2001/05/19 03:33:56  horne
# *** empty log message ***
#
