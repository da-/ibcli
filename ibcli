#!/usr/bin/perl
#
my $ID  = q$Id: ibcli,v 3.10 2006/07/19 15:35:59 horne Exp $ ;
my $REV = q$Revision: 3.10 $;
# $Date: 2006/07/19 15:35:59 $
#

# (c) Copyright: Geoff horne, SLC 2001-2005
#               All rights reserved
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. So there...
#
# THIS TICKET IS SOLD SUBJECT TO THE SELLERS CONDITIONS OF SALE OF COPY
# WHICH IS AVAILABLE FOR INSPECTION AT TIME OF PURCHASE AND/OR CONDITIONS
# OF THIS TICKET AND ALSO (TO THE EXTENT THAT THEY ARE NOT INCONSISTENt
# WITH THE SELLERS CONDITIONS OF SALE) THE FOLLOWING:
# 
# 1: A CHANGE IN CONDITIONS OF THE PURCHASER DOES NOT ENTITLE THE PURCHASER
#    TO RETURN OR EXCHANGE TICKET.
# 
# 2: THE SELLER RESERVES THE RIGHT TO:
#    - ADD, WITHDRAW OR SUBSTITUTE ARTISTS
#    - VARY ADVERTISED PROBRAMMES, SEATING ARRANGEMENT AND AUDIENCE
#      CAPACITY , AND:
#    - REFUSE ADMISSION WITH REASONABLE CAUSE
#
# 3: CAMERAS AND TAPE RECORDERS MAY NOT BE PERMITTED. LATE ARRIVALS MAY
#    RESULT IN NON-ADMITTANCE UNTIL A SUITABLE BREAK IN PERFORMANCE. THE
#    SELLER REQUESTS THAT ALL PAGERS AND MOBILE PHONES BE TURNED OFF BEFORE
#    ENTRY.
#
# 4: IF AN OUTDOOR PERFORMANCE IS CANCELLED DUE TO ADVERSE WEATHER OR ANy
#    OTHER CAUSE REASONABLY BEYOND THE SELLERS CONTROL, THERE IS NO RIGHT 
#    TO A REFUND OR EXCHANGE, AND THE SELLER IS NOT OBLIGED TO ARRANGE A 
#    SUBSTITUTE SERVICE, EVENT OR PERFORMANCE
#
# StreetLevel Communications
#
#            support@slc.com.au
#            ph: +1-650-483-0998
#
###############################################################################


# Perl CGI common chunks
#
use strict ;
no strict "refs" ;
no strict "subs" ;

# work out where i am
use FindBin qw($Bin $Script);
my ($BASE,$NAME)=($Bin,$Script) ;

use lib "$FindBin::Bin" ;
use lib "$FindBin::Bin/lib" ;
use lib "lib" ;

# GDH, moved to an internal routine
# use Term::EditLine qw(CC_EOF CC_REFRESH CC_REDISPLAY);

use Text::Abbrev ;
use Data::Dumper ;
use Getopt::Long;
use Infoblox;

# globals
$Data::Dumper::Sortkeys = 1 ;

### ---  GLOBAL PRE canned regexes --- ###
#
#  we can force syntax HERE by matching args to regexes
#

            # quoted comments
my $REcomm = '("([^"]+)")|(\S+)' ;
            # zones
my $REzone = '(\w|\-|\.)+';
            # a complete IP address
my $REip  = '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}';
            # a complete n.n.n.n/mm
my $REcidr = '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2}';
           # MAC address 
my $REmac  = '[\w:]+';
           # incomplete form of an IP address
           # match 'N' then praps '.N' then praps '.' or '.N'
my $REpartip = '\d{1,3}(\.\d{1,3}){0,2}(\.|\.\d{1,3})?';

# this is a hash of regexes to use for special keywords
my %SPECOPS = (
     '<mac>' => "^$REmac\$",
     '<num>' => '^\d+$',
     '<svr>' => '^\S+$',
     '<file>' => '^\S+$',
     '<name>' => '^\S+$',
     '<value>' => '^\S+$',
     '<name=value>' => '^\S+=\S+$',
     '<canonical>' => '^\S+$',
     '<comment>' => "^$REcomm\$",
     '<name,ip>' => "^$REzone,*($REpartip)*\$",
     '<ip,ip>'   => "$REpartip|,",
     '<ip>'      => "^$REpartip\$",
                     # incomple n.n.n.n/mm
     '<n.n.n.n/mm>' => "^($REpartip|$REip\\\/|$REcidr)\$",
     '<cidr>'       => "^($REpartip|$REip\\\/|$REcidr)\$",
     '</cidr>'      => '^\/\d{1,2}$',
     '<zone>'   => '^\S+$',
     '<priority>'   => '^\d+$',
   );

# Alternate words are set of a global lookup table
# [ ] GDH - no implemented
my %ALTERNATES = (
     "configure" => "set",
);

### ---  end ------------------ ###

# [ ] connected
my $ONLINE ;
my $SESSION ;
my $MASTER_IP ;

my $DEBUG = 0 ;
my $LIST_COMM = 0 ;
my $LIST_USAGE = 0 ;

my ( $S_ID , $S_PASS , $S_USER ) ;

GetOptions (
    "s=s" => \$S_ID , 
    "p=s" => \$S_PASS ,
    "u=s" => \$S_USER ,
    "h|help" => \$LIST_USAGE ,
    "t+"  => \$LIST_COMM ,
    "V|version+"    => sub { print "\n$ID\n$REV\n\n"; exit ; },
    "d=s"     => \$DEBUG,
);

if ( $LIST_USAGE ) {
      print "
Usage $NAME [-s <dns one IP> -u <user> -p <passwd>] [file.cf]
   -s <xxx>   # The name of the DNS One you are poking at
   -u <xxx>   # The username
   -p <xxx>   # That user's password
   -d N       # The debug level
   -V         # show the version #
   -t         # show the command table
   -h|help    # Print out help
    \n";

    exit ;
}

##########################################################
# now we can initialise

# set the prompt ;
my $PROMPT = 'server ? > ';

# initialise the CLI table ( have to do this first or we can't dump them )
my %COMMANDS = &init_commands ;

# initialise editline ( or not ) and return a handler

# use Term::EditLine qw(CC_EOF CC_REFRESH CC_REDISPLAY);

my $USE_EL = 0 ;

# define some constants for Editline
# ( I hope to hell these don't change because they are supposed to be
#   imported from the module )

use constant CC_REDISPLAY => 8 ;
use constant CC_REFRESH => 4 ;
use constant CC_EOF => 2 ;

# continue initialising
# my $el = &init_editline ;
my ( $USE_EL , $el ) = &init_editline ;

##########################################################

# bailout if we just want commands
if ( $LIST_COMM ) {
   foreach my $comm ( sort keys %COMMANDS ) {
      print "$comm\n";
   }
   exit ;
}

##########################################################

# otherwise - we initialise and get going
# do a connection from the git go ?
if ( $S_ID and $S_PASS and $S_USER ) {
   &cli_add_server ( "configure server $S_ID user $S_USER password $S_PASS" ) ;
}

# main loop

if ( @ARGV ) {
    # we are in batch mode

    # scrub the prompt
    $PROMPT = "" ;
    
    # read the file
    while (<> ) {

        $PROMPT = "read line $.:" ;
        # 
        # skip comments, blanks
        next if /^\s*#/;
        next if /^$/;
    
        print "$PROMPT $_";
    
        &process_line ( $_ ) ;

    }

    exit ;

}
else {

# print a startup message
print " 
#####################################################################
#
# the Infoblox CLI $REV (this is alpha code, ymmv)
#
#####################################################################

( press <tab> for help )
";

    if ( $USE_EL ) {
        # we can load the editline routines and use them
        while (defined($_ = $el->gets())) {

            # only history non-blank lines
            chomp ( my ( $in ) = $el->line ) ;
            if ( $in ) {
                    # save the line WITH the cr.
                    $el->history_enter($_);
            }

            # now do something
            chomp ;

            # cleanup the line, do something, and redraw
            # we can only do redraws on a 'return()' 
            # so everything is in a sub{}
            &process_line ( $_ ) ;

            # now flush the buffer
            $el->deletestr( length ( $in ) );
        }
    }
    else {
        # no editline (winders) go old skool
        print "Warning : Can't find Term::EditLine, feature disabled\n";
        # unbuffer IO
        $| = 1 ;
        print "$PROMPT";

        # read lines 1 per
        while(<>){

            # exit conditions etc that /were/ in editline
            if ( /^quit|q$/ ) {
                &cli_exit ;
            }
            # help
            if ( /\?\s*$/ ) {
                # so a simple substitution
                $_ = "help\n" ;
            }
            # skip comments, blanks
#             next if /^\s*#/;
#             next if /^$/;

            # snarf the line
            chomp ;
            &process_line ( $_ ) ;

            # lastly, reprompt ?
            print "$PROMPT";

        }
    }

}

#####################################################################
# perldoc goes here

=head1 NAME

The INFOBLOX CLI, a users guide

=head1 Synopsis

*A guide for commandline junkies*

=head1 Description

This is 
$Revision: 3.10 $
there were previous versions that were even worse, this one is pretty bad,
it really is beta code.  But it is a start.

So why do this, what is this CLI for ? Well there were a few primary
reasons:

=over

=item Quick changes are now easy,

You don't need to wait for a GUI to start or get the right version
of java functional, this allows you to quickly get into the database
and make some simple and efficient changes

=item Abstract command set

Now you don't need to know the intricacies of the API, a few simple
commands will achieve the same effect, if you are a user that
doesn't know PERL you can still drive the CLI and get the results
you need. This may not be an advantage if you are reading data from
another system to import into an Infoblox unit (since you still need
to write software to parse the data, eg PERL) but it may still help
and end user that can convert this data in to the CLI command set
but not know enough to write PERL.

=item Customers wanted it

    Need I say more ?

=back 

Lastly, why is this called 'ibcli' and not 'DNScli' ? Well, this is just
a wrapper to any API we like, it is not really DNS specific.


=head1 Quickstart

Simple example, adding a zone

   server ? > conf server 10.0.1.224 user admin pass infoblox
   admin@10.0.1.224 > conf zone add infoblox.com
   admin@10.0.1.224 > conf zone add sales.infoblox.com

A more detailed example

   server ? > conf server 10.0.1.224 user admin pass infoblox
   admin@10.0.1.224 > conf zone add com
   admin@10.0.1.224 > conf zone add foo.com
   admin@10.0.1.224 > conf zone foo.com add host test 1.2.3.4
   admin@10.0.1.224 > conf zone delete bar.com

A complex example, multiple connections

   server ? > conf server 10.0.1.224 user admin pass infoblox
   admin@10.0.1.224 > conf zone add sales.foo.com

   # now switch servers
   admin@10.0.1.224 > conf server 10.0.1.200 user admin1 pass infoblox1
   admin1@10.0.1.220 > conf zone add biz.foo.com

=head1 Installation

It should run 'as is' from a uniz machine. 

If you have a windows OS then you will have a few hurdles to cross:

=over

=item * Rename the script to 'ibcli.pl'. 

I still don't understand why Windows uses file suffix to type its data
rather than doing something intelligent like looking at the contents of
the file, but then, we are dealing with people who thought 8.3 was all
you'd ever need as a file namespace and 640K for ram...

=item * Make sure you have the necessary libraries installed, 

you'll need:

   o Getopt::Long

   o Text::Abbrev

   o Term::EditLine

=back

=head1 Getting started

Run the ibcli - it is a perl script, you will get a prompt

    % ./ibcli
    server ? >

Ideally, you should now connect the CLI to a server somewhere, to do
this you give it the server and a user and a password, you can do these in
either order, it just tries to eventually connect when it has enough data.

    server ? > conf server 10.0.1.224 user admin password infoblox
    admin@10.0.1.224 >

Or you can also do this from the initial invocation:

    % ./ibcli -s 10.0.1.230 -u admin -p infoblox 

"HOLD ON A SEC", I hear you ask, "Why am i connecting to a server, isn't
this CLI running on a console somewhere ?". No, Grasshopper, the CLI is
just a wrapper to the Infoblox.pm so you can run it from anywhere in
the world. This gives you the added advantage of being able to work on
MANY servers from the one CLI.

=head1 Setting the debug level

    server ? > conf debug 3
    server ? >

Or you can also do this from the initial invocation:

    % ./ibcli -d 3


=head1 Other Gritty Details

OK, so what can I do from here ?

=head2 Members and secondaries

By default all stuff is added to just the Grid Master, the API guesses
this from the SERVER setting. If you explicitly want to add stuff to
certain members you need to append the members to the command arg :

   conf zone add foo.com member 1.2.3.4
   conf zone add foo.com member 1.2.3.4 member 1.2.3.5

=head2 Laziness

The command parser accepts abbreviations

    se z a foo.com

is the same as

    conf zone add foo.com

=head2 TAB completion

The cli uses a full line editor with history and the usual bells and
whistles. command completion can be achieved by pressing <tab>

=head2 BATCH processing

You can process command in batch by just writing them to a file and
adding it to the command line thus :

   ibcli -s 10.64.128.50 -u admin -p infoblox demo.cf

=cut

########################################
# subs
########################################

sub cli_history {
    # [ ] History

#     my $hsize = ${ $el->history_get_size } ;
#     my $hobj = $el->history_get_curr ;

    print "--HISTORY not supported--\n";
}

sub print_help { 
    # [ ] contextual help
    if ( $USE_EL ) {
        my ( $context ) = $el->line ;
        chomp $context;

        print "\nhelp for [$context] TBD
 press :
    <tab> for options and word completion
    '\\' to clear the line
    'q' to quit\n\n";

        return CC_REDISPLAY ;
    }
    else {
        print "\nNo help available (Editline disabled)\n\n";
    }
};

sub print_perldoc { 
    # dumpmyself to perldoc

#     print "doc : $0 \n";
    system ( "perldoc $0 | less" );

    return CC_REDISPLAY
};

sub process_line {
    # expand the line, drop errors
    my ( $line ) = @_ ;

    # [ ] protect special chars
    $line =~ s/\*/\\\*/g;

    &debug_cli (1,"");
    my ( $expanded , $error , $matchline ) = &expand_line ( $line ) ;
    &debug_cli (2,"linec m[$matchline]");
    &debug_cli (2,"linec e[$expanded]");

    if ( $error ) {
       print "$error\n"
    }
    else {

       # now go do it
       my $func = $COMMANDS{ $matchline }{"func"} ;
       &debug_cli (2,"linec call ($func) ($expanded)");
       if ( $func ) {
          # catch undefined arrays
          if ( defined ( &$func ) ) {
             &$func ( $expanded ) ;
          }
          else {
             print " NOT implemented ($func)\n";
          }
       }
       else {
          if ( $line ) {
             my $words = $COMMANDS{ $matchline }{"words"} ;
#              print "  Incomplete : $line ($words)\n";
             # cleanup some syntaxes
             $words =~ s/=/ /g;
             print "  Incomplete : $expanded ($words)\n";
          }
       }
    }

    # may need a re-display here...
#     return CC_REDISPLAY
    return CC_REFRESH
}

sub expand_line {
    # if a user hasn't been presing <tab> we may have valid syntax that
    # still needs to be pumped through the abbreviation parser.
    # 
    # this is a tad tricky because each word needs to be walked through
    # the command tree to make sure it is in context
    #
    # but given input :
    #
    #   co z foo.com a
    #
    # we need to see that this is BOTH :
    #
    #   configure zone foo.com add  (expanded)
    #   configure zone <zone> add   (used for matching)
    # 
    # we do this by returning $expline and $matchline

    my ( $line ) = @_ ;
    &debug_cli (3,"linex input [$line]");

    # protect stuff in quotes by inserting '%20s'
    # do this for all args in the string...

    my @cargs = $line =~ /"([^"]*)"?/g;
    foreach my $ori_comment ( @cargs ) {
#         (my $new_comment = $ori_comment) =~ s/\[|\]|\(|\)/!/g;
        (my $new_comment = $ori_comment) =~ s/\[|\(/!/g;
        $new_comment =~ s/\]|\)/!!/g;

        ( my $pcomment = $new_comment ) =~ s/\s/%20s/g;
        $ori_comment =~ s/\(/\\(/g;
        $ori_comment =~ s/\)/\\)/g;
        $ori_comment =~ s/\[/\\[/g;
        $ori_comment =~ s/\]/\\]/g;
        if ($ori_comment) {
            $line =~ s/$ori_comment/$pcomment/;
        }
    }

    &debug_cli (3,"linex cinput [$line]");

    # walk each word ( split on <space> )
    my $expline ;
    my $matchline ;
    my $error ;
    foreach my $thisarg ( split ( /\s+/ , $line ) ) {

       &debug_cli (3,"linex -------");

       my $origarg  = $thisarg ;

       &debug_cli (3,"linex arg     a($thisarg)<-($origarg)");
#        &debug_cli (3,"linex partial e[$expline]");
       &debug_cli (3,"linex partial m[$matchline]");

       # hide special chars (stops us exiting)
       $thisarg =~ s/\[|\]|\(|\)/!/g;

       # we now have the short word, 
       # we have to look at the matchline to get some context
       # then we can expand the word

       # we need the contect so we know what the next word is

       my ( @words ) = get_context ( $matchline ) ;

       my ($done,$sptype,$expword,@matches) = &expand_word ($thisarg,@words) ;

       &debug_cli (3,"linex match [$done][$sptype] exp($expword)or[@matches]");
       &debug_cli (3,"linex exp   [$thisarg]->[$expword]");

       if ( $expword and @matches ) {
          # ambiguous line, drop an error, exit
          $error = "  Ambiguous : $expline(@matches)";

          # break out of the arg reading loop..
          return ( $expline , $error , $matchline) ;

       }

       elsif ( $sptype ) {
          # we're a special, record this for regex matching
          $expline .= "$expword " ;
          $matchline .= "$sptype " ;
       }

       elsif ( ! $expword ) {
          # NO MATCH, Bad word
          $expline .= "$thisarg" ;
          $matchline .= "$thisarg" ;

          # find out where the error was.. (kinda tricky)
          # the bad word will be at the end of $expanded
          ( my $good = $line ) =~ s/(.*)$thisarg.*$/$1/;

          # and unclean protected strings
          $good =~ s/%20s/ /g ;

          # and use this to put a marker at the right place
          my $slen = length ( $PROMPT) + length ( $good ) ;
          my $spc = sprintf ( "%*s^" , $slen , " " ) ;
          &debug_cli (3,"linex estrip [$thisarg] from [$good] [$spc]");

          # create the error string.
#           $error = "$spc\n  Unknown argument at '^'";
          $error = "$spc--- Unknown argument at marker";

          return ( $expline , $error , $matchline) ;
       }

       else {
          # standard word
          $expline .= "$expword" ;
          $matchline .= "$expword" ;

       }

    }

    # now clean it up
    $expline =~ s/\s+$//;
    $matchline =~ s/\s+$//;
    # and unclean comments
    $expline =~ s/%20s/ /g;
    $matchline =~ s/%20s/ /g;

    return ( $expline , $error , $matchline ) ;

}

sub lastarg {
    # given a string, determine what the last arg is.

    my ($line) = @_ ;

    # we need the last 2 words to get context 
    #  - last complete word
    #  - last incomplete word
    # this string can be any combination of :
    # ''
    # '<str>'
    # '<str> '
    # '..<str> <srt>'
    # '..<str> <srt> '

    # if there is trailing space - that is the last arg
    # if there is no trailing space, the last word is the lastarg

    # we also return the previous word, as this is useful sometimes

    &debug_cli (4,"lastarg line  l($line)");

    my ( $prearg , $lastarg ) = $line =~ /(\S+)\s+(\S+)$/ ;
    if ( $line =~ /(\S+)\s+$/ ) { $prearg = $1 , $lastarg = "" };
    if ( $line =~ /^(\S+)$/ ) { $prearg = "NULL" , $lastarg = $1 };
    if ( $line =~ /^$/ ) { $prearg = "NULL" , $lastarg = $1 };

    return ( $prearg , $lastarg ) ;

}

sub add_context {
    # shove an new context into the hash
    my  ( $context , $words , $add_func , $copyfrom ) = @_ ;

    # only create NEW structures
#     unless ( $COMMANDS{ $context }{"words"} ) {
    unless ( $COMMANDS{ $context } ) {
       $COMMANDS{ $context }{"words"} = $words ;

       # there should already be a context for $line
       # so we may choose to copy the function
       # ( we DON'T do this for things like the lhs of <word>=<var> )
       my $func = $COMMANDS{ $copyfrom }{"func"} ;
       if ( $add_func ) {
          $COMMANDS{ $context }{"func"} = $COMMANDS{ $copyfrom }{"func"} ;
       }

       &debug_cli (4,"addcon f($func) ($context) [$words]");
    }

}

sub get_context {

    # we are passed a string which SHOULD be the whole line EXCEPT for
    # THE LAST ARG, we use this to get some sort of context and the next
    # list of possible words

    my ( $line , $lastarg ) = @_ ;
    $line =~ s/\s+$//;
    &debug_cli (3,"contxt line [$line]");

    # we need to check is we're at the beginnning of the line
    if ( ! $line ) { $line = "NULL" } ;

    # the hash is $COMMANDS { "<string>" } { "words|func|help" }
    #             $COMMANDS { "<string>" } { "words" }
    #
    # Can't use an undefined value as an ARRAY reference

    # now find a matching line of context in the commend hash.
    my @words ;
    if ( $COMMANDS{"$line"}{'words'} ) {
       my $wordlist = $COMMANDS{"$line"}{'words'} ;

       # We need to clean up some of the odd syntaxes the list
       # of words, so we do neat things before creating an array

       # 'word=<var>' pair : if that's the case we have to get a
       # tad clever and dynamically add new matches to the context array.
       # this is easier that generating all permutations at compile time
       # we'll just add new contextes at run time.

       # walk the words one at a time
       foreach my $cw ( split ( /\s+/ , $wordlist ) ) {
          if ( $cw =~ /\|/ ) {
             # word|word|word :
             # add an additional context with the same arg list
             foreach my $alt ( split /\|/ , $cw ) {

                # now check for 'word=<var>|word=<var>|word' :
                if ( $alt =~ /(\S+)=(<\S+>)/ ) {
                   push ( @words , $1 ) ;
                   # add a context for lhs (with no func)
                   &add_context ( "$line $1" , $2 , 0 , 0 ) ;
                   # and the rhs with the original list
                   &add_context ( "$line $1 $2" , $wordlist , 1 , $line ) ;
                }
                else {
                   # just add the word
                   push ( @words , $alt ) ;

                   # add a context for the altword
                   &add_context ( "$line $alt" , $wordlist , 1 , $line ) ;
                }
             }
          }
          elsif ( $cw =~ /(\S+)=(<\S+>)/ ) {
             # word=<var> :
             # drop '=<var>' , add an additional context
             push ( @words , $1 ) ;

             # add a context for lhs
             &add_context ( "$line $1" , $2 , 0 , 0 ) ;
             # add a terminating context for rhs
             &add_context ( "$line $1 $2" , "<cr>" , 1 , $line ) ;
          }

          else {
             # normal word
             push ( @words , $cw ) ;
          }
          
       }

    }
    else {
       @words = ( "<cr>" ) ;
    }
    &debug_cli (4,"contxt words c(@words) ");

    return ( sort @words ) ;

}

################
# TAB completion
# This is complex in its simplicity
################

sub cmpctl {
    # completion control... called when we <tab>
    print "\n" if $DEBUG ;

    # first, we have to get the last input
    my ( $line , $icur , $ilast ) = $el->line ;
    chomp $line ;

    # Q) how do you handle a line that has been edited ?
    #    like you press <tab> before an existing word ?
    # A) you ignore it, and don't complete the word

    # now we have to expand this line and parse it
    # this seems redundant, but there may be words in the line that were
    # not previously <tab> completed. 

    my ( $expanded , $exerr , $matchline ) = &expand_line ( $line ) ;

    &debug_cli (3,"cmpctl -------");
    &debug_cli (3,"cmpctl e[$expanded]");
    &debug_cli (3,"cmpctl m[$matchline]");
    
    # [-] now - expandline may drop an error if we made a typo
    # EARLIER in the wordlist.
    # if so we should STOP and report the syntax error
    if ( $exerr =~ /unknown/i ) {
       # find out where the error was.. (kinda tricky)
       # the bad word will be at the end of $expanded

       print "\n$exerr\n";
       return CC_REDISPLAY  ;
    }

    # so we now have expanded the line, we can use this to get the
    # context (again), but we have to rip out the last arg from it

    my ( $prearg , $lastarg ) = &lastarg ($line ) ;
    &debug_cli (3,"cmpctl lastarg p($prearg) l($lastarg)");

    my $checkline = $matchline ;
    if ( $prearg eq "NULL" ) { $checkline = "NULL" }
    elsif ($lastarg ) {
       # now we so some tricky substitution
       # putting the last arg back as it was
       $checkline =~ s/\s($lastarg)\S*$/ /;

       # or cleansing special markers ( <net> etc )
       $checkline =~ s/\s<\S*>$/ /;
    }

    &debug_cli (3,"cmpctl chkline  [$checkline]");

    # we pass the last arg to get_context anyway, as we may need it
    my ( @words ) = get_context ( $checkline , $lastarg ) ;

    # then we call expand_word() which will find a match and return
    # - the expanded word (unique match)
    # - no change ( a special word )
    # - no change ( ambiguous , list of matches )
    # - nothing ( no match , list of matches )

    my ($done,$sptype,$expword,@matches) = &expand_word ($lastarg,@words) ;
    &debug_cli (3,"cmpctl match [$done][$sptype] ($expword) alt[@matches]");

    # based on this, do something useful
    if ( $expword and $done ) {
       # finish the line, add the missing charagters
       &debug_cli (3,"cmpctl uniq ($lastarg)+[$expword]");

       ( my $append = $expword ) =~ s/^$lastarg//i ;
       # BUT only do it if the cursor is in the right place
       if ( $icur = $ilast ) {
          $el->push("$append");
       }
    }
    elsif ( $expword and @matches ) {
       # print matching options
       &debug_cli (3,"cmpctl ambig ($expword) [@matches]");

       print "\n  @matches\n";
    }
    elsif ( $expword ) {
       # do nothing (NOTE, specials match AFTER uniqs )
       &debug_cli (3,"cmpctl spec ($expword) [@matches]");
    }
    # [-] i don't think we ever get here
    #     no, it gets caught by errors with expandline
    elsif ( ! $expword ) {
       # delete the string , print all options
       my $len = length ( $lastarg ) ;
       &debug_cli (3,"cmpctl cut ($expword)-[$len]");

       $el->deletestr( $len );
       print "\n  @matches\n";
    }

    # Redisplay entire input line
    return CC_REDISPLAY  ;
}

sub expand_word {
    # given an input and a list of matches, return either
    # - the bit to append word (unique match)
    # - no change ( a special word )
    # - no change ( ambiguous , list of matches )
    # - nothing ( no match )

    my ( $inword , @words ) = @_ ;

    # then force an error if there are illegal characters
    # by not making the regex match anything
    # ( this catches words like '<ip>' )
    $inword =~ s/^</!/;
#     $inword =~ s/\[|\]|\(|\)/!/;

    # we need to create a version of inword that is regex friendly
    # so special chars have to be protected
    ( my $regex = $inword ) =~ s/(\[|\]|\.|\/)/\\$1/g ;

    &debug_cli (5,"wordx arg [$inword] regex #$regex#");

    # WGDH--
    # now we do something tricky with alternates.
    # We INJECT them into the list of legal words here, if the real word
    # was legal. this lets us to the expansion.
    # THEN, if we do expand the word, we undo it later.

#     my $altreal ;
#     my $altword ;
#     foreach my $realword ( keys %ALTERNATES ) {
#         my $alt = $ALTERNATES{$realword};
# 	# if the real word is there, add an alternate
#         if ( grep ( /$realword$/ , @words ) ) {
#             push @words , $alt ;
# 	    # save these
# 	    $altreal = $realword ;
# 	    $altword = $alt ;
#         }
#     }
#     &debug_cli (4,"wordx words [@words]");
    # --WGDH--

    # generate abbreviations
    my %abbrevs = abbrev ( @words ) ;
    # if this is an abbrev of a word...
    my $expword = $abbrevs{ lc($inword) } ;
    my @matches ;
    my $completed = 0 ;
    my $spectype ;

    if ( $expword ) {

       # we have a match, stop here, append a <spc>
       $expword .= " ";
       &debug_cli (4,"wordx uniq ($inword) -> [$expword]");
       $completed = 1 ;
    }
    else {

       # no match , resolve ambiguities
       @matches = sort grep ( /^$regex/ , @words ) ;
       my @specials = sort grep ( /^</ , @words ) ;

       if ( @matches ) {
          # we have an abiguous word (or a blank)
          &debug_cli (4,"wordx ambig ($inword) [@matches]+[@specials]");
          $expword = $inword ;

          if ( $regex ) { @matches = ( @specials , @matches ) ; }
       }
       else {
          # no match, catch special strings or remove the bad word

          my $havespecial ;
          foreach my $smatch ( sort keys %SPECOPS ) {
             # if the special is valid in this context
             # and it has the right regex, ...

             # we lookup the regex to use based on the keyword
             my $regex = $SPECOPS{$smatch};
             &debug_cli (5,"wordx spe regex ($smatch) ( $regex ) ");

             if ( grep ( /$smatch/ , @words ) and $inword =~ /$regex/ ) {
                # delete nothing
                &debug_cli (4,"wordx is spe ($smatch) [$inword]");
                $expword = $inword ;
                $havespecial ++ ;
                $spectype = $smatch ;
             }
          }

          unless ( $havespecial ) {

             # scrub the word
             $expword = "" ;
             &debug_cli (4,"wordx cut [$inword] -> ($expword)");
             @matches = sort @words ;

          }

       }

    }

    # WGDH--
    # now we UNDO the alternate words by substuting it back
    # and we have to match on the expansion

#     if ( $expword =~ /^$altword/ ) {
#         # do these in the right order...
#         $expword =~ s/$altword/$altreal/;
# 
#         &debug_cli (4,"wordx alt ($inword)->[$expword]");
#     }

    # --WGDH

    # return the results
    &debug_cli (4,"wordx word  ($inword)->[$expword]");
    return ( $completed , $spectype , $expword , @matches ) ;
}

###########################################
#
# call an infoblox function, ONLY if we're connected
#

sub do_func {

    # assume we are passed a single object
    #
    my ( $method , @data ) = @_ ;
#     &debug_cli(1,"do_func ($method)");

    # [ ] format the data for pretty printing
    if ( $DEBUG >= 2 ) {
        &debug_cli (3,"obj in -----------");
        print Dumper ( \@data ) ;
    }

    my @ret_objects ;

       # actually try and run it
       if ( $ONLINE ) {

          # call by indirection
          @ret_objects = $SESSION->$method ( @data ) ;

          print Dumper ( \@ret_objects ) if $DEBUG >= 2 ;

          # get errors
          my $result = $SESSION->status_code();
          my $response = $SESSION->status_detail();

          if ( $result > 0 ) {
             # We got error...
             print "  Error : $response ($result)\n";
          }
       }
       else {
          print "  CANNOT EXECUTE - no connection is in place\n";
       }

    return ( @ret_objects ) ;
}


###########################################
#
# actual API calling functions.
#
###########################################

=head1 GENERAL COMMAND REFERENCE

The syntax mostly matches the API syntax. Also, since this is based on
the API (duh) the same restrictions about required arguments applies.
Don't expect the cli to work around requiring dumb extra arguments. When
you look deep into the API you realise why they are there.

=cut

=head2 Add a Zone

Zones can be added as either forward or reverse. If you add a zone of the
form n.n.n.n/mm it will assume it is a reverse zone

Add a forward zone

   conf zone add foo.com

Add a reverse zone

   conf zone add 10.0.1.0/24

Add a zone to specific members

   conf zone add foo.com primary 1.2.3.4 secondary 1.2.3.5 sec 1.2.3.6

Add a zone with external primary

   conf zone add foo.com ext_primary ns1.foo.com,1.2.3.4 

Add a zone with an nsgroup

   conf zone add foo.com nsgroup mygroup

=head2 Import a zone

Zones can be imported as either forward or reverse. You just add an extra
argument of the import source

Import a forward zone

   conf zone add foo.com import 45.0.1.220

Import a reverse zone

   conf zone add 10.0.1.0/24 import 45.0.1.220

=cut

sub cli_add_zone {

    # [ ] modify zone
    # [ ] add nameserver
    # [ ] remove nameserver

    # essentially all options are passed as name value pairs
    # 
    my ( $line ) = @_ ;

    # get the args from the line
    my ($zone)     = $line =~/zone add (\S+)/ ;
    my ($import)   = $line =~/ import (\S+)/ ;
    my ($pri)      = $line =~/ primary (\S+)/ ;
    my ($nsgroup)  = $line =~/ nsgroup (\S+)/ ;
    my ($email)    = $line =~/ email (\S+)/ ;

    my (@ext_pri) = $line =~/ ext_primary (\S+)/g ;
    my (@forwarders) = $line =~/ forward_to (\S+)/g ;
    my (@sec)     = $line =~/ secondary (\S+)/g ;
    my (@mems)     = $line =~/ member (\S+)/g ;
    my (@ext_sec) = $line =~/ ext_secondary (\S+)/g ;
    my (@stealth_ext_sec) = $line =~/ stealth_ext_secondary (\S+)/g ;
    my (@views) = $line =~/ view (\S+)/g ;

    &debug_cli (1,"addz z($zone) i($import) p($pri) ep(@ext_pri) s(@sec) es(@ext_sec)");

    # create the zone...
    my $obj = Infoblox::DNS::Zone->new ( "name" => $zone, );


    # find a member to be the primary (external or otherwise)
    # or is it a forward zone...
    if ( @forwarders ) {

       # external primaries
       my @fwd_svrs ;
       foreach my $fwd_ip ( @forwarders ) {
          push @fwd_svrs , Infoblox::DNS::Nameserver->new(
                             "ipv4addr" => $fwd_ip ,
                             );

          &debug_cli (2,"addz z($zone) fwd($fwd_ip)");
       }

       $obj->forward_to( \@fwd_svrs ) ;
       # [ ] and add the right members...

        # find secondaries
        my @memlist ;
        foreach my $mem ( @mems ) {
            # normaal members
            push @memlist , Infoblox::DNS::Member->new(
#                              "name" => $value ,
                             "ipv4addr" => $mem ,
                             );
            &debug_cli (2,"addz z($zone) mem($mem)");
        }
        $obj->members ( \@memlist ) ;


    }
    # using ns groups ?
    elsif ( $nsgroup ) {
       $obj->ns_group( $nsgroup ) ;
    }
    # or normal nameservers ?
    else {
    if ( $pri ) {
       # member primary
       my $pri_ns = Infoblox::DNS::Member->new ( 'ipv4addr' => $pri, );
       $obj->primary( $pri_ns ) ;

       &debug_cli (2,"addz z($zone) mem-p($pri)");
    }
    elsif ( @ext_pri ) {
       # external primaries
       my @ext_svrs ;
       foreach my $external ( @ext_pri ) {
          # we override with an external primary
          my ( $nsname , $ip ) = split ( /,/ , $external ) ;

          &debug_cli (2,"addz z($zone) ext-p($nsname)($ip)");
          my $primary = Infoblox::DNS::Nameserver->new ( 
                     'name' => $nsname, 
                     'ipv4addr' => $ip, 
                      );

          push @ext_svrs , $primary ;
       }

       $obj->primary( \@ext_svrs ) ;

    }
    elsif ( $MASTER_IP ) {
       # use the server as the primary
       my $pri_ns = Infoblox::DNS::Member->new ( 'ipv4addr' => $MASTER_IP, );

       $obj->primary( $pri_ns ) ;
       &debug_cli (2,"addz z($zone) mas-p($MASTER_IP)");
    }

    # find secondaries
    my @sec_svrs ;

    foreach my $sec_ip ( @sec ) {
       # normaal members
       push @sec_svrs , Infoblox::DNS::Member->new(
#                              "name" => $value ,
                             "ipv4addr" => $sec_ip ,
                             );
       &debug_cli (2,"addz z($zone) sec($sec_ip)");
    }

    # external secondaries
    foreach my $ext_ip ( @ext_sec ) {
       # external secondaries
       my ( $nsname , $ip ) = split ( /,/ , $ext_ip ) ;

       # IP is optional (kinda)
       if ( ! $ip ) { $ip = "255.255.255.255" }

       my $secondary = Infoblox::DNS::Nameserver->new ( 
                        'name' => $nsname, 
                        'ipv4addr' => $ip, 
                      );

       push @sec_svrs , $secondary ;
       &debug_cli (2,"addz z($zone) ext-s($nsname)($ip)");
    }

    # stealth external secondaries
    foreach my $sext_ip ( @stealth_ext_sec ) {
       # external secondaries
       my ( $nsname , $ip ) = split ( /,/ , $sext_ip ) ;

       # IP is optional (kinda)
       if ( ! $ip ) { $ip = "255.255.255.255" }

       my $secondary = Infoblox::DNS::Nameserver->new ( 
                        'name' => $nsname, 
                        'ipv4addr' => $ip, 
                        'stealth' => "TRUE" ,
                      );

       push @sec_svrs , $secondary ;
       &debug_cli (2,"addz z($zone) s-ext-s($nsname)($ip)");
    }

    # add any secondaries we found parsing the args
     
    $obj->secondaries ( \@sec_svrs ) ;

    # do we import ?
    if ( $import ) {
       $obj->import_from ( $import ) ;
       &debug_cli (2,"addz z($zone) imp($import)");
    }
    } # not a forward ?

    # do we add it to a view ?
    my @view_objs ;
    foreach my $vname ( @views ) {
        my $view = Infoblox::DNS::View->new ( "name" => $vname );
        push @view_objs , $view ;
    }
    $obj->views ( \@view_objs ) ;

    # email
    if ( $email ) {
       $obj->email ( $email ) ;
       &debug_cli (2,"addz z($zone) email($email)");
    }

    # now add the damn thing
    &do_func("add",$obj);

}

=head2 Remove a zone

Forward or reverse, the syntax follows the same logic as add zone

Remove a forward zone

   conf zone del foo.com

Remove a reverse zone

   conf zone del 10.0.1.0/24

=cut

sub cli_delete_zone {
    my ( $line ) = @_ ;

    # get the args from the line
    ( my $zone)     = $line =~/zone delete (\S+)/ ;
    &debug_cli(1,"remz n($zone)");

    my $obj = Infoblox::DNS::Zone->new (
                  "name" => $zone,
    );

    &do_func("remove",$obj);

}

=head2 Add a host to a zone

   conf zone foo.com add host test 1.2.3.4

   conf zone foo.com add host test 1.2.3.4 comment "this is a comment"

=cut

sub cli_add_host {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host , $ip ) = $line =~/add host (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    $host =~ s/"//g;
    my $name ;
    if ( $host ) { $name = "$host.$zone"; }
    else { $name = $zone }

    my @ips = split(',', $ip) ;

    &debug_cli(1,"addh n($name) n($ip) c($comment)");

    # create the object
    my $obj = Infoblox::DNS::Host->new (
                  "name" => $name,
#                   "ipv4addrs" => [ $ip ],
                  "ipv4addrs" => \@ips,
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a host from a zone

   conf zone foo.com delete host test

=cut

sub cli_del_host {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host ) = $line =~/host (\S+)/ ;

    my $name="$host.$zone";

    &debug_cli(1,"delh n($host.$zone) ");

    # create the object
    my $obj = Infoblox::DNS::Host->new (
                  "name" => "$host.$zone",
    );

    # addit
    &do_func("remove",$obj);

}

=head2 Add an A record to a zone

   conf zone foo.com add A test 1.2.3.4

=cut

sub cli_add_a_rec {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host , $ip ) = $line =~/ a_record (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    my $obj = Infoblox::DNS::Record::A->new (
                  "name" => "$host.$zone",
                  "ipv4addr" => "$ip",
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    &debug_cli(1,"add_a n($host) n($ip) c($comment)");

    # addit
    &do_func("add",$obj);

}

=head2 Remove An A record from a zone

   conf zone foo.com delete A test 1.2.3.4

=cut

sub cli_del_a_rec {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host , $ip ) = $line =~/ a_record (\S+) (\S+)/ ;

    my $obj = Infoblox::DNS::Record::A->new (
                  "name" => "$host.$zone",
                  "ipv4addr" => "$ip",
    );

    &debug_cli(1,"del_a n($host) n($ip) ");

    # addit
    &do_func("remove",$obj);

}

=head2 Add an MX record to a zone

   conf zone foo.com add mx mail 10 mail.bar.com

=cut

sub cli_add_mx {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host , $pref , $dest ) = $line =~/ mx (\S+) (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    $host =~ s/"//g;
    if ( $host ) { $host = "$host.$zone"; }
    else { $host = $zone }

    my $obj = Infoblox::DNS::Record::MX->new (
                    "name" => "$host",
                    "pref" => $pref ,
                    "exchanger" => $dest ,
                    "comment" => $comment,
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    &debug_cli(1,"add_mx n($host) n($pref) c($comment)");

    # addit
    &do_func("add",$obj);

}

=head2 Remove An MX record from a zone

   conf zone foo.com del mx mail 10 mail.bar.com

=cut

sub cli_del_mx {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $host , $pref , $dest ) = $line =~/ mx (\S+) (\S+) (\S+)/ ;

    my $obj = Infoblox::DNS::Record::MX->new (
                    "name" => "$host.$zone",
                    "pref" => $pref ,
                    "exchanger" => $dest ,
    );

    &debug_cli(1,"del_mx n($host) n($pref) ");

    # addit
    &do_func("remove",$obj);

}

=head2 Add a bulk host to a zone

   conf zone foo.com add bulkhost my_prefix 1.2.3.10 1.2.3.20

   conf zone foo.com add bulkhost my_prefix 1.2.3.10 1.2.3.20 comment "bah"

=cut

sub cli_add_bulk {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $prefix , $fip , $lip ) = $line =~/ bulkhost (\S+) (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    &debug_cli(1,"addbh z($zone) p($prefix) n($fip,$lip) c($comment)");

    my $obj = Infoblox::DNS::BulkHost->new (
                   "zone" => $zone ,
                   "prefix" => $prefix ,
                   "start_addr" => $fip ,
                   "end_addr" => $lip ,
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a bulk host from a zone

   conf zone foo.com del bulkhost my_prefix 1.2.3.10 1.2.3.20

=cut

sub cli_del_bulk {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $prefix , $fip , $lip ) = $line =~/ bulkhost (\S+) (\S+) (\S+)/ ;

    &debug_cli(1,"delbh z($zone) p($prefix) n($fip,$lip) ");

    my $obj = Infoblox::DNS::BulkHost->new (
                   "zone" => $zone ,
                   "prefix" => $prefix ,
                   "start_addr" => $fip ,
                   "end_addr" => $lip ,
      );

    # addit
    &do_func("remove",$obj);

}

=head2 Add a CNAME to a zone

   conf zone foo.com add CNAME alias real.foo.com

=cut

sub cli_add_cname {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $alias , $cname ) = $line =~/ cname (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    &debug_cli(1,"addcn z($zone) a($alias) cn($cname) c($comment)");

    my $obj = Infoblox::DNS::Record::CNAME->new (
                  "name" => "$alias.$zone",
                  "canonical" => "$cname",
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a CNAME from a zone

   conf zone foo.com delete CNAME alias

=cut

sub cli_del_cname {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $alias , $cname ) = $line =~/ cname (\S+) (\S+)/ ;

    &debug_cli(1,"delcn z($zone) n($alias) cn($cname)");

    my $obj = Infoblox::DNS::Record::CNAME->new (
                  "name" => "$alias.$zone",
                  "canonical" => "$cname",
    );

    # addit
    &do_func("remove",$obj);

}

=head2 Add a PTR to a zone

   conf zone 10.0.0.0/24 add PTR 10.0.0.20 ns2.foo.com

Add a PTR with comments

   conf zone 10.0.0.0/24 add PTR 10.0.0.20 ns2.foo.com comment "string"

=cut

sub cli_add_ptr {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $ip , $host ) = $line =~/ ptr_record (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/comment "?([^"]+)"?/ ;

    &debug_cli(1,"addptr n($zone) ip($ip) h($host) c($comment)");

    my $obj = Infoblox::DNS::Record::PTR->new (
                  "ipv4addr" => $ip ,
                  "ptrdname" => "$host",
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # addit
    &do_func("add",$obj);

}

=head2 Remove a PTR from a zone

   conf zone 10.0.0.0/24 del PTR 10.0.0.20 ns2.foo.com

=cut

sub cli_del_ptr {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $zone )     = $line =~/zone (\S+)/ ;
    my ( $ip , $host ) = $line =~/ ptr_record (\S+) (\S+)/ ;

    &debug_cli(1,"delptr n($zone) ip($ip) h($host)");

    my $obj = Infoblox::DNS::Record::PTR->new (
                  "ipv4addr" => $ip ,
                  "ptrdname" => "$host",
    );

    # addit
    &do_func("remove",$obj);

}

=head2 Add a network

   conf network add 1.1.1.0/24

Add a network witwith a reverse zone

   conf network add 1.1.1.0/24 addreverse

Add a network with members

   conf network add 1.1.1.0/24 member 10.1.1.20,10.1.1.40

Add a network with options

   conf network add 1.1.1.0/24 option 82,"some data"

Add a network with comments (comments must come last)

   conf network add 1.1.1.0/24 comment "comment string"

=cut

# direct options :
# [-] lease_time , domain_name , etc etc
# let the serverside handle this or i will end up hardcoding keywords
# in too many places

sub cli_add_network {
    # essentially all options are passed as name value pairs
    # 
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network add (\S+)/ ;
    my ( $parent )  = $line =~/ parent (\S+)/ ;
    my ( $comment ) = $line =~/ comment "?([^"]+)"?/ ;
    my ( $addrev ) = $line =~/ (addreverse)/ ;

    my @options  = $line =~/ option (\S+)/g ;
    my @members  = $line =~/ member (\S+)/g ;

    # rewrite the comment
    $comment =~ s/\!\!/\)/g;
    $comment =~ s/\!/\(/g;

    &debug_cli (1,"addnet n($network) p($parent) m(@members) o(@options) c($comment)");

    # create the network object :

    my $net = Infoblox::DHCP::Network->new (
                   "network" => $network ,
                   "comment" => $comment ,
                   "network_container" => $parent ,
                   "auto_create_reversezone" => "FALSE"
                );

    # auto create reverses ?
    if ( $addrev ) {
        $net->auto_create_reversezone ( "TRUE" );
    }

    # members :
    if ( @members ) {
       my @memsvrs ;
       foreach my $memval ( @members ) {
          # split on ',' get all the IPs
          &debug_cli(2,"addnet mem($memval)");
          push @memsvrs, Infoblox::DHCP::Member->new("ipv4addr"=>$memval);
       }
       # and add them to the object
       $net->members ( \@memsvrs ) ;
    }
    elsif ( $MASTER_IP ) {
       # just add the grid master
       &debug_cli(2,"addnet mem($MASTER_IP)");
       my $DHMASTER = Infoblox::DHCP::Member->new ('ipv4addr' => $MASTER_IP);
#        my @memsvrs = ( $DHMASTER ) ;
#        $net->members ( \@memsvrs ) ;
       $net->members ( [ $DHMASTER ] ) ;
    }

    # options
    if ( @options ) {

       my @opt_list ;
       foreach my $optval ( @options ) {
          # set some custom options;
          # split on the ','
          my ( $opt , $val ) = $optval =~  /^(.*?)=(.*)/ ;
   
          &debug_cli(2,"addnet o($opt) v($val)");
   
          my ($opt_obj,$key)=make_dhcp_option($DEBUG,$opt,$val) ;

          # only add options we recognise
          if ( $opt_obj ) {
            push @opt_list , $opt_obj ;
          }

       }

       $net->options ( \@opt_list ) ;

    }

    # add the network 
    &do_func("add",$net);

}

=head2 Remove a network

   conf network del 1.1.1.0/24

=cut

sub cli_delete_network {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network delete (\S+)/ ;

    &debug_cli(1,"delnet n($network)");

    my $net = Infoblox::DHCP::Network->new (
                   "network" => $network ,
                );

    &do_func("remove",$net);

}

=head2 Add a shared network

   conf network add shared my_shared child_network 1.1.1.0/24 child 1.1.2.0/24

Add a network with options

   conf network add shared foo option 82,"some data"

Add a network with comments (comments must come last)

   conf network add shared comment "comment string"

=cut

# direct options :
# [-] lease_time , domain_name , etc etc
# let the serverside handle this or i will end up hardcoding keywords
# in too many places

sub cli_add_shared {
    # essentially all options are passed as name value pairs
    # 
    my ( $line ) = @_ ;

    print "AS[$line]\n";

    # get the args from the line
    # the shared network name could be quoted and have spaces
    # what we have to do here is some nested matches from $REcomm
    $line =~/ add shared ($REcomm)/ ;
    my $name = $+ ;

    $line =~/ comment "?([^"]+)"?/ ;
    my $comment = $+ ;

    my @children  = $line =~/ child_network (\S+)/g ;
    my @options  = $line =~/ option (\S+)/g ;

    # members are assigned at the network level
#     my @members  = $line =~/ member (\S+)/g ;

    &debug_cli (1,"addsha s($name) n(@children) o(@options) c($comment)");

    # children :
    my @netlist ;
    if ( @children ) {
       foreach my $net ( @children ) {
          # split on ',' get all the IPs
          &debug_cli(2,"addsha chi($net)");
          push @netlist, Infoblox::DHCP::Network->new("network"=>$net);
       }
       # and add them to the object
#        $net->networks ( \@netlist ) ;
    }

    # create the network object :
    my $net = Infoblox::DHCP::SharedNetwork->new (
                   "name" => $name ,
                   "comment" => $comment ,
                   "networks" => \@netlist ,
                );

    # options
    if ( @options ) {

       my @opt_list ;
       foreach my $optval ( @options ) {
          # set some custom options;
          # split on the '='
          my ( $opt , $val ) = $optval =~  /^(.*?)=(.*)/ ;
   
          &debug_cli(2,"addnet o($opt) v($val)");
   
          my ($opt_obj,$key)=make_dhcp_option($DEBUG,$opt,$val) ;

          # only add options we recognise
          if ( $opt_obj ) {
            push @opt_list , $opt_obj ;
          }

       }

       $net->options ( \@opt_list ) ;

    }

    # add the network 
    &do_func("add",$net);

}

=head2 Remove a shared network

   conf network del shared my_shared

=cut

sub cli_delete_shared {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $name ) = $line =~/ delete shared (\S+)/ ;

    &debug_cli(1,"delsha n($name)");

    my $net = Infoblox::DHCP::sharedNetwork->new (
                   "name" => $name ,
                );

    &do_func("remove",$net);

}

=head2 Split a network

You need to specify the netmaks of the children networks when you are
doing a split. So to split a /16 into /20 networks :

   conf network 1.1.0.0/16 split /24

Split a network and add all children

   conf network 1.1.0.0/16 split /24 all

=cut

sub cli_split_network {
    #
    # splitting either creates ALL networks or only the ones
    # we have to have (which could be none)

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $ncidr ) = $line =~/ split \/(\S+)/ ;
    my ( $type )  = $line =~/ split \/\S+ (\S+)/ ;

    &debug_cli(2,"splitnet n($network) s($ncidr) t($type)");

    # create the split object
    my $obj = Infoblox::DHCP::SplitNetwork->new (
                   "network" => $network ,
                   "prefix" => $ncidr ,
                );

    # check the type
    if ( $type eq "required" ) { 
       $obj->add_all_subnetworks ( "false" ) ;
    }
    if ( $type eq "all" ) { 
       $obj->add_all_subnetworks ( "true" ) ;
    }

    &do_func("add",$obj);

}

=head2

When you split a network and want to add children you just add them to
the parent network. All other options are the same as for adding networks

   conf network 1.1.0.0/16 add 1.1.4.0/22 

=cut

sub cli_add_sub_network {
    my ( $line ) = @_ ;

    # we hack this by change the arg list to the correct syntax
    # and just calling cli_add_network
    

    my ( $par , $sub ) = $line =~/ network (\S+) add network (\S+)/ ;


    $line =~ s/ network $par add network $sub/ network add $sub parent $par/;

    &debug_cli(2,"addsn pn($par) cn($sub)");
    &debug_cli(2,"addsn l[$line]");

    &cli_add_network ( $line ) ;

}

=head2 Add a fixed address

   conf network 10.0.1.0/24 add fixed 10.0.1.4 aa:bb:cc:11:22:33 

Add a fixed address with comments

   conf net 10.0.1.0/24 add fixed 10.0.1042 aa:bb:cc:11:22:33 "comment string"

=cut

sub cli_add_fixed_address {
    my ( $line ) = @_ ;

    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $ip , $mac ) = $line =~/ add fixed (\S+) (\S+)/ ;
    my ( $comment ) = $line =~/ comment "?([^"]+)"?/ ;
    my @options  = $line =~/ option (\S+)/g ;

    &debug_cli(1,"addfix n($network) ip($ip) mac($mac) o(@options) c($comment)");

    my $obj = Infoblox::DHCP::FixedAddr->new (
                  "network" => $network ,
                  "ipv4addr" => $ip ,
                  "mac" => $mac ,
    );

    if ( $comment ) { $obj->comment ( $comment ) }

    # options
    if ( @options ) {

       my @opt_list ;
       foreach my $optval ( @options ) {
          # set some custom options;
          # split on the ','
          my ( $opt , $val ) = $optval =~  /^(.*?)=(.*)/ ;
   
          &debug_cli(2,"addfix o($opt) v($val)");
   
          my ($opt_obj,$key)=make_dhcp_option($DEBUG,$opt,$val) ;

          # only add options we recognise
          if ( $opt_obj ) {
            push @opt_list , $opt_obj ;
          }

       }

       $obj->options ( \@opt_list ) ;

    }
    
    
    # addit
    &do_func("add",$obj);

}

=head2 Remove a fixed address

For some clever reason, you don't really need to specify the parent
network to remove a fixed address, but we enforct it here to keep people
sane (In reality, any bogus string for the network name will work)

   conf network 10.0.1.0 delete fixed 1.2.3.4

=cut

# [ ] remove fixed does not work
sub cli_del_fixed_address {
    my ( $line ) = @_ ;

    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $ip ) = $line =~/ fixed (\S+)/ ;
    my ( $mac ) = $line =~/ fixed \S+ (\S+)/ ;

    &debug_cli(2,"delfix ip($ip) mac($mac)");

    my $obj = Infoblox::DHCP::FixedAddr->new (
                  "network" => $network ,
                  "ipv4addr" => $ip ,
                  "mac" => $mac ,
    );

    # addit
    &do_func("remove",$obj);

}

=head2 Add a dhcp range to a network

Dhcp ranges, by default, will get added to the Grid master unless you
override that setting with the 'member <ip>' syntax

   conf network 10.1.1.1/24 add range 10.1.1.20 10.1.1.40

Failover associations are an additional argument

   conf net 10.1.1.1/24 add range 10... failover "my_peering"

As are adding the member 

   conf net 10.1.1.1/24 add range 10... member 1.1.1.2

You can also add exclusions

   conf net 10.1.1.1/24 add range 10... exclude 1.1.1.2,1.1.2.5

=cut

sub cli_add_dhcp_range {
    # essentially all options are passed as name value pairs
    # 
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $fip , $lip )  = $line =~/ add range (\S+) (\S+)/ ;
    my ( $failover )  = $line =~/ failover (\S+)/ ;
    my ( $member )  = $line =~/ member (\S+)/ ;
    my ( $comment ) = $line =~/ comment "?([^"]+)"?/ ;

    # [ ] exclusions
    my @exclude  = $line =~/ exclude (\S+)/g ;
    my @options  = $line =~/ option (\S+)/g ;

    &debug_cli (1,"addrng n($network) s($fip) e($lip) o(@options)");
    &debug_cli (1,"addrng n($network) m($member) c($comment) f($failover)");
    &debug_cli (1,"addrng n($network) e(@exclude)");

    # create the object
    my $obj = Infoblox::DHCP::Range->new (
                   "network" => $network ,
                   "start_addr" => $fip ,
                   "end_addr" => $lip ,
#                    "comment" => $comment ,
#                    "options" => \@opt_list ,
#                    "member" => $member ,
                );

    # add the optional extras
    if ( $comment ) { $obj->comment ( $comment ) }

    # you can't assign failover and members, you have to choose one.
    if ( $failover ) { 
         $obj->failover_assoc ( $failover ) 
    }
    else {
       # find a member to put this range on
       if ( $member ) {
          # not the grid master
          &debug_cli(2,"addrng mem($member)");
          my $memobj = Infoblox::DHCP::Member->new("ipv4addr"=>$member);
          $obj->member ( $memobj ) ;
       }
       elsif ( $MASTER_IP ) {
          &debug_cli(2,"addrng mem($MASTER_IP)");
          my $DHMASTER = Infoblox::DHCP::Member->new ('ipv4addr'=>$MASTER_IP);
          $obj->member ( $DHMASTER ) ;
       }
    }

    # exclusions
    if ( @exclude ) {

       my @exc_list ;
       foreach my $excval ( @exclude ) {
          # set some custom options;
          # split on the ','
          my ( $efip , $elip ) = $excval =~  /^(.*?),(.*)/ ;
   
          &debug_cli(2,"addrng e($efip) v($elip)");
   
          my $exc_obj = Infoblox::DHCP::ExclusionRange->new(
                            start_address => $efip,
                            end_address => $elip,
                            );

          push @exc_list , $exc_obj ;
       }

       $obj->exclude ( \@exc_list ) ;

    }


    # options
    if ( @options ) {

       my @opt_list ;
       foreach my $optval ( @options ) {
          # set some custom options;
          # split on the ','
          my ( $opt , $val ) = $optval =~  /^(.*?),(.*)/ ;
   
          &debug_cli(2,"addrng o($opt) v($val)");
   
          my ($opt_obj,$key)=make_dhcp_option($DEBUG,$opt,$val) ;
          push @opt_list , $opt_obj ;
       }

       $obj->options ( \@opt_list ) ;

    }

    # add the range
    &do_func("add",$obj);

}

=head2 Remove a dhcp range

   conf net 1.1.1.1/24 delete range 1.1.1.20 1.1.1.40

=cut

sub cli_del_dhcp_range {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $network ) = $line =~/ network (\S+)/ ;
    my ( $fip , $lip )  = $line =~/ range (\S+) (\S+)/ ;

    &debug_cli (1,"delrng n($network) s($fip) e($lip)");

    my $obj = Infoblox::DHCP::Range->new (
                   "network" => $network ,
                   "start_addr" => $fip ,
                   "end_addr" => $lip ,
                );

    &do_func("remove",$obj);

}

=head2 Add a DHCP filter

Filters can take many forms, so you need to be specific

    conf network add macfilter my_filter

=cut

sub cli_add_macfilter {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $name ) = $line =~/ macfilter (\S+)/ ;

    &debug_cli (1,"addmfil n($name)");

    #[ ] what about vendor prefix ?
    my $obj = Infoblox::DHCP::Filter::MAC->new (
                   "name" => $name ,
                );

    &do_func("add",$obj);

}


=head2 Remove a DHCP filter

    conf network del macfilter my_filter

=cut

sub cli_del_macfilter {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $name ) = $line =~/ macfilter (\S+)/ ;

    &debug_cli (1,"delmfil n($name)");

    #[ ] what about vendor prefix ?
    my $obj = Infoblox::DHCP::Filter::MAC->new (
                   "name" => $name ,
                );

    &do_func("remove",$obj);

}

=head2 Add a mac address to a filter

    conf network filter my_filter add macaddress aa:bb:cc:11:22:33

Add a mac address to a filter with comments

    conf network filter my_filter add mac aa:bb:cc:11:22:33 comment "my comment"

=cut

sub cli_add_macfilteraddr {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $name ) = $line =~/ filter (\S+)/ ;
    my ( $mac ) = $line =~/ macaddress (\S+)/ ;
    my ( $comment ) = $line =~/ comment "?([^"]+)"?/ ;

    &debug_cli (1,"addmaddr f($name) m($mac) c($comment)");

    my $obj = Infoblox::DHCP::MAC->new (
                   "filter" => $name ,
                   "mac" => $mac ,
                   "comment" => $comment ,
                );

    &do_func("add",$obj);

}

=head2 remove a mac address from a filter

    conf network filter my_filter delete macaddress aa:bb:cc:11:22:33

=cut

sub cli_del_macfilteraddr {
    my ( $line ) = @_ ;

    # get the args from the line
    my ( $name ) = $line =~/ filter (\S+)/ ;
    my ( $mac ) = $line =~/ macaddress (\S+)/ ;

    &debug_cli (1,"delmaddr f($name) m($mac)");

    my $obj = Infoblox::DHCP::MAC->new (
                   "filter" => $name ,
                   "mac" => $mac ,
                );

    &do_func("remove",$obj);

}

# global grid settings

=head2 Show global Grid settings

   show grid Infoblox

=cut


sub cli_show_grid {

    my ( $line ) = @_ ;
    # get the args from the line
    ( my $gridname)  = $line =~/show grid (\S+)/ ;

    my ( $show_mems , $member ) = $line =~/(member) (\S+)/ ;

    # do we need to get members ?

    # else get the grid
    my %opthash = (
          "object" => "Infoblox::Cluster",
          "name" => $gridname ,
    );
    my ( $grid ) = &do_func("get", %opthash );

    if ( $grid ) {
        &dump_object ( $grid ) ;
    }

}

=head2 configure global Grid settings

Add or remove access methods

   conf grid <name> add remote_console_access
   conf grid <name> delete  remote_console_access
   conf grid <name> add support_access
   conf grid <name> add lcd_input

Modify some basic grid values

   configure grid Infoblox modify grid_name My_Grid

   configure grid Infoblox modify vpn_port 1194
   configure grid Infoblox modify shared_secret test
   configure grid Infoblox modify session_timeout 14400

Add ntp servers ( and enable NTP at the same time )

   configure grid Infoblox add ntp_server 1.1.1.1 ntp_server 2.2.2.2

Disable the NTP service

   configure grid Infoblox disable ntp

=cut


sub cli_mod_grid {

    my ( $line ) = @_ ;
    # get the args from the line
    ( my $gridname)  = $line =~/configure grid (\S+)/ ;

    ( my $timeout)  = $line =~/session_timeout (\S+)/ ;
    ( my $vpn_port)  = $line =~/vpn_port (\S+)/ ;
    ( my $secret)  = $line =~/shared_secret (\S+)/ ;
    ( my $newname)  = $line =~/grid_name (\S+)/ ;

    my (@ntp_servers) = $line =~/ ntp_server (\S+)/g ;

    # find some booleans
    my $rem_access ;
    my $supp_access ;
    my $lcd_input ;
    my $use_ntp ;
    $line =~/add remote_console_access/ and $rem_access = "TRUE" ;
    $line =~/add support_access/ and $supp_access = "TRUE" ;
    $line =~/add lcd_input/ and $lcd_input = "TRUE" ;
    $line =~/delete remote_console_access/ and $rem_access = "FALSE" ;
    $line =~/delete support_access/ and $supp_access = "FALSE" ;
    $line =~/delete lcd_input/ and $lcd_input = "FALSE" ;

    $line =~/enable ntp$/ and $use_ntp = "TRUE" ;
    $line =~/disable ntp$/ and $use_ntp = "FALSE" ;

    # first get the grid
    my %opthash = (
          "object" => "Infoblox::Cluster",
          "name" => $gridname ,
    );
    my ( $grid ) = &do_func("get", %opthash );

    &debug_cli (2,"modgr st($timeout) rc($rem_access) sa($supp_access)");
    &debug_cli (2,"modgr lc($lcd_input) vpn($vpn_port) ss($secret)");

    # make some changes, if we have a grid
    if ( $grid ) {

        if ( $timeout ) { $grid->session_timeout ( $timeout ) }
        if ( $secret ) { $grid->secret ( $secret ) }
        if ( $vpn_port ) { $grid->vpn_port ( $vpn_port ) }
        if ( $newname ) { $grid->name ( $newname ) }

        if ( $rem_access ) { $grid->remote_console_access ( $rem_access ) }
        if ( $supp_access ) { $grid->support_access ( $supp_access ) }
        if ( $lcd_input ) { $grid->lcd_input ( $lcd_input ) }
        if ( $use_ntp ) { $grid->enable_ntp ( $use_ntp ) }

        # Add NTP servers
        if ( @ntp_servers ) {
            my @ntp_list ;
            foreach my $ntp ( @ntp_servers ) {
                # normaal members
                push @ntp_list , Infoblox::Cluster::NTPServer->new(
                                "address" => $ntp ,
                                authentication => "FALSE",
                                );

                &debug_cli (2,"modgr ntp($ntp)");

                print "AAAA-----\n";
                print Dumper ( \@ntp_list ) ;
            }
            $grid->ntp_server ( \@ntp_list ) ;
            $grid->enable_ntp( "TRUE" );
        }

        # push the changes, if we were ok
        &do_func("modify",$grid);
    }

}

# global member settings

=head2 configure Member settings

Enable or Disable the NTP service

   configure member 1.2.3.20 enable ntp
   configure member 1.2.3.20 disable ntp

=cut


sub cli_mod_member {

    my ( $line ) = @_ ;
    # get the args from the line
    ( my $member)  = $line =~/configure member (\S+)/ ;

    # find some booleans
    my $use_ntp ;
    $line =~/enable ntp$/ and $use_ntp = "TRUE" ;
    $line =~/disable ntp$/ and $use_ntp = "FALSE" ;

    # first get the member
    my %opthash = (
          "object" => "Infoblox::Cluster::Member",
          "name" => $member ,
    );
    my ( $memobj ) = &do_func("get", %opthash );

    &debug_cli (2,"modme ntp($use_ntp)");

    # make some changes, if we have a grid
    if ( $memobj ) {

        if ( $use_ntp ) { $memobj->enable_ntp ( $use_ntp ) }

        # push the changes, if we were ok
        &do_func("modify",$memobj);
    }

}

# [ ] dns settings

=head2 add global DNS settings

   conf grid <name> add dns nsgroup <name>

DNS ACLs

   conf grid <name> add dns acl zone-transfer x.x.x.x/nn

=cut

# [ ] broken until i get syntax to set the Grid name



=head2 add global DHCP settings

   conf grid <name> add dhcp option lease-time=3600

Custom optons

   conf grid <name> add dhcp option 82="opt 82 string" 

Set the type for a custom option
   
   conf grid <name> add dhcp typeoption 82=IPADDRESS

Remove a custom option

   conf grid <name> delete dhcp option 82

=cut

sub cli_add_grid_dhcp {

    my ( $line ) = @_ ;
    # get the args from the line
    ( my $gridname)  = $line =~/configure grid (\S+)/ ;

    my @options  = $line =~/ option (\S+)/g ;
    my @typedefs  = $line =~/ typeoption (\S+)/g ;

    # else get the grid
    my %opthash = (
          "object" => "Infoblox::Cluster::DHCP",
#           "cluster" => $gridname ,
          "name" => $gridname ,
    );

    my ( $grid ) = &do_func("get", %opthash );


#        my $option = Infoblox::Cluster::DHCP::Custom_option->new(
#                "num" => "1",
#                "type" => "ip-address",
#                "value" => "10.0.0.10" );



    
#     my ( $cluster ) = &do_func("get", %args ) ;
# 
#     if ( $cluster ) {
#         # add the option, make the changes;
#         $cluster->options( [ $obj ] ) ;
#     print Dumper ( \$cluster ) ;
#         &do_func("modify", $cluster ) ;
#     }


}

=head2 Remove a custom option

   conf network global delete custom_option 82
   conf network global delete lease_time

=cut

sub cli_del_global_dhcp {
}

=head2 modify a network

TBD

=cut

sub cli_mod_network {
}

# End -- API ---

#
# show stuff
#

=head1 SHOW commands

=head2 Showing Zones

Show all zones

    show zone

Show all forward zones

    show zone forward

Show all reverse zones

    show zone reverse

Show just 1 zone

    show zone foo.com

=cut


sub cli_show_zone {
    #
    # [ ] show needs some cleanup

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $type ) = $line =~/ zone (\S+)/ ;
    my ( $view ) = $line =~/ view (\S+)/ ;

    &debug_cli(2,"showz t($type)");

    # we can get either all forward, rev or just a zone
    if ( !$type or $type eq "forward" 
                or $type eq "reverse" 
                or $type eq "view" 
       ) {
        # get all the zones
        my %opthash = (
               "object" => "Infoblox::DNS::Zone", 
               "name" => ".*" 
        );
    
        # do we have a specific view ?
        if ( $view ) { 
            $opthash{"view"} = $view ;
        };

        my @zones = &do_func("search", %opthash );
    
        # we can't sort on oid, we have to sort on name
        my @forzones ;
        my @revzones ;
        foreach my $zone (@zones) {
          my $name = $zone->name();
          if ( $name =~ /\/\d+$/ ) {
             push @revzones , "  $name\n";
          }
          else {
             push @forzones , "  $name\n";
          }
        }

        # now print them (sorted)
        if ( $type eq "forward" ) { print sort @forzones ; }
        elsif ( $type eq "reverse" ) { print sort by_ip @revzones ; }
        else { 
           print sort @forzones ; 
           print sort by_ip @revzones ; 
        }
    
    }
    else {
        # specific zone
        my %opthash = (
               "object" => "Infoblox::DNS::Zone", 
               "name" => $type 
        );
    
        # do we have a specific view ?
        if ( $view ) { 
            $opthash{"view"} = $view ;
        };

        my ( $zone ) = &do_func("get", %opthash );

        &dump_object ( $zone ) ;

    }

}

=head2 Showing Views

Show all views

    show views

Show just One view

    show view default

=cut


sub cli_show_view {
    #

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $name ) = $line =~/ views (\S+)/ ;

    &debug_cli(2,"showv t($name)");

    # we can get either all forward, rev or just a view
    if ( ! $name ) {
        # get all the views
        my %opthash = (
               "object" => "Infoblox::DNS::View", 
               "name" => ".*" 
        );
    
        my @views = &do_func("search", %opthash );
    
        my @vlist ;
        foreach my $view (@views) {
          my $name = $view->name();
          push @vlist , "  $name\n";
        }

        print sort @vlist ; 
    
    }
    else {
        # specific zone
        my %opthash = (
               "object" => "Infoblox::DNS::View", 
               "name" => $name 
        );
        my ( $view ) = &do_func("get", %opthash );

        &dump_object ( $view ) ;

    }

}

=head2 Showing leases

   show lease 1.1.1.1

   shoe lease aa:bb:cc:11:22:33

=cut

sub cli_show_lease {
    #
    # splitting either creates ALL networks or only the ones
    # we have to have (which could be none)

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $item ) = $line =~/ lease (\S+)/ ;

    # is it IP or mac...
    my $stype ;
    if ( $item =~ /$REip/ ) { $stype = "ipv4addr" }
    else { $stype = "mac" }

    &debug_cli(2,"showl l($item) t($stype)");

    # get all the zones
    my %opthash = (
           "object" => "Infoblox::DHCP::Lease", 
           $stype => $item,
    );

    my @leases = &do_func("get", %opthash );

    foreach my $lease ( @leases ) {
       # format and pretty print
       foreach my $k ( qw( client_hostname mac ipv4addr
                           starts ends 
                           cltt tsfp tstp 
                           binding_state next_binding_state ) ) {

         my $val = $lease->$k ;
         # clenasing
         $val =~ s/&quot;/"/g;
         print "  $k = \t$val\n";

       }

    }

#     my @netlist ;
#     foreach my $net (@nets) {
#       my $name = $net->name();
#       push @netlist , "  $name\n";
#     }

    # now print them (sorted)
#     print sort @netlist ; 
    
}

=head2 Showing networks

   show network

   show network 161.245.254.128/25

=cut

sub cli_show_network {
    #
    # try and shopw a network

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $net ) = $line =~/ network (\S+)/ ;

    &debug_cli(2,"shown n($net)");

    # do we get all nets
    my $search = ".*";
    # or just one net
    if ( $net ) { $search = $net ; }

    # get all the networks
    my %opthash = (
           "object" => "Infoblox::DHCP::Network", 
           "network" => $search,
    );

    my @nets = &do_func("search", %opthash );

    # dump the network or all the list
    if ( $net ) {
        &dump_object ( shift @nets ) ;
    }
    else {

        my @netlist ;
        foreach my $nobj (@nets) {
            my $name = $nobj->network();
            push @netlist , "  $name\n";
        }

        # now print them (sorted)
        print sort @netlist ; 
    }
    
}

=head2 Showing networks

   show network 161.245.254.128/25 range

   show network 161.245.254.128/25 range 161.245.254.130

=cut

sub cli_show_range {
    #
    # try and shopw a network

    my ( $line ) = @_ ;

    # get the args from the line
    my ( $net ) = $line =~/ network (\S+)/ ;
    my ( $range ) = $line =~/ range (\S+)/ ;

    &debug_cli(2,"showr n($net) r($range)");

#     # To get get ALL ranges
#     my %opthash = (
#            "object" => "Infoblox::DHCP::Range", 
#            "start_addr" => ".*",
#     );

    # get all ranges in a network ( 3.2r9 ? )
    my %opthash = (
           "object" => "Infoblox::DHCP::Range", 
           "network" => $net,
           "start_addr" => ".*",
    );

    # if we want to be specific, we get an actual range
    if ( $range ) {
        %opthash = (
           "object" => "Infoblox::DHCP::Range", 
           "network" => $net,
           "start_addr" => $range,
        );
    }

    # get what we need
    my @ranges = &do_func("search", %opthash );

    # dump the range or all the list
    if ( $range ) {
        &dump_object ( shift @ranges ) ;
    }
    else {

        # display all
        my @rangelist ;
        foreach my $nobj (@ranges) {
            my $net = $nobj->network();
            my $fip = $nobj->start_addr();
            my $lip = $nobj->end_addr();
            push @rangelist , "  $net : $fip - $lip\n";
        }

        # now print them (sorted)
        print sort @rangelist ; 

    }
    
}

=head2 Showing leases

Show a lease

    show lease ip 1.1.1.1
    show lease mac aa:aa:aa

=cut

# [ ] get a lease with a regex...

=head2 Showing records

Show a host

    show host test.foo.com

=cut

=head2 Showing ranges

=cut

#
# SERVER CONNECTION STUFF.....
#

=head1 Server Management

=head2 Connect to a server

    conf server <SERVER> user <USERNAME> password <PASSWD>

Select a server to talk to

    server ? > conf server 10.0.1.230 
    10.0.1.20 >

Supply the username and or password
   
    server ? > conf ser 10.0.1.230 user admin pass infoblox
    admin@10.0.1.20 >
        
=cut

sub cli_add_server {

    my ( $line ) = @_ ;

    # get the args from the line
    ( my $server)  = $line =~/server (\S+)/ ;
    ( my $user)    = $line =~/user (\S+)/ ;
    ( my $passwd)  = $line =~/password (\S+)/ ;

    &debug_cli (2,"add svr s($server) u($user) p($passwd)");

    $MASTER_IP = $server ;

    # create the session handler
       $SESSION = Infoblox::Session->new( 
                     "master" => $server,
                     "username" => $user,
                     "password" => $passwd ,
                  );


        print Dumper ( \$SESSION ) if $DEBUG >= 2 ;

      if ( $SESSION->status_code() ) {
          my $result = $SESSION->status_code();
          my $response = $SESSION->status_detail();

          print "  Error : $response ($result)\n";
      }
      else {
         $ONLINE = 1 ;
         $PROMPT = "$user\@$server > " ;
         # check for editline
         if ( $USE_EL ) {
             $el->set_prompt ( $PROMPT );
         }
         else {
            print "$PROMPT";
         }
      }


}

=head2 Show server details

    show server version

    show server error

    show server message

=cut
sub cli_show_server {

    my ( $line ) = @_ ;

    # get the status
    if ( $SESSION ) {
        my $result = $SESSION->status_code();
        my $response = $SESSION->status_detail();
        my $rev = $SESSION->server_version();

        # get the args from the line
        if ( $line =~ /version/ ) {
            print " Server Version : $rev\n";
        }
    }

}

=head2 Restarting services

the cli will not restart services, you have to do that manually

   restart dns
   restart dhcp

IF you want to delay the restart you can do that also

   restart dns delay 10

=cut

sub cli_restart {

    my ( $line ) = @_ ;

    # get the args from the line
    ( my $service)  = $line =~/restart (\S+)/ ;
    ( my $delay)  = $line =~/delay (\S+)/ ;

    &debug_cli (2,"restart s($service) d($delay)");

    my %opthash ;
    $opthash{'service'}=$service;
    $opthash{'when'}=0;
    if ( $delay ) {
       $opthash{'delay'}=$delay;
    }

    my @function=("restart",%opthash);
    &do_func(@function);

}

=head2 Export the database

    download database <file>

=cut

sub cli_download {

    my ( $line ) = @_ ;
    # get the args from the line
    ( my $dest)  = $line =~/database (\S+)/ ;

    my %opthash = (
          "path" => $dest ,
          "type" => "backup",
          "format" => "tar",
    );

    print "DOWNLOADING ALL DATABASE data as $dest ...\n";

    my @function=("export_data",%opthash);
    &do_func(@function);

    print "DONE\n";
}


###########################################
#
# END API calling functions.
#
###########################################

sub dump_object {
    # pretty print an object
    my ( $obj ) = @_ ;

    print Dumper ( \$obj ) if $DEBUG > 3 ;

    foreach my $key ( sort keys %{ $obj } ) {
        # ignore privates
        next if $key =~ /^__/;
        next if $key =~ /FUNCTION/;
        next if ! $obj->{$key} ;

        my $data ;

        # look for sub objects
        if ( $key eq "primary" 
           ) {
            # get the name
            my $sobj = $obj->{$key} ;
            $data = $sobj->{'name'};
        }
        # arrays by 'ipv4addr'
        elsif ( $key eq "syslog_server" or $key eq "match_members" ) {
            my @values ;
            # find all the names only
            foreach my $sobj ( @{ $obj->{$key} } ) {
                my $name = $sobj->{'ipv4addr'};
                push @values , "$name" ;
            }

            # remember it
            $data = "@values";
            $data = join " " , @values ;
              
        }
        # arrays by just a value
        elsif ( $key eq "ntp_access_list" 
             or $key eq "match_clients" 
             or $key eq "match_client_keys" 
             or $key eq "ntp_authentication_key" 
             ) {

            my @values = @{ $obj->{$key} } ;

            # remember it
            $data = "@values";
            $data = join " " , @values ;
              
        }
        # arrays by 'address'
        elsif ( $key eq "ntp_server" ) {
            my @values ;
            # find all the names only
            foreach my $sobj ( @{ $obj->{$key} } ) {
                my $name = $sobj->{'address'};
                push @values , "$name" ;
            }

            # remember it
            $data = "@values";
            $data = join " " , @values ;
              
        }
        # views , by name
        elsif ( $key eq "views" ) {
            my @values ;
            # find all the names only
            foreach my $sobj ( @{ $obj->{$key} } ) {
                my $name = $sobj->{'name'};
                push @values , "$name" ;
            }

            # remember it
            $data = "@values";
#             $data = join " " , @values ;
              
        }
        elsif ( $key eq "secondaries") {
            my @values ;
            # find all the names only
            foreach my $sobj ( @{ $obj->{$key} } ) {
                my $name = $sobj->{'name'};
                my $ip = $sobj->{'ipv4addr'};
                push @values , "$name,$ip" ;
                printf ( "%30s : %s,%s\n", $key , $name,$ip ) ;
            }

#             # remember it
#             $data = "@values";
#             $data = join " " , @values ;
              
        }
        else {
            $data = $obj->{$key} ;
        }

        # print it
        if ( $data ) {
            printf ( "%30s : %s\n", $key , $data ) ;
        }
        
    }

}

# sub make_dhcp_option {
#     print "  OPTIONS not supported\n";
# }

# DHCP functions
sub make_dhcp_option {
    my ( $DEBUG, $opt , $val ) = @_ ;

    # eat random dhcp options,
    # make intelligent decisions,
    # return an object

    # initially clean the value
    $val =~ s/"//g;

    # we have to convert all options to both a name and a number
    # this will save us pain in the long run

    my ( $onum , $oname ) = &get_custom_options ( $DEBUG , $opt ) ;

    debug_cli(4,"mkdh: took option o($opt) > ($onum)($oname)=($val)");

    # then conditionally check the object and see if it it is special
    # or just an ordinary option

    # this loop is the god, it renames a value and its type
    # it is also a list of what options we handle specifically
    # (as opposed to generic 'custom options')

    my $option ;

    if ( $oname eq "routers" ) {
       $option = Infoblox::DHCP::Option->new (
                    "type" => "routers",
                    "ipv4addrs" => [ split(/,\s*/,$val) ],
                 )
    }
    elsif ( $oname eq "domain-name-servers" ) {
       $option = Infoblox::DHCP::Option->new (
                    "type" => "nameservers",
                    "ipv4addrs" => [ split(/,\s*/,$val) ],
                 )
    }
    elsif ( $oname eq "domain-name" ) {
       $option = Infoblox::DHCP::Option->new (
                    "type" => "domain-name",
                    "name" => $val,
                 )
    }
    elsif ( $oname eq "broadcast-address" ) {
       $option = Infoblox::DHCP::Option->new (
                    "type" => "broadcast",
                    "ipv4addr" => $val,
                 )
    }
    elsif ( $oname =~ /^lease*/ ) {
       $option = Infoblox::DHCP::Option->new (
                    "type" => "lease-time",
                    "seconds" => $val,
                 )
    }
    elsif ( $onum ) {
       # only do this if we have a real #
       debug_cli(4,"mkdh: generic option o($onum)=($val)");
       $option = Infoblox::DHCP::Option->new (
                    "type" => $onum,
                    "value" => $val,
                 )
    }

    # return the object and the name of the object
    return ( $option , $oname ) ;

}

sub get_custom_options {
  # remap some variables
    my $DEBUG = shift;
    my $opt = shift;
    my %lookup = (
         "subnet-mask" => "Option   1: subnet-mask",
         "time-offset" => "Option   2: time-offset",
         "routers" => "Option   3: routers",
         "time-servers" => "Option   4: time-servers",
         "ien116-name-servers" => "Option   5: ien116-name-servers",
         "domain-name-servers" => "Option   6: domain-name-servers",
         "log-servers" => "Option   7: log-servers",
         "cookie-servers" => "Option   8: cookie-servers",
         "lpr-servers" => "Option   9: lpr-servers",
         "impress-servers" => "Option  10: impress-servers",
         "resource-location-servers" => "Option  11: resource-location-servers",
         "host-name" => "Option  12: host-name",
         "boot-size" => "Option  13: boot-size",
         "merit-dump" => "Option  14: merit-dump",
         "default-domain" => "Option  15: domain-name",
         "domain-name" => "Option  15: domain-name",
         "swap-server" => "Option  16: swap-server",
         "root-path" => "Option  17: root-path",
         "extensions-path" => "Option  18: extensions-path",
         "ip-forwarding" => "Option  19: ip-forwarding",
         "non-local-source-routing" => "Option  20: non-local-source-routing",
         "policy-filter" => "Option  21: policy-filter",
         "max-dgram-reassembly" => "Option  22: max-dgram-reassembly",
         "default-ip-ttl" => "Option  23: default-ip-ttl",
         "path-mtu-aging-timeout" => "Option  24: path-mtu-aging-timeout",
         "path-mtu-plateau-table" => "Option  25: path-mtu-plateau-table",
         "interface-mtu" => "Option  26: interface-mtu",
         "all-subnets-local" => "Option  27: all-subnets-local",
         "broadcast-address" => "Option  28: broadcast-address",
         "perform-mask-discovery" => "Option  29: perform-mask-discovery",
         "mask-supplier" => "Option  30: mask-supplier",
         "router-discovery" => "Option  31: router-discovery",
         "router-solicitation-address" => "Option  32: router-solicitation-address",
         "static-routes" => "Option  33: static-routes",
         "trailer-encapsulation" => "Option  34: trailer-encapsulation",
         "arp-cache-timeout" => "Option  35: arp-cache-timeout",
         "ieee802-3-encapsulation" => "Option  36: ieee802-3-encapsulation",
         "default-tcp-ttl" => "Option  37: default-tcp-ttl",
         "tcp-keepalive-interval" => "Option  38: tcp-keepalive-interval",
         "tcp-keepalive-garbage" => "Option  39: tcp-keepalive-garbage",
         "nis-domain" => "Option  40: nis-domain",
         "nis-servers" => "Option  41: nis-servers",
         "ntp-servers" => "Option  42: ntp-servers",
         "vendor-encapsulated-options" => "Option  43: vendor-encapsulated-options",
         "netbios-name-servers" => "Option  44: netbios-name-servers",
         "netbios-dd-server" => "Option  45: netbios-dd-server",
         "netbios-node-type" => "Option  46: netbios-node-type",
         "netbios-scope" => "Option  47: netbios-scope",
         "font-servers" => "Option  48: font-servers",
         "x-display-manager" => "Option  49: x-display-manager",
         "dhcp-requested-address" => "Option  50: dhcp-requested-address",
         "lease" => "Option  51: lease-time",
         "lease-time" => "Option  51: lease-time",
         "default-lease-time" => "Option  51: lease-time",
         "max-lease-time" => "Option  51: lease-time",
         "dhcp-option-overload" => "Option  52: dhcp-option-overload",
         "dhcp-message-type" => "Option  53: dhcp-message-type",
         "dhcp-server-identifier" => "Option  54: dhcp-server-identifier",
         "dhcp-parameter-request-list" => "Option  55: dhcp-parameter-request-list",
         "dhcp-message" => "Option  56: dhcp-message",
         "dhcp-max-message-size" => "Option  57: dhcp-max-message-size",
         "dhcp-renewal-time" => "Option  58: dhcp-renewal-time",
         "dhcp-rebinding-time" => "Option  59: dhcp-rebinding-time",
         "vendor-class-identifier" => "Option  60: vendor-class-identifier",
         "dhcp-client-identifier" => "Option  61: dhcp-client-identifier",
         "nwip-domain" => "Option  62: nwip-domain",
         "nwip-suboptions" => "Option  63: nwip-suboptions",
         "nisplus-domain" => "Option  64: nisplus-domain",
         "nisplus-servers" => "Option  65: nisplus-servers",
         "tftp-server-name" => "Option  66: tftp-server-name",
         "tftp-server" => "Option  66: tftp-server-name",
         "boot-file" => "Option  67: boot-file",
         "mobile-ip-home-agent" => "Option  68: mobile-ip-home-agent",
         "smtp-server" => "Option  69: smtp-server",
         "pop-server" => "Option  70: pop-server",
         "nntp-server" => "Option  71: nntp-server",
         "www-server" => "Option  72: www-server",
         "finger-server" => "Option  73: finger-server",
         "irc-server" => "Option  74: irc-server",
         "streettalk-server" => "Option  75: streettalk-server",
         "streettalk-directory-assistance-server" => "Option  76: streettalk-directory-assistance-server",
         "user-class" => "Option  77: user-class",
         "slp-directory-agent" => "Option  78: slp-directory-agent",
         "slp-service-scope" => "Option  79: slp-service-scope",
         "option-80" => "Option  80: option-80",
         "fqdn" => "Option  81: fqdn",
         "relay-agent-information" => "Option  82: relay-agent-information",
         "option-83" => "Option  83: option-83",
         "option-84" => "Option  84: option-84",
         "nds-servers" => "Option  85: nds-servers",
         "nds-tree-name" => "Option  86: nds-tree-name",
         "nds-context" => "Option  87: nds-context",
         "option-88" => "Option  88: option-88",
         "option-89" => "Option  89: option-89",
         "option-90" => "Option  90: option-90",
         "option-91" => "Option  91: option-91",
         "option-92" => "Option  92: option-92",
         "option-93" => "Option  93: option-93",
         "option-94" => "Option  94: option-94",
         "option-95" => "Option  95: option-95",
         "option-96" => "Option  96: option-96",
         "option-97" => "Option  97: option-97",
         "uap-servers" => "Option  98: uap-servers",
         "option-99" => "Option  99: option-99",
         "option-100" => "Option 100: option-100",
         "option-101" => "Option 101: option-101",
         "option-102" => "Option 102: option-102",
         "option-103" => "Option 103: option-103",
         "option-104" => "Option 104: option-104",
         "option-105" => "Option 105: option-105",
         "option-106" => "Option 106: option-106",
         "option-107" => "Option 107: option-107",
         "option-108" => "Option 108: option-108",
         "option-109" => "Option 109: option-109",
         "option-110" => "Option 110: option-110",
         "option-111" => "Option 111: option-111",
         "option-112" => "Option 112: option-112",
         "option-113" => "Option 113: option-113",
         "option-114" => "Option 114: option-114",
         "option-115" => "Option 115: option-115",
         "option-116" => "Option 116: option-116",
         "option-117" => "Option 117: option-117",
         "subnet-selection" => "Option 118: subnet-selection",
         "option-119" => "Option 119: option-119",
         "option-120" => "Option 120: option-120",
         "option-121" => "Option 121: option-121",
         "option-122" => "Option 122: option-122",
         "option-123" => "Option 123: option-123",
         "option-124" => "Option 124: option-124",
         "option-125" => "Option 125: option-125",
         "option-126" => "Option 126: option-126",
         "option-127" => "Option 127: option-127",
         "option-128" => "Option 128: option-128",
         "option-129" => "Option 129: option-129",
         "option-130" => "Option 130: option-130",
         "option-131" => "Option 131: option-131",
         "option-132" => "Option 132: option-132",
         "option-133" => "Option 133: option-133",
         "option-134" => "Option 134: option-134",
         "option-135" => "Option 135: option-135",
         "option-136" => "Option 136: option-136",
         "option-137" => "Option 137: option-137",
         "option-138" => "Option 138: option-138",
         "option-139" => "Option 139: option-139",
         "option-140" => "Option 140: option-140",
         "option-141" => "Option 141: option-141",
         "option-142" => "Option 142: option-142",
         "option-143" => "Option 143: option-143",
         "option-144" => "Option 144: option-144",
         "option-145" => "Option 145: option-145",
         "option-146" => "Option 146: option-146",
         "option-147" => "Option 147: option-147",
         "option-148" => "Option 148: option-148",
         "option-149" => "Option 149: option-149",
         "option-150" => "Option 150: option-150",
         "option-151" => "Option 151: option-151",
         "option-152" => "Option 152: option-152",
         "option-153" => "Option 153: option-153",
         "option-154" => "Option 154: option-154",
         "option-155" => "Option 155: option-155",
         "option-156" => "Option 156: option-156",
         "option-157" => "Option 157: option-157",
         "option-158" => "Option 158: option-158",
         "option-159" => "Option 159: option-159",
         "option-160" => "Option 160: option-160",
         "option-161" => "Option 161: option-161",
         "option-162" => "Option 162: option-162",
         "option-163" => "Option 163: option-163",
         "option-164" => "Option 164: option-164",
         "option-165" => "Option 165: option-165",
         "option-166" => "Option 166: option-166",
         "option-167" => "Option 167: option-167",
         "option-168" => "Option 168: option-168",
         "option-169" => "Option 169: option-169",
         "option-170" => "Option 170: option-170",
         "option-171" => "Option 171: option-171",
         "option-172" => "Option 172: option-172",
         "option-173" => "Option 173: option-173",
         "option-174" => "Option 174: option-174",
         "option-175" => "Option 175: option-175",
         "option-176" => "Option 176: option-176",
         "option-177" => "Option 177: option-177",
         "option-178" => "Option 178: option-178",
         "option-179" => "Option 179: option-179",
         "option-180" => "Option 180: option-180",
         "option-181" => "Option 181: option-181",
         "option-182" => "Option 182: option-182",
         "option-183" => "Option 183: option-183",
         "option-184" => "Option 184: option-184",
         "option-185" => "Option 185: option-185",
         "option-186" => "Option 186: option-186",
         "option-187" => "Option 187: option-187",
         "option-188" => "Option 188: option-188",
         "option-189" => "Option 189: option-189",
         "option-190" => "Option 190: option-190",
         "option-191" => "Option 191: option-191",
         "option-192" => "Option 192: option-192",
         "option-193" => "Option 193: option-193",
         "option-194" => "Option 194: option-194",
         "option-195" => "Option 195: option-195",
         "option-196" => "Option 196: option-196",
         "option-197" => "Option 197: option-197",
         "option-198" => "Option 198: option-198",
         "option-199" => "Option 199: option-199",
         "option-200" => "Option 200: option-200",
         "option-201" => "Option 201: option-201",
         "option-202" => "Option 202: option-202",
         "option-203" => "Option 203: option-203",
         "option-204" => "Option 204: option-204",
         "option-205" => "Option 205: option-205",
         "option-206" => "Option 206: option-206",
         "option-207" => "Option 207: option-207",
         "option-208" => "Option 208: option-208",
         "option-209" => "Option 209: option-209",
         "authenticate" => "Option 210: authenticate",
         "option-211" => "Option 211: option-211",
         "option-212" => "Option 212: option-212",
         "option-213" => "Option 213: option-213",
         "option-214" => "Option 214: option-214",
         "option-215" => "Option 215: option-215",
         "option-216" => "Option 216: option-216",
         "option-217" => "Option 217: option-217",
         "option-218" => "Option 218: option-218",
         "option-219" => "Option 219: option-219",
         "option-220" => "Option 220: option-220",
         "option-221" => "Option 221: option-221",
         "option-222" => "Option 222: option-222",
         "option-223" => "Option 223: option-223",
         "option-224" => "Option 224: option-224",
         "option-225" => "Option 225: option-225",
         "option-226" => "Option 226: option-226",
         "option-227" => "Option 227: option-227",
         "option-228" => "Option 228: option-228",
         "option-229" => "Option 229: option-229",
         "option-230" => "Option 230: option-230",
         "option-231" => "Option 231: option-231",
         "option-232" => "Option 232: option-232",
         "option-233" => "Option 233: option-233",
         "option-234" => "Option 234: option-234",
         "option-235" => "Option 235: option-235",
         "option-236" => "Option 236: option-236",
         "option-237" => "Option 237: option-237",
         "option-238" => "Option 238: option-238",
         "option-239" => "Option 239: option-239",
         "option-240" => "Option 240: option-240",
         "option-241" => "Option 241: option-241",
         "option-242" => "Option 242: option-242",
         "option-243" => "Option 243: option-243",
         "option-244" => "Option 244: option-244",
         "option-245" => "Option 245: option-245",
         "option-246" => "Option 246: option-246",
         "option-247" => "Option 247: option-247",
         "option-248" => "Option 248: option-248",
         "option-249" => "Option 249: option-249",
         "option-250" => "Option 250: option-250",
         "option-251" => "Option 251: option-251",
         "option-252" => "Option 252: option-252",
         "option-253" => "Option 253: option-253",
         "option-254" => "Option 254: option-254",
    );

    # is it a number ?
    # then lookup and return the real name

    my $name ;
    my $number ;

    if ( $opt =~ /^\d+$/ ) {
       # look it up in the above list
       ( $name ) = grep ( / $opt:/ , sort values %lookup );

       # clean it, return
       $name =~ s/.*: //;
       $number = $opt;
    }
    else {
       # find the number
       # fix it ?
       if ( $lookup{$opt} ) {
          $number = $lookup{$opt};
          $name = $lookup{$opt};
          
          # strip and clean the answers
          $number =~ s/:.*//g;
          $number =~ s/\D//g;
          $name =~ s/.*: //;
       }
       else {
          $number = 0 ;
          $name = "0" ;
       }
    }

#     my $DEBUG = 4 ;
    debug_cli(4,"gedh: ($number , $name) from [$opt]");

    return ( $number , $name ) ;
}




sub by_ip {
    # used for sorting (by_ip)
    &abs_ip($a) <=> &abs_ip($b) ;
}

sub abs_ip {
    # get an IP as a real absval
    my ( $ip ) = @_ ;

    # strip cidr crap
    $ip =~ s/\/.*//;

    my @octets = split(/\./,$ip) ;

    my $absval = $octets[3] + ( 2 ** 8 * $octets[2] ) ;
       $absval = $absval + ( 2 ** 16 * $octets[1] ) ;
       $absval = $absval + ( 2 ** 24 * $octets[0] ) ;

    return ($absval) ;
}

sub cli_exit {
    # quit and cleanup
    print "\nexiting...bye\n"; 
#     $el->history_save(".clihistory") || die "cant" ;
    exit ;
#     return CC_EOF;
}

sub init_editline {

    # assume the worst
    my $use_el = 0 ;

    # now, try an catch the loading of editline and not abort when we die
    # errk

    # Inside an "eval()," the die()
    # error message is stuffed into $@ and the "eval" is terminated
    # with the undefined value.  
    # This makes "die" the way to raise an exception.
    eval { 
#         require Term::eEditLine;
        require Term::EditLine;
    } ;
    if ( $@ =~ /Can't locate Term.* in \@INC/ ) {
        # return NULL
        return ( 0 , 0 );
    }
    else {
        # we loaded ok, git going.
        $use_el = 1
    }
    
    # continue importing
    import Term::EditLine ;


    # create the object
    my $el = Term::EditLine->new('progname');

    $el->set_prompt ("$PROMPT");
    
    # other useful commands are
    #      $el->insertstr("aaaa");
    # inserts text, but may not print it.


    ##########################################################
    
    # sigint (ctrl-c) has to be caught by perl, before the term.
    # $SIG{INT} = sub { print "\nYou hit ^C... Aaayyy it hurts\n"; };
    # $SIG{INT} = sub { $el->reset ; return CC_CURSOR };
    # $el->add_fun ('undo','reset', 
    #              sub { print "\n" ; $el->reset ; return CC_REDISPLAY }) ;

    $SIG{INT} = 'IGNORE';

    ########################################
    # define input functions
    #
    # these occur based on character input...
    #
    ########################################

    # quit on '^D'
    # CC_EOF kills the input (end of file)
    # $el->add_fun ('bye','desc',sub { 
    #         print "q\nquitting...bye\n"; return CC_EOF; });

    $el->add_fun ('bye','desc', \&cli_exit );

    # print help
    $el->add_fun ('help','desc', \&print_help );

    # completion control
    $el->add_fun ('cmpcl','desc', \&cmpctl ) ;


    ########################################
    # add key bindings
    # 'q' to quit is really an arg function
    # $el->parse('bind','q\n','bye');

    $el->parse('bind','-e');
    $el->parse('bind','^D','bye');

    # "\" clear the line ( can't use CRTL-C ?? )
    $el->parse('bind','\\\\','ed-start-over');
    
    # inline help
    $el->parse('bind','?','help');
    
    # tab ?
    $el->parse('bind','\t','cmpcl');

    # show them all
    # $el->parse('bind','-a');

    ########################################
    
    # load the history
    # $el->history_load(".clihistory");

    ########################################

    # did we succeed ?
    if ( $el ) { $use_el = 1 }

    # return the handler
#     return ( $el );
    return ( $use_el , $el );
}

sub init_commands {


##########################################################
#
# The word list lookup table
# we'll create a big hash of all commandline alternatives then
# abbreviate all of them. This will give you conditional cmpctl and still
# hopefully be easy to read

# the hash is $COMMANDS { "<string>" } { "words|func|help" }
#             $COMMANDS { "<string>" } { "words" }

# the LHS is a regex matching the WHOLE expanded comand line
# the RHS is the list of next possible words as a string which
# will get carved into array values as part of get_context()

# we grep from the LHS the WHOLE STRING (^..$) ensure uniqieness

# [x] how do you handle options than can come in any order ?
#      use '|' syntax "word|word|word"
# [x] how do you handle option/value pairs ?
#      use '|=' syntax "word=<spec>|word=<spec>|word=<spec>"
# [ ] some options can be repeated, some need to end with them.
#     so we need a val|val syntax and a val?|val? syntax
#     ( use perlre's '?' for 0 or 1 )

# comm list


my %COMMANDS = (

    'NULL' => { 
           words => "help quit history restart download configure show test", },
    'test' => { 
#            words => "configure zone network", 
           words => "configure add adc|bb zone network", 
#            words => "comment=<comment> <cr> <name,ip> delay=<num> aa|bb bad|member=<ip>|import=<svr> zone network", 
           func => "cli_test", },
    'quit' => { 
           func => "cli_exit", },
    'history' => { 
           func => "cli_history", },
    'show' => { 
           words => "server grid=<name> views lease zone network debug",  },

    'help' => { 
           words => "all",
           func => "print_help", },
    'help all' => { 
           func => "print_perldoc", },

    'show debug' => { 
           words => "session commands",  },
    'show debug session' => { 
           func => "debug_commands", },
    'show debug commands' => { 
           words => "<cr> detailed",
           func => "debug_commands", },
    'show debug commands detailed' => { 
           func => "debug_commands", },

# -gdhshow-
# [x] show grid xxx
# [ ] show grid xxx dns nsgroup
# [ ] show grid xxx dhcp
# [ ] show grid xxx member
# [ ] show grid xxx member yyyy
# [x] show views
# [x] show network
# [ ] show network xxx
#     list options and ranges
# [ ] show network xxx stats
#     Infoblox::DHCP::Statistics
# [ ] show network xxx range yyy
#     Infoblox::DHCP::Range
#     Infoblox::DHCP::ExclusionRange
#     Infoblox::DHCP::FilterRule
# [ ] show zone (fqdn)
# [ ] show host (fqdn)
# [ ] show license
# [ ] show failover
# [ ] show filter xxx

    'show grid <name>' => { 
           words => "<cr> member",  
           func => "cli_show_grid", },

    'show grid <name> member' => { 
           words => "<cr> <name>",  
           func => "cli_show_grid", },

    'show grid <name> member <name>' => { 
#            words => "<name>",  
           func => "cli_show_grid", },

    'show views' => { 
           words => "<cr> <name>",  
           func => "cli_show_view", },

    'show views <name>' => { 
           words => "<cr>",  
           func => "cli_show_view", },

    'show zone' => { 
           words => "<cr> <zone>|forward|reverse|view=<name>",  
           func => "cli_show_zone", },

    'show network' => { 
           words => "<cr> <n.n.n.n/mm>",  
           func => "cli_show_network", },
    'show network <n.n.n.n/mm>' => { 
           words => "<cr> range",  
           func => "cli_show_network", },
    'show network <n.n.n.n/mm> range' => { 
           words => "<cr> <ip>",  
           func => "cli_show_range", },
    'show network <n.n.n.n/mm> range <ip>' => { 
           func => "cli_show_range", },

    'show lease' => { 
           words => "<ip> <mac>", },
#            func => "cli_show_lease", },
    'show lease <mac>' => { 
           func => "cli_show_lease", },
    'show lease <ip>' => { 
           func => "cli_show_lease", },

    'download' => { 
           words => "database",  },
    'download database' => { 
           words => "<file>",  },
    'download database <file>' => { 
           func => "cli_download", },
    'restart' => { 
           words => "dns dhcp",  },
    'restart dns' => { 
           words => "delay=<num>",  
           func => "cli_restart", },
    'restart dhcp' => { 
           words => "delay=<num>",  
           func => "cli_restart", },

    'configure' => { 
           words => "debug server zone network grid member" , },

    'configure debug' => { 
           words => "<num>", },
    'configure debug <num>' => { 
           func => "set_debug", },

# - server -
    'configure server' => { 
           words => "<value>", },

    'configure server <value>' => { 
           words => "user=<value>", },
    'configure server <value> user <value>' => { 
           words => "password=<value>", 
           func => "cli_add_server", },


    'show server' => { 
           words => "version error message", },

    'show server version' => { 
           func => "cli_show_server", },
    'show server error' => { 
           func => "cli_show_server", },
    'show server message' => { 
           func => "cli_show_server", },

# --

    'configure member' => { 
           words => "<name>", },

    'configure grid' => { 
           words => "<name>", },

# [ ] conf member <name> enable ntp

# - member -
    'configure member <name>' => { 
           words => "disable enable", },

    'configure member <name> disable' => { 
           words => "ntp|dns|dhcp",
           func => "cli_mod_member", },

    'configure member <name> enable' => { 
           words => "ntp|dns|dhcp",
           func => "cli_mod_member", },

# - grid -
    'configure grid <name>' => { 
           words => "disable enable add delete modify", },

    'configure grid <name> disable' => { 
           words => "ntp|ntp_server",
           func => "cli_mod_grid", },

    'configure grid <name> enable' => { 
           words => "ntp|ntp_server",
           func => "cli_mod_grid", },

    'configure grid <name> modify' => { 
           words => "grid_name=<name>|session_timeout=<value>|vpn_port=<value>|shared_secret=<value>",
           func => "cli_mod_grid", },

    'configure grid <name> delete' => { 
           words => "lcd_input|remote_console_access|support_access",
           func => "cli_mod_grid", },

    'configure grid <name> add' => { 
           words => "dns dhcp ntp_server=<ip>|lcd_input|remote_console_access|support_access",
           func => "cli_mod_grid", },
    'configure grid <name> add dns' => { 
           words => "nsgroup=<name> acl", },

    'configure grid <name> add dns nsgroup <name>' => { 
           words => "stealth_ext_secondary=<name,ip>|ext_secondary=<name,ip>|ext_primary=<name,ip>|primary=<ip>|secondary=<ip,ip>", 
           func => "cli_add_grid_nsgroup", },

    'configure grid <name> add dns acl' => { 
           words => "allow deny", },

    'configure grid <name> add dns acl allow' => { 
           words => "transfer=<n.n.n.n/mm>|update=<n.n.n.n/mm>|query=<n.n.n.n/mm>|forwarding=<n.n.n.n/mm>", 
           func => "cli_add_grid_dns_acl", },
    'configure grid <name> add dns acl deny' => { 
           words => "transfer=<n.n.n.n/mm>|update=<n.n.n.n/mm>|query=<n.n.n.n/mm>|forwarding=<n.n.n.n/mm>", 
           func => "cli_add_grid_dns_acl", },

    'configure grid <name> add dhcp' => { 
           words => "option=<name=value>|typeoption=<name=value>",
           func => "cli_add_grid_dhcp", },

    'configure zone' => { 
           words => "add delete <zone>", },

    'configure zone delete' => { 
           words => "<zone>", },
    'configure zone delete <zone>' => { 
           func => "cli_delete_zone", },

    'configure zone add' => { 
           words => "<zone>", },
    'configure zone add <zone>' => { 
           words => "<cr>
           view=<name>|email=<name>|nsgroup=<name>|import=<ip>|member=<ip>|forward_to=<ip>|stealth_ext_secondary=<name,ip>|ext_secondary=<name,ip>|ext_primary=<name,ip>|primary=<ip>|secondary=<ip,ip>",  
           func => "cli_add_zone", },

    'configure zone <zone>' => { 
           words => "add delete", },

    'configure zone <zone> add' => { 
           words => "host a_record bulkhost cname ptr_record mx", },
    'configure zone <zone> delete' => { 
           words => "host a_record bulkhost cname ptr_record mx", },

    'configure zone <zone> delete host' => { 
           words => "<name>", },
    'configure zone <zone> delete host <name>' => { 
           func => "cli_del_host", },

    'configure zone <zone> delete a_record' => { 
           words => "<name>=<ip>", },
    'configure zone <zone> delete a_record <name> <ip>' => { 
           func => "cli_del_a_rec", },

    'configure zone <zone> delete bulkhost' => { 
           words => "<name>", },
    'configure zone <zone> delete bulkhost <name>' => { 
           words => "<ip>", },
    'configure zone <zone> delete bulkhost <name> <ip>' => { 
           words => "<ip>", },
    'configure zone <zone> delete bulkhost <name> <ip> <ip>' => { 
           func => "cli_del_bulk", },

    'configure zone <zone> delete cname' => { 
           words => "<name>", },
    'configure zone <zone> delete cname <name>' => { 
           words => "<canonical>", },
    'configure zone <zone> delete cname <name> <canonical>' => { 
           func => "cli_del_cname", },

    'configure zone <zone> delete ptr_record' => { 
           words => "<ip>", },
    'configure zone <zone> delete ptr_record <ip>' => { 
           words => "<name>", },
    'configure zone <zone> delete ptr_record <ip> <name>' => { 
           func => "cli_del_ptr", },

    'configure zone <zone> add mx' => { 
           words => "<name>", },
    'configure zone <zone> add mx <name>' => { 
           words => "<priority>=<name>", },
    'configure zone <zone> add mx <name> <priority> <name>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_mx", },
    'configure zone <zone> add mx <name> <priority> <name> comment <comment>' => { 
           func => "cli_add_mx", },

    'configure zone <zone> add host' => { 
           words => "<name>=<ip,ip>", },
    'configure zone <zone> add host <name> <ip,ip>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_host", },
    'configure zone <zone> add host <name> <ip,ip> comment <comment>' => { 
           func => "cli_add_host", },

    'configure zone <zone> add a_record' => { 
           words => "<name>=<ip>", },
    'configure zone <zone> add a_record <name> <ip>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_a_rec", },
    'configure zone <zone> add a_record <name> <ip> comment <comment>' => { 
           func => "cli_add_a_rec", },

    'configure zone <zone> add bulkhost' => { 
           words => "<name>", },
    'configure zone <zone> add bulkhost <name>' => { 
           words => "<ip>", },
    'configure zone <zone> add bulkhost <name> <ip>' => { 
           words => "<ip>", },
    'configure zone <zone> add bulkhost <name> <ip> <ip>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_del_bulk", },
    'configure zone <zone> add bulkhost <name> <ip> <ip> comment <comment>'=> { 
           func => "cli_add_bulk", },

    'configure zone <zone> add cname' => { 
           words => "<name>", },
    'configure zone <zone> add cname <name>' => { 
           words => "<canonical>", },
    'configure zone <zone> add cname <name> <canonical>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_cname", },
    'configure zone <zone> add cname <name> <canonical> comment <comment>'=> { 
           func => "cli_add_cname", },

    'configure zone <zone> add ptr_record' => { 
           words => "<ip>", },
    'configure zone <zone> add ptr_record <ip>' => { 
           words => "<name>", },
    'configure zone <zone> add ptr_record <ip> <name>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_ptr", },
    'configure zone <zone> add cname <ip> <name> comment <comment>'=> { 
           func => "cli_add_ptr", },

    'configure network' => { 
           words => "add delete <n.n.n.n/mm> filter=<name>", },

    'configure network delete' => { 
           words => "<n.n.n.n/mm> macfilter=<name> shared=<name>", },
    'configure network delete <n.n.n.n/mm>' => { 
           func => "cli_delete_network", },

    'configure network add' => { 
           words => "<n.n.n.n/mm> macfilter=<name> shared=<name>", },

# - macfilters -
    'configure network add macfilter <name>' => { 
           func => "cli_add_macfilter", },
    'configure network delete macfilter <name>' => { 
           func => "cli_del_macfilter", },

    'configure network filter <name>' => { 
           words => "add delete", },

    'configure network filter <name> add' => { 
           words => "macaddress=<mac>", },
    'configure network filter <name> add macaddress <mac>' => { 
           words => "<cr> comment=<comment>", 
           func => "cli_add_macfilteraddr", },

    'configure network filter <name> delete' => { 
           words => "macaddress=<mac>", },
    'configure network filter <name> delete macaddress <mac>' => { 
           func => "cli_del_macfilteraddr", },

# - sharednetworks -
    'configure network add shared <name>' => { 
           words => "<cr> child_network=<n.n.n.n/mm>|comment=<comment>|member=<ip>|option=<name=value>",  
           func => "cli_add_shared", },
    'configure network add <n.n.n.n/mm>' => { 
           words => "<cr> addreverse|comment=<comment>|member=<ip>|option=<name=value>",  
           func => "cli_add_network", },

    'configure network <n.n.n.n/mm>' => { 
           words => "split add delete ", },

    'configure network <n.n.n.n/mm> add' => { 
           words => "network fixed range",  },
    'configure network <n.n.n.n/mm> delete' => { 
           words => "network fixed range",  },

    'configure network <n.n.n.n/mm> split' => { 
           words => "</cidr>",  },
    'configure network <n.n.n.n/mm> split </cidr>' => { 
           words => "<cr> required all",  
           func => "cli_split_network", },
    'configure network <n.n.n.n/mm> split </cidr> required' => { 
           func => "cli_split_network", },
    'configure network <n.n.n.n/mm> split </cidr> all' => { 
           func => "cli_split_network", },

    'configure network <n.n.n.n/mm> delete fixed' => { 
           words => "<ip>=<mac>",  },
    'configure network <n.n.n.n/mm> delete fixed <ip> <mac>' => { 
           func => "cli_del_fixed_address", },

    'configure network <n.n.n.n/mm> delete range' => { 
           words => "<ip>=<ip>",  },
    'configure network <n.n.n.n/mm> delete range <ip> <ip>' => { 
           func => "cli_del_dhcp_range", },

    'configure network <n.n.n.n/mm> add network' => { 
           words => "<n.n.n.n/mm>",  },
    'configure network <n.n.n.n/mm> add network <n.n.n.n/mm>' => { 
           words => "<cr> addreverse|comment=<comment>|member=<ip>|option=<name=value>",
           func => "cli_add_sub_network", },

    'configure network <n.n.n.n/mm> add fixed' => { 
           words => "<ip>=<mac>",  },
    'configure network <n.n.n.n/mm> add fixed <ip> <mac>' => { 
           words => "<cr> comment=<comment>|option=<name=value>",  
           func => "cli_add_fixed_address", },

    'configure network <n.n.n.n/mm> add range' => { 
           words => "<ip>=<ip>",  },
    'configure network <n.n.n.n/mm> add range <ip> <ip>' => { 
           words => "<cr> comment=<comment>|exclude=<ip,ip>|failover=<value>|member=<ip>|option=<name=value>",  
           func => "cli_add_dhcp_range", },

   );

# print Dumper ( \%COMMANDS ) ;

   return %COMMANDS ;

}


sub debug_commands {
    my ( $line ) = @_ ;
    # get the args from the line
    ( my $type)  = $line =~/debug (.*)/ ;

    if ( $type eq "commands detailed" ) {
        # dump crap to tty
        print Dumper ( \%COMMANDS );
    }
    if ( $type eq "commands" ) {
        foreach my $comm ( sort keys %COMMANDS ) {
            if ( $COMMANDS{$comm}{'func'} and $COMMANDS{$comm}{'words'} ) {
                print "  $comm $COMMANDS{$comm}{'words'}\n";
            }
            else {
                print "  $comm\n";
            }
        }
    }
    if ( $type eq "session" ) {
        # dump crap to tty
        print Dumper ( \$SESSION );
    }
}

sub set_debug {
                
    my ( $line ) = @_ ;
    # get the args from the line
    ( my $level)  = $line =~/debug (\S+)/ ;

    print "DEBUG = $level\n";
    $DEBUG = $level ;
}

=head2 Debugging :

  configure debug <level>

The higher the debug level, the more junk gets spat to the tty. You
probably don't want anything higher than (2) unless you are debugginh the
completion control parser.

=cut



sub debug_cli {
    # we're passed a message and a level
    # if this level is <= the CURRENT DEBUG level 
    # we print the data
    my $level = shift @_ ;

    if ($level <= $DEBUG) {
#         if ( $MAKE ) { print "# " ; }
        print "($level) DEBUG: @_\n";
    }

}

#############################

# $Log: ibcli,v $
# Revision 3.10  2006/07/19 15:35:59  horne
# BugId: 8205
# Reviewer(s): Geoff
# Description: extra show comands
#
# Revision 3.9  2006/07/14 23:25:43  horne
# BugId: 8205
# Reviewer(s): Geoff
# Description: added support for exclude ranges
# Add lots of grid level features
#
# Revision 3.8  2006/06/18 04:44:50  horne
# BugId: 8205
# Reviewer(s): Geoff
# Description: rolled in fixed for networks, added mac filter support
# fixed bugs with winders editline, fixed show network
#
# Revision 3.7  2006/06/05 17:40:34  horne
# BugId: 8205
# Reviewer(s): Geoff
# Description: added more features, shared networks, comments
#
# Revision 3.6  2006/06/01 01:58:47  horne
# BugId: 8205
# Reviewer(s): Kevin
# Description: fixed some require/import problems with constants
#
# Revision 3.5  2006/05/31 03:27:02  horne
# BugId: 8205
# Reviewer(s): Geoff
# Description: intial checkin of winders friendly version
#
# Revision 3.4  2006/05/01 22:58:26  horne
# BugId: 8205
# Reviewer(s): Geoff
# Description: reverse the default syntax for add zone
#
# Revision 3.3  2006/05/01 22:48:18  horne
# BugId: 8205
# Reviewer(s): geoff
# Description: merged in my branch
#
# Revision 3.2.2.4  2006/05/01 22:44:13  horne
#
# BugId: 8205
# Reviewer(s): Geoff
# Description: added voews to show zone, added nozone to add networks
#
# Revision 3.2.2.3  2006/02/16 21:46:14  horne
# BugId: 8209
# Reviewer(s): Geoff
# Description:
# added grid settings
# added grid nsgroups
# added zone nsgroups
# added zone email
# added zone eternal stealth secondaries
# added zone forward_to with members
# added mx record support
# added multiple ip addresses for a host
#
# Revision 3.2.2.2  2005/11/23 23:52:14  horne
# BugId: 8209
# Reviewer(s): Geoff
# Description: views, batch and show support
#
# Revision 3.2.2.1  2005/09/29 17:20:24  horne
# *** empty log message ***
#
# Revision 3.1.2.5  2005/09/29 17:18:13  horne
# *** empty log message ***
#
# Revision 3.1.2.4  2005/09/26 22:16:29  horne
# added support for failover and forwarders
#
# Revision 3.1.2.3  2005/08/15 20:44:42  horne
# added the rest of the perldoc
#
# Revision 3.1.2.2  2005/08/15 01:23:12  horne
# some rearranging of coments, mostly
#
# Revision 3.1.2.1  2005/08/14 23:31:43  horne
# *** empty log message ***
#
# Revision 3.1  2005/08/14 23:14:23  horne
# Bumped the rev#
#
# Revision 2.11  2005/08/14 23:13:11  horne
# *** empty log message ***
#
# Revision 2.10  2005/08/14 23:07:23  horne
# last version, this now gets replaced by complt with Readline
#
# Revision 2.9  2005/07/13 05:07:06  horne
# major fixes of some of the parser bits
# added additional functions to add zone
#
# Revision 2.8  2005/04/22 20:09:17  horne
# *** empty log message ***
#
# Revision 2.7  2005/03/22 01:01:18  horne
# *** empty log message ***
#
# Revision 2.6  2005/03/05 19:27:15  horne
# added support for custom options
#
# Revision 2.5  2004/12/22 20:52:05  horne
# fixed the commit prompt
# changed commit to 'reatart'
# really cleaned up the connection handler
# changed all 'set' to 'conf'
# cleaned up pod examples
#
# Revision 2.4  2004/12/20 15:57:03  horne
# *** empty log message ***
#
# Revision 2.3  2004/12/18 12:53:46  horne
# Ripped out all the recursive hash print stuff and replaced it with
# Data::Dumper instead (much cleaner)
#
# Revision 2.2  2004/12/18 12:10:13  horne
# this version has perldoc
#
# Revision 2.1  2004/12/14 05:09:01  horne
# first round of bug testing
# also added member support
# also add import zone
#
# Revision 2.0  2004/11/03 19:58:48  horne
# new code suporting the infoblox V3 API
# major rewrite
#
# Revision 1.18  2004/10/20 16:44:39  horne
# broken checkin - ignore
#
# Revision 1.17  2004/08/13 05:21:09  horne
# Added correct connection handling
#
# Revision 1.16  2004/08/13 03:57:45  horne
# Major changes to the arg parsers, args are now sent as arrays and the
#   do_ib_func does the formatting/prettyprinting
# Added conection syntax to hanvle V3 connections
# Added a whole bag of RADIUS commands
#
# Revision 1.15  2004/08/01 19:34:03  horne
# Added 'peer_assoc' support for V2.5
#
# Revision 1.14  2004/06/16 20:19:46  horne
# added comments to ptrs
# added modify global dhcp opts
#   conf dhcp global
# added fixed addresses
# added modify network options
#   conf net x.x.x.x/mm modify opt value
# added non-auth networks
#
# Revision 1.13  2004/02/13 20:11:21  horne
# added the command lister
#
# Revision 1.12  2003/11/26 01:29:09  horne
# *** empty log message ***
#
# Revision 1.11  2003/11/06 07:31:28  horne
# server and password now live on the same commandline
# upload and download database
# import zone
# conf zone add now takes additional options
#
# the software now writes its own code
#
# Revision 1.10  2003/10/16 21:41:25  horne
# un hardcoede dig
# changed password syntax
# added a -V -v option (version)
# added download commands
#
# Revision 1.9  2003/09/24 01:43:08  horne
# added dhcp range stuff
# cleaned up the dig pre-processing
#
# Revision 1.8  2003/09/22 21:37:30  horne
# added prt functions
# cleaned up show network
#
# Revision 1.7  2003/09/22 19:24:30  horne
# *** empty log message ***
#
# Revision 1.6  2003/09/21 23:04:29  horne
# added ambiguous commands
# prints now wrapped for cli or batch
# batch commands now work
#
# Revision 1.5  2003/09/20 01:22:36  horne
# First full working version with the abstracted argument parser.
# there is still a lot of gumpf in here, but most of the repeatable code is
# now packed into subroutines
#
# Revision 1.4  2003/09/18 02:28:56  horne
# *** empty log message ***
#
# Revision 1.3  2003/09/16 23:17:25  horne
# *** empty log message ***
#
# Revision 1.2  2003/09/09 22:58:27  horne
# *** empty log message ***
#
# Revision 1.1  2003/08/11 23:31:57  horne
# INFOBLOX version, re-set the CVS counters
#
# Revision 1.9  2001/06/07 16:45:47  horne
# major rewrite of the arg parser - ripped out all the RE's to a much better
# process.
# delete commands disabled
#
# Revision 1.8  2001/05/31 05:28:15  horne
# *** empty log message ***
#
# Revision 1.7  2001/05/24 00:17:54  horne
# Added RE's to handle shortened commant words, not however that this is
# still buggy, typos, as long as they are unique will still work. thus
#  - password, p , pa , ps , pdfgt = password
# I need to find a better command parser
#
# Revision 1.6  2001/05/23 19:39:11  horne
# working version - waiting for updates from infoblox to see if they have
# changed the API syntax
#
# Revision 1.5  2001/05/19 06:08:13  horne
# iblox ready version, but no connections to servers work
#
# Revision 1.4  2001/05/19 04:59:19  horne
# All base commands are being parsed and netmasks are being applied.
# Now we need to hit the infoblox engine for real
#
# Revision 1.3  2001/05/19 03:43:45  horne
# added the DEBUG option before i started to drown in a lot of messy print
# statements
#
# Revision 1.2  2001/05/19 03:34:34  horne
# Basic version, config file parsing is functional.
#
# Revision 1.1  2001/05/19 03:33:56  horne
# *** empty log message ***
#
