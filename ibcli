#!/usr/bin/perl
#
# (c) Copyright: Geoff horne, SLC 2001-2003
#               All rights reserved
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. So there...
#
# THIS TICKET IS SOLD SUBJECT TO THE SELLERS CONDITIONS OF SALE OF COPY
# WHICH IS AVAILABLE FOR INSPECTION AT TIME OF PURCHASE AND/OR CONDITIONS
# OF THIS TICKET AND ALSO (TO THE EXTENT THAT THEY ARE NOT INCONSISTENt
# WITH THE SELLERS CONDITIONS OF SALE) THE FOLLOWING:
# 
# 1: A CHANGE IN CONDITIONS OF THE PURCHASER DOES NOT ENTITLE THE PURCHASER
#    TO RETURN OR EXCHANGE TICKET.
# 
# 2: THE SELLER RESERVES THE RIGHT TO:
#    - ADD, WITHDRAW OR SUBSTITUTE ARTISTS
#    - VARY ADVERTISED PROBRAMMES, SEATING ARRANGEMENT AND AUDIENCE
#      CAPACITY , AND:
#    - REFUSE ADMISSION WITH REASONABLE CAUSE
#
# 3: CAMERAS AND TAPE RECORDERS MAY NOT BE PERMITTED. LATE ARRIVALS MAY
#    RESULT IN NON-ADMITTANCE UNTIL A SUITABLE BREAK IN PERFORMANCE. THE
#    SELLER REQUESTS THAT ALL PAGERS AND MOBILE PHONES BE TURNED OFF BEFORE
#    ENTRY.
#
# 4: IF AN OUTDOOR PERFORMANCE IS CANCELLED DUE TO ADVERSE WEATHER OR ANy
#    OTHER CAUSE REASONABLY BEYOND THE SELLERS CONTROL, THERE IS NO RIGHT 
#    TO A REFUND OR EXCHANGE, AND THE SELLER IS NOT OBLIGED TO ARRANGE A 
#    SUBSTITUTE SERVICE, EVENT OR PERFORMANCE
#
# StreetLevel Communications
#
#            support@slc.com.au
#            ph: +1-650-483-0998
#
###############################################################################

#### work out where i am
# these 3 varables can then be used to find config files
# and keep the code portable

use FindBin qw($Bin $Script);
my ($BASE,$NAME)=($Bin,$Script) ;

#   $Id: ibcli,v 1.15 2004/08/01 19:34:03 horne Exp $
my $REV = "\n$BASE/$NAME" . '
$Revision: 1.15 $
$Date: 2004/08/01 19:34:03 $
';
$REV =~ s/\$//g;


# Perl CGI common chunks
#
use strict ;
no strict "refs" ;
use Getopt::Long ;
use Text::Abbrev ;

# include infoblox , find the path ???
# this is done at compile time so we need to use a method...
use lib "$FindBin::Bin";
use InfoBloxDNS ;

######################
#
# define some globals
#
my $DEBUG = 0 ;
my $CLI = 0 ;
my $CONN_STRING = "!" ;

my $SERVER_ID ;
my $SERVER_PASS ;
my $CONNECTED ;
my $CONFIG ;
my $MAKE ;
my $LIST_COMM ;
my $GET_VERSION ;
my @LIST_BRANCH ;

my $GOOD_COMMAND ;
my $LINE ;

my $SAVE_HIST ;
my @CLIST ;
my @WORDS ;
my @P_ARGS ;
my @HISTORY ;

my $PROMPT ;

#
# WTF is P_ARGS ??
#
# Well, grasshopper, some subroutines need to know some of the earlier
# arguments, so we keep these in a stack and pass them around where
# necessary. it is a global because all sorts of subs will want to play
# with it...
#

#
#####################

# read the lines
# the datastructure is kinda nested, but the command set is still small
# enough to avoid some sort of lexical overhead subroutine

## NOTE - to make a better CLI version we should have a wrapper loop that
#  checks if you are coming in as a file or STD in. The primary loop in
#  either case should pass to the actual arg parser
#

# optional args
# -f <config file>
# -s <server>
# -p <password>
# -d <debug level>
# -m make a script

my $S_PASS ;
my $S_ID ;

GetOptions(
      "s=s" => \$S_ID , 
      "p=s" => \$S_PASS ,
      "f=s" => \$CONFIG ,
      "d=s" => \$DEBUG ,
      "m+"  => \$MAKE ,
      "t+"  => \$LIST_COMM ,
      "v|V"   => \$GET_VERSION ,
   );

   #

if ( $GET_VERSION ) {
   &show_version ;
   exit 0 ;
}

# set the first level command set
my %commands = ( 
            'history' => 'show_history',
            'commit' => 'commit',
            'connect' => 'connect',
            'disconnect' => 'disconnect',
            'download' => 'download_commands',
            'upload' => 'upload_commands',
            'set' => 'set_commands' ,
            'configure' => 'set_commands' ,
            'show' => 'show_commands' ,
            'get' => 'show_commands' ,
            'exit' => 'do_exit' ,
            'quit' => 'do_exit' ,
) ;

# catch fools who forget to do a '-f'
if ( @ARGV ) { $CONFIG = shift ; }

# if we were called with a "-c" we are dumping the command parsing tree
if ( $LIST_COMM ) {
   print "$REV\n";

   &walk_tree(%commands) ;
   exit ;
}

# are we in make mode ?
if ( $MAKE ) { &script_header }

# check if we need to do any initial conections
# temp vars to avoid a clobbering problem
if ( $S_ID ) { &add_server($S_ID) }
else         { $PROMPT = "no server > " ; }

if ( $S_PASS ) { &add_pass($S_PASS) }

#
# are we interactive or in batch mode ?
#
if ( ! $CONFIG ) {
   print "CLI version\n";
   $CLI = 1 ;
   # unflush the buffer
   $| = 1 ;

   # set initial prompt
   &print_prompt ;
}

if ( $CONFIG ) { 
   # make 'while(<>)' still work...
   push @ARGV , $CONFIG  ;
}

#
# time to read commands, line at a time...
#

while (<>) {

   # strip blanks, comments etc
   if ( /^\s*#/ ) { 
      if ( $MAKE ) { print $_ ; }
         &print_prompt ; 
         next ; 
   } ;

   if ( /^\s*$/ ) { 
      if ( $MAKE ) { print $_ ; }
         &print_prompt ; 
         next ; 
   } ;

   $GOOD_COMMAND = 1 ;
   $SAVE_HIST = "" ;

   chomp ;

   #
   # Pattern matching, we want 'fuzzy' matches but only in the form of
   # abbreviations, if the command is 'server', 'ser' and 'serv' should
   # match but not 'serf'. FORTUNATELY, there seems to be a perlmodule
   # for this. ( Text::Abbrev )
   #
   # and the nice thing is that we can build up a hash
   # of command to subroutine matching, the abbrev code will
   # find the right command to call, then we can pass the WHOLE line to
   # the required routine.
   #
   # HOWEVER, the additional args at the end of the line will break the
   # abbrev match, so we still need to eat the line - 1 word at a time
   # and branch apropriately
   #
   # if the abbrev gets an ambiguous match, we return '0'...

   # we have a problem in that if we get a match on the first arg we are
   # still in 2 states
   #  - execute
   #  - check for more args
   #  - check for more commands
   #
   # after the branching we still keep track of :
   #  - the original command (for history)
   #  - the optional args
   # and IF WE GET A MATCH, we say the command is good and THEN execute


   # SO break the commandline into components
   #
   # @WORDS is a global, because we want to keep eating the array
   # regardless of what routine we are in. At the end of the parsing, we
   # should end up with the command ($SAVE_HIST) and the args (@WORDS)
   #
   # SO, if there are more args that need to be checked, the subroutine
   # to call should be a simple one that just resets $commands and makes
   # another call to 'shift_Arg'
   #
   $LINE = $_ ;
   @WORDS  = split /\s+/ ;
   @P_ARGS = () ;
   my $arg = shift @WORDS ;

   &shift_arg($arg,%commands);

   # history - if kosher
   # ( done at the end, after all other line processing... )
   if ( $GOOD_COMMAND ) {
      &addhistory($SAVE_HIST , @WORDS);
   }

   # lastly - the prompt
   &print_prompt ;
   
}

# just in case
&do_exit ;

################################################################

# 
# EXIT
#
sub do_exit {
    $LINE = "exit" ;
    if ( $CONNECTED ) { 
#        &commit ;
       &disconnect ;
    }

    if ( $MAKE ) { &script_footer }

    exit ;
}

#
# shift arg, once we've set up a new %commands hash
# we just want to call shift_arg to do the rest of the processing
#
# THIS is the guts of the command line parser, for each ARG in a line
# shift_arg looks at this word, does an apprev match, and if it is ok
# then calles the hashed subroutine.
#
# The nice thing about this is that the subroutines can either be end
# points (do this feature) or subroutines that set possibilities for the
# next arg value. This has more power then putting ALL the commands in a
# treed hash since we can jump around tween subs as much as we like
#
# [ you just have to keep track of the parser subroutines :-) ]
#
sub shift_arg {

   my ( $arg , %commands ) = @_ ;

   if ( $LIST_COMM ) { &walk_tree(%commands) ; return ; }


   @CLIST = sort keys %commands ;
   my %clookup = abbrev ( @CLIST ) ;

   # $full_comm does the abbreviation lookup and gets the
   # ACTUAL full comand name, or returns '0' so the expansion
   # is automatic, but sometimes full_comm can be a wildcard
   # so we check the existence of the subroutine to call instead.
   #
   # and we hack history accordingly
   
   my $full_comm = $clookup{ lc($arg) };
   &debug (4,"shift: h($SAVE_HIST) arg($arg) com[$full_comm]");

   # we set $call_sub , coz we risk re-setting $full_com ;
   my $call_sub = $commands{$full_comm} ;
   if ( $call_sub ) {
      &debug (4,"shift: sub($call_sub)");

      # catch wildcards...
      if ( ! $full_comm ) { 
         $full_comm = $arg  ;
         push @P_ARGS , $arg ;
      }
      $SAVE_HIST .= "$full_comm " ;

      &rd_line($call_sub) ;
   }
   else {
      &missing_arg(@CLIST)  ;
   }
}

# parse a line, this is called EVERYTIME we press <cr> so we can
# do things like print the prompt
# we abstract this to keep it in one place
#
sub rd_line {

    # we're passed :
    #  the subroutine to call
    #  the subroutine arguments
    #
    #  if we are eating more of the args, we append to savehistory...

    my ($command) = @_ ;

    &debug (4,"rd_line b: c[$command] h[$SAVE_HIST] , go_c [$GOOD_COMMAND]");
    &debug (4,"           p_args[@P_ARGS] words[@WORDS]");

    # call the command (and any prev args...)
    &$command(@P_ARGS,@WORDS);

    #
    &debug (4,"rd_line a: c[$command] h[$SAVE_HIST] , go_c [$GOOD_COMMAND]");
    &debug (4,"           p_args[@P_ARGS] words[@WORDS]");


}

sub walk_tree {
   my ( %commands ) = @_ ;

   foreach my $cmd ( sort keys %commands ) {
      my $call = $commands{$cmd};

      &debug(1,"arg : $cmd => ($call) [@LIST_BRANCH] [$cmd]");

      # a few sanity checks
      if ( $cmd eq "" ) { $cmd = "<zone>" ; }
      if ( $cmd eq "set" ) { next ; }
      if ( $cmd eq "remove" ) { next ; }

      push ( @LIST_BRANCH , $cmd ) ;

      if ( $call =~ /commands/ ) {
         &$call("foo","foo");
      }

      if ( @LIST_BRANCH ) { print "@LIST_BRANCH\n"; }

      pop @LIST_BRANCH ;
   }
}


# PARSER : show xxx
sub show_commands {
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                'zone' => 'show_zone',
                'network' => 'show_network',
                'host' => 'show_host',
                'version' => 'show_version',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : download xxx
sub download_commands {
   &debug (4,"sub = download_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "database" => 'get_database',
                "logs" => 'get_logs',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : upload xxx
sub upload_commands {
   &debug (4,"sub = download_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "database" => 'put_database',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set xxx
#
# note, 'conf dhcp' (for the present) == 'conf network'
sub set_commands {
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                'debug' => 'set_debug',
                'server' => 'add_server',
                'system' => 'system_comands',
                'password' => 'add_pass',
                'zone' => 'zone_commands',
                'network' => 'network_commands',
                'dhcp' => 'network_commands',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : set system xxx
sub system_comands {
   &debug (4,"sub = zone_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "default" => 'erase_data',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set zone xxx
sub zone_commands {
   &debug (4,"sub = zone_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_zone',
                "delete" => 'remove_zone',
                "remove" => 'remove_zone',
                "" => 'mod_zone_commands',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network xxx
sub network_commands {
   &debug (4,"sub = network_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_network',
                "delete" => 'remove_network',
                "remove" => 'remove_network',
                "global" => 'mod_global_dhcp',
                "" => 'set_network_commands',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network <n.n.n.n/mm> xxx
sub set_network_commands {
   &debug (4,"sub = set_net ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "split" => 'split_network',
                "add" => 'add_to_network_commands',
                "remove" => 'delete_from_network_commands',
                "delete" => 'delete_from_network_commands',
                "modify" => 'modify_network',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network <n.n.n.n/mm> add xxx
sub add_to_network_commands {
   &debug (4,"sub = add_to_network ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "address" => 'add_network_ptr',
                "ptr" => 'add_network_ptr',
                "fixed" => 'add_fixed_address',
                "network" => 'add_sub_network',
                "range" => 'add_dhdprange',
                "dhcprange" => 'add_dhdprange',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network <n.n.n.n/mm> delete xxx
sub delete_from_network_commands {
   &debug (4,"sub = delete_from_network ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "address" => 'del_network_ptr',
                "range" => 'del_dhcprange',
                "dhcprange" => 'del_dhcprange',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set zone <zone> xxx
sub mod_zone_commands {
   &debug (4,"sub = mod_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_to_zone_commands',
                "delete" => 'remove_from_zone_commands',
                "remove" => 'remove_from_zone_commands',
                "import" => 'import_to_zone',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : set zone <zone> add xxx
sub add_to_zone_commands {
   &debug (4,"sub = add_to_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "host" => 'add_host',
                "cname" => 'add_cname',
                "onewayhost" => 'add_one_host',
                "bulkhost"   => 'add_bulkhost',
                "nameserver" => 'NOT_READY',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set zone <zone> remove xxx
sub remove_from_zone_commands {
   &debug (4,"sub = remove_from_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "host" => 'remove_host',
                "cname" => 'remove_cname',
                "bulkhost" => 'remove_bulkhost',
                "nameserver" => 'NOT_READY',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : default
sub NOT_READY {
    print "***-  NOT IMPLEMENTED\n";
}

###########################################
#
# here endith the arg parsers
#
###########################################

#
# call an infoblox function, ONLY if we're connected
#
sub do_ib_func {
    my ($function) = @_ ;
    &debug (1,"do_ib_func [$function]");

    if ( $MAKE ) {
       print "\nprint '" . $function . "'.\"\\n\";\n" ;
       print "$function ;\n" ;
    }
    else {

       if ( $CONNECTED ) {
          eval $function ;
       }
       else {
          &err_print("CANNOT EXECUTE - no connection is in place");
       }

    }
}


###########################################
#
# actual ib_ functions.
#
###########################################

sub get_logs {
    #
    # download the logs to the current dir
    #
    my ( $dest ) = @_ ;
#     chomp($dest = `pwd`);
#     $dest="$dest/IB_files";
    if ( ! $dest ) {
       &missing_arg("<dir>")  ;
       return ;
    }

    &err_print("DOWNLOADING ALL LOGS data to $dest ...");
    if ( ! -d $dest ) { mkdir($dest,0755); }

    my $function = "ib_export_logs(\"$dest\")";
    &do_ib_func($function);

    &err_print("DONE ");

}

sub get_database {
    #
    # download the database to the current dir
    #
    my ( $dest ) = @_ ;
#     chomp($dest = `pwd`);
#     $dest="$dest/IB_files";
    if ( ! $dest ) {
       &missing_arg("<dir>")  ;
       return ;
    }

    &err_print("DOWNLOADING ALL DATABASE data to $dest ...");
    if ( ! -d $dest ) { mkdir($dest,0755); }

    my $function = "ib_export_database(\"$dest\")";
    &do_ib_func($function);

    &err_print("DONE ");

}

sub put_database {
    #
    # upload the database from the spec'd dir
    #
    my ( $dest ) = @_ ;
    if ( ! $dest ) {
       &missing_arg("<dir>")  ;
       return ;
    }

    &err_print("UPLOADING ALL DATABASE data from $dest ...");
    if ( ! -d $dest ) { 
       &err_print("NO such location");
       return ;
    }

    my $function = "ib_import_database(\"$dest\")";
    &do_ib_func($function);

    &err_print("DONE ");

    # do an implicit disconnect
    &disconnect ;

}
sub get_database {
    #
    # download the database to the current dir
    #
    my ( $dest ) = @_ ;
#     chomp($dest = `pwd`);
#     $dest="$dest/IB_files";
    if ( ! $dest ) {
       &missing_arg("<dir>")  ;
       return ;
    }

    &err_print("DOWNLOADING ALL DATABASE data to $dest ...");
    if ( ! -d $dest ) { mkdir($dest,0755); }

    my $function = "ib_export_database(\"$dest\")";
    &do_ib_func($function);

    &err_print("DONE ");

}

sub erase_data {

    &err_print("ERASING ALL DATABASE data ...");

    # we may want an 'are you sure here...'
    my $function = "ib_erase_dns_data()";
    &do_ib_func($function);

    &err_print("DONE ");
}

sub import_to_zone {
    my ( $zone , $ip , $opt ) = @_ ;
    if ( ! $ip ) {
       &missing_arg("<ip> [noptr]")  ;
       return ;
    }

    &debug (2,"importing z($zone) ip($ip) ");

    my $function = "ib_import_zone(\"$zone\",\"$ip\",\"$opt\")";
    &do_ib_func($function);

}

sub add_host {
    my ( $zone , $host , $ip , $comment ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"addh n($name) n($ip) c($comment)");

    my $function = "ib_insert_host(\"$name\",\"$ip\",\"$comment\")";
    &do_ib_func($function);

}

sub remove_host {
    my ( $zone , $host ) = @_ ;
    if ( ! $host ) {
       &missing_arg("<host>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"addh n($name) ");

    my $function = "ib_remove_host(\"$name\")";
    &do_ib_func($function);

}

sub add_one_host {
    my ( $zone , $host , $ip ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"add1h n($name) n($ip) ");

    my $function = "ib_insert_oneway_host(\"$name\",\"$ip\")";
    &do_ib_func($function);

}

sub add_bulkhost {
    my ( $zone , $prefix , $fip , $nip ) = @_ ;

    if ( $zone and $prefix and $fip and $nip ) {

       &debug (2,"addbh n($zone) p($prefix) n($fip,$nip) ");

       my $func="ib_insert_bulk_host(\"$zone\",\"$prefix\",\"$fip\",\"$nip\")";
       &do_ib_func($func);
    }
    else {
       &missing_arg("<prefix> <start_ip> <end_ip>")  ;
       return ;
    }

}

sub remove_bulkhost {
    my ( $zone , $prefix , $fip , $nip ) = @_ ;

    if ( $zone and $prefix and $fip and $nip ) {

       &debug (2,"addbh n($zone) p($prefix) n($fip,$nip) ");

       my $func="ib_remove_bulk_host(\"$zone\",\"$prefix\",\"$fip\",\"$nip\")";
       &do_ib_func($func);
    }
    else {
       &missing_arg("<prefix> <start_ip> <end_ip>")  ;
       return ;
    }
}

sub add_cname {
    my ( $zone , $cname , $host ) = @_ ;
    if ( (! $host ) or ( ! $cname ) ) {
       &missing_arg("<cname> <host>")  ;
       return ;
    }
    my $fcname="$cname.$zone";

    &debug (2,"addh n($fcname) n($host) ");

    my $function = "ib_insert_cname(\"$fcname\",\"$host\")";
    &do_ib_func($function);

}

sub remove_cname {
    my ( $zone , $host ) = @_ ;
    if ( ! $host ) {
       &missing_arg("<host>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"addh n($name) ");

    my $function = "ib_remove_cname(\"$name\")";
    &do_ib_func($function);

}

sub add_zone {
    my ( $zone , $type , @type_opts) = @_ ;

    if ( ! $zone ) { &missing_arg("<zone>") ; return }
    my $etype ;

    #
    # etype is the expanded version of whatever we typed for $type
    #
    if ( $type ) {
       my @opts = ( "authoritative","nonauthoritative","delegated","secondary");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "authoritative" ) ; }

    # format the type opts
    my $opt_str ;
    if ( @type_opts ) {
       foreach my $oo ( @type_opts ) {
               $opt_str .= ",\"$oo\"";
       }
    }
    &debug (2,"addz n($zone) a($etype) oo($opt_str)");


    my $function = "ib_insert_zone(\"$zone\",\"$etype\"$opt_str)";

    my @args = ( $zone , $etype , $opt_str ) ;

    &do_ib_func($function);

}

sub remove_zone {
    my ( $zone ) = @_ ;
    if ( ! $zone ) { &missing_arg("<zone>") ; return }
    &debug (2,"remz n($zone)");

    my $function = "ib_remove_zone(\"$zone\")";
    &do_ib_func($function);

}

sub mod_global_dhcp {
    my ( $opt , $val , @extra ) = @_ ;
    if ( (! $val ) or ( ! $opt ) ) {
       &missing_arg("<option> <value>")  ;
       return ;
    }
    # clean up any custom option args
    my $custom= join ( '","' , @extra );

    # clean some options
    $val=~s/["']*//g ;
    $custom=~s/""/"/g ;

    &debug (2,"modglob o($opt) v($val) c($custom)");

    #
    # GLOBAL custom props have to ALL be on one line, or stuff gets dropped
    #
    # ib_modify_global_dhcp_options
    #         ("10.34.8.0","255.255.252.0","router","10.34.8.1");
    # OR
    # ib_modify_global_dhcp_options
    #         ("10.54.0.0","255.255.252.0","custom_option",
    #           "netbios-name-servers","","10.23.60.20");
    my $comm="ib_modify_global_dhcp_options(";

    my $func="$comm\"$opt\",\"$val\")";
    if ( $opt eq "custom_option" ) {
       $func="$comm\"custom_option\",\"$val\",\"$custom\")";
    }
       

    &do_ib_func($func);

}

sub modify_network {
    my ( $parent , $opt , $val , @extra ) = @_ ;
    if ( (! $val ) or ( ! $opt ) ) {
       &missing_arg("<option> <value>")  ;
       return ;
    }
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    # some custom options look like arrays..
    my $custom = "@extra";

    # clean some options
    $val=~s/["']*//g ;
    $custom=~s/["']*//g ;

    &debug (2,"modnet n($net) m($mask) o($opt) v($val) c($custom)");

    # ib_modify_network_dhcp_options
    #         ("10.34.8.0","255.255.252.0","router","10.34.8.1");
    # OR
    # ib_modify_network_dhcp_options
    #         ("10.54.0.0","255.255.252.0","custom_option",
    #           "netbios-name-servers","","10.23.60.20");
    my $comm="ib_modify_network_dhcp_options(\"$net\",\"$mask\"";

    my $func="$comm,\"$opt\",\"$val\")";
    if ( $opt eq "custom_option" ) {
       $func="$comm,\"custom_option\",\"$val\",\"\",\"$custom\")";
    }
       

    &do_ib_func($func);

}

sub add_fixed_address {
    my ( $parent , $ip , $mac , $comment ) = @_ ;
    if ( (! $ip ) or ( ! $mac ) ) {
       &missing_arg("<mac> <ip>")  ;
       return ;
    }
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    &debug (2,"addnp n($net) m($mask) ip($ip) mac($mac) c($comment)");

    # ib_insert_fixed_address(10.0.0.0 , 255.255.0.0 , 10.2.3.4 , foo.com );
    my $comm="ib_insert_fixed_address(\"$net\",\"$mask\"";
    my $func="$comm,\"$mac\",\"$ip\")";

    if ($comment) {
       $func="$comm,\"$ip\",\"$mac\",\"comment\",\"$comment\")";
    }
    &do_ib_func($func);

}

sub add_network_ptr {
    my ( $parent , $ip , $host , $comment ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<ip> <host>")  ;
       return ;
    }
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    &debug (2,"addnp n($net) m($mask) ip($ip) h($host)");

    # ib_insert_oneway_ptr(10.0.0.0 , 255.255.0.0 , 10.2.3.4 , foo.com );
    my $comm="ib_insert_oneway_ptr(\"$net\",\"$mask\"";
    my $func="$comm,\"$ip\",\"$host\",\"$comment\")";
    &do_ib_func($func);

}

sub add_dhdprange {
    my ( $parent , $fip , $lip , $type , @type_opts ) = @_ ;
    if ( (! $fip ) or ( ! $lip ) ) {
       &missing_arg("<first_ip> <last_ip>")  ;
       return ;
    }
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    # parse optional extra arguments

    my $etype ;
    if ( $type ) {
       my @opts = ( "peer_association");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype || ! @type_opts ) { 
          &missing_arg(@opts , "<name>" );
          return ;
       }
    }

    # format the type opts
    my $o_str ;
       $o_str .= ",\"$etype\"";
    if ( @type_opts ) {
       foreach my $oo ( @type_opts ) {
               $o_str .= ",\"$oo\"";
       }
    }

    &debug (2,"addrng n($net) m($mask) ip($fip) h($lip) oo($o_str)");

    # ib_insert_dhcp_range(10.0.0.0 , 255.255.0.0 , 10.2.3.4 , 10.2.3.50 );
    my $func="ib_insert_dhcp_range(\"$net\",\"$mask\",\"$fip\",\"$lip\"$o_str)";
    &do_ib_func($func);

}

sub add_network {
    my ( $netarg , $type , @type_opts) = @_ ;
    if ( ! $netarg ) { &missing_arg("<n.n.n.n/mm>") ; return }
    my $etype ;

    #
    # etype is the expanded version of whatever we typed for $type
    # [ I've used this twice now, can i make it a sub ?? ]
    #
    if ( $type ) {
       my @opts = ( "nonauthoritative","authoritative","delegated","secondary");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "authoritative" ) ; }

    # format the type opts
    my $opt_str ;
       $opt_str .= ",\"$etype\"";
    if ( @type_opts ) {
       foreach my $oo ( @type_opts ) {
               $opt_str .= ",\"$oo\"";
       }
    }

    #
    # use the /cidr to find the mask etc etc
    #
    my ($net,$cidr) = split(/\//,$netarg);
    my $mask = &cidrfind($cidr) ;

    &debug (2,"addn n($net) c($cidr) m($mask) oo($opt_str)");

    my $bn = "0.0.0.0" ;

    # add net now requires a bogus parent
    # not that this will add it at the root level. you need to
    # use add subnet for anything else
    my $func="ib_insert_network(\"$net\",\"$mask\",\"$bn\",\"$bn\"$opt_str)";
    &do_ib_func($func);

}

sub add_sub_network {
    my ( $parg , $netarg , $type ) = @_ ;
    if ( ! $netarg ) { &missing_arg("<n.n.n.n/mm>") ; return }
    my $etype ;

    #
    # etype is the expanded version of whatever we typed for $type
    # [ I've used this thrice now, can i make it a sub ?? ]
    #
    if ( $type ) {
       my @opts = ( "nonauthoritative","authoritative","delegated","secondary");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "authoritative" ) ; }

    #
    # use the /cidr to find the mask etc etc
    #
    my ($net,$cidr) = split(/\//,$netarg);
    my ($pnet,$pcidr) = split(/\//,$parg);
    my $mask = &cidrfind($cidr) ;
    my $pmask = &cidrfind($pcidr) ;

    &debug (2,"addsn pn($pnet) pc($pmask) n($net) c($cidr) m($mask) ");

    # add net now requires a bogus parent
    # not that this will add it at the root level. you need to
    # use add subnet for anything else
    my $func="ib_insert_network(\"$net\",\"$mask\",\"$pnet\",\"$pmask\",\"$etype\")";
    &do_ib_func($func);

}
sub split_network {
    #
    # the second last arg of ib_split_network is a bitshift RELATIVE
    # to the original mask, so there is some math involved

    my($parent,$ncidr,$type) = @_ ;
    my($pnet,$pcidr)= split(/\//,$parent );
       $ncidr =~ s/\/// ;
    my $pmask = &cidrfind($pcidr);
    my $bitshift = $ncidr - $pcidr ;

    &debug (3,"split net [$pnet] [$pcidr] [$ncidr] ($bitshift)\n");
    &debug (2,"splitting network [$pnet , $pmask] to add [$bitshift] bits");

    # check for optional args...
    my $etype ;
    if ( $type ) {
       my @opts = ( "all","required");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "0" ) ; }
    if ( $etype eq "required" ) { $etype = "1" }
    if ( $etype eq "all" ) { $etype = "2" }

    # ib_split_network("10.0.0.0", "255.255.0.0", 8);
    my $func ;
    $func="ib_split_network(\"$pnet\", \"$pmask\", \"$bitshift\",\"$etype\")";
    &do_ib_func($func);

}

sub remove_network {
    my ( $netarg ) = @_ ;
    if ( ! $netarg ) { &missing_arg("<n.n.n.n/mm>") ; return }

    # use the /cidr to find the mask etc etc
    #
    my ($net,$cidr) = split(/\//,$netarg);
    my $mask = &cidrfind($cidr) ;

    &debug (2,"remn n($net) c($cidr) m($mask) ");

    my $func="ib_remove_network(\"$net\",\"$mask\")";
    &do_ib_func($func);

}

sub del_network_ptr {
    my ( $parent , $ip ) = @_ ;
    if ( ! $ip  ) {
       &missing_arg("<n.n.n.n/mm> <ip>")  ;
       return ;
    }
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    &debug (2,"remnp n($net) c($cidr) m($mask) ip($ip)");

    my $func="ib_remove_oneway_ptr(\"$net\",\"$mask\",\"$ip\")";
    &do_ib_func($func);

}


sub del_dhcprange {
    my ( $parent , $fip , $lip ) = @_ ;
    if ( ( ! $fip ) or ( ! $lip )  ) {
       &missing_arg("<first_ip> <last_ip>")  ;
       return ;
    }
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    &debug (2,"remrng n($net) m($mask) ip($fip) ip($lip)");

    my $func="ib_remove_dhcp_range(\"$net\",\"$mask\",\"$fip\",\"$lip\")";
    &do_ib_func($func);

}

##########################################################
#
# An important thing to note :
#
# what happens if you issue commands and you do NOT have a connection in
# place yet ? do we rely on the infoblox module to generate errors or
# should we assume the worst ? we don't want to re-invent the wheel
# here...
#
#


###########################################3
#

sub missing_arg {
    &debug(4,"MISS ARG call");
    if ( $CLI ) {
       print "Next possible completions : \n\t@_\n";
    }
    else {
       &err_print("UNRECOGNISED command");
    }
    $GOOD_COMMAND = 0 ;
}

#
# PROMPT
#
sub print_prompt {
    if ( $CLI ) {
       print "[$DEBUG] $CONN_STRING $PROMPT" ;
    }
}

#
# ERRORS
#
sub err_print {
    if ( $CLI ) {
       print "@_\n" ;
    }
    else {
       # comment if making..
       if ( $MAKE ) { print "# " }
       print "@_ : $LINE\n";
    }
}

#
# SET DEBUG
#
sub set_debug {

    if ( "@_" =~ /\d+/ ) {
       $DEBUG = shift @_ ;
    }
    else {
       &missing_arg("$SAVE_HIST <level>");
    }
}

#
# SHOW THE HISTORY:
#

sub addhistory {
    my ($line) = "@_" ;

    #cleanup spacing
    $line =~ s/^\s*//;
    $line =~ s/\s+/ /g;
    $line =~ tr/A-Z/a-z/;

    push @HISTORY , $line ;

}

sub show_history {
    my $lineno = 1 ;

    # walk through the history array and print what we input
    print "\n-- COMMAND HISTORY --\n";
    foreach my $command ( @HISTORY ) {
       print "-- $lineno\t$command\n";
       $lineno ++ ;
    }
    print "\n";

#     $GOOD_COMMAND = 1 ;

}

#
# SERVER CONNECTION STUFF.....
#

sub add_server {
    my ($server,$pass) = @_ ;
    # save the server id and see if we have enough info to connect
    # password can be passed on this line, if not specified, assume
    # no password
    

    if ($server) {
       # if we're already connected, sput an error
       if ( ! $CONNECTED ) {
          &debug (2,"adding server [$server]");
          $SERVER_ID = $server ;

          $PROMPT = "$SERVER_ID > " ;

          # when you specify a new server, you need to re-set the
          # password
          if ( ! $pass ) {
             # this is a NON DNSone, DIG only
             # unset the password
             $SERVER_PASS = "" ;
          }
          else {
             $SERVER_PASS = $pass ;
          }
          &debug (2,"adding passwd [$pass]");

          &connect ;
       }
       else {
          &err_print("SERVER :: already connected");
       }
    }
    else {
       &missing_arg("$SAVE_HIST <server>");
    }
}

sub add_pass {
    my ($arg) = @_ ;

    if ($arg) {
       # save the server password and see if we have enough info to connect
       &debug (2,"adding passwd [$arg]");
       $SERVER_PASS = $arg ;
       &connect ;
    }
    else {
       &missing_arg("$SAVE_HIST <password>");
    }


}

sub connect {
    # make a connection
    # unless we have both server and password,  die

    if ( ! $MAKE ) {

      if ( $SERVER_ID && $SERVER_PASS ) {
         if ( $CONNECTED ) {
            &err_print("SERVER :: already connected");
            return ;
         }

         &debug (1,"connecting to server [$SERVER_ID] [$SERVER_PASS]");

         &err_print("SERVER :: connecting");

         ib_open_connection($SERVER_ID,$SERVER_PASS) ;

         $PROMPT = "$SERVER_ID > " ;
         $CONN_STRING = "*" ;
   
         $CONNECTED = 1 ;


      }
      else {
         &err_print ("CANNOT CONNECT :: no server or password supplied");
         &debug (3,"NOOP - incomplete details for server connection");
      }
    }

}

sub disconnect {
    if ( $CONNECTED ) {
#        &commit ;
       &err_print ( "SERVER :: disconnecting");
       ib_close_connection();
       $CONNECTED = 0 ;

       $PROMPT = "no server > " ;
    }
    else {
       &err_print ( "CANNOT DISCONNECT - no connection is in place");
    }

}

sub commit {

    #
    # ib_update_server doesn;t really commit
    #
#     &err_print ( "COMMIT -  NOT WORKING");

    if ( $CONNECTED ) {
       print "SERVER :: Committing Changes .. ";

       ib_close_connection();
       sleep 3 ;
       ib_open_connection($SERVER_ID,$SERVER_PASS) ;

#        ib_update_server();

       print "DONE.\n";

       $CONN_STRING = " " ;
    }
    else {
       &err_print ("CANNOT COMMIT - no connection is in place");
    }
}

#
# DIGS AND GET ROUTINES
#

sub show_host {
    my ($query,$verbose) = @_ ;

    # use dig...

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <host> (verbose)") ;
       return (0) ;
    }

    &debug (2,"showing zone [@_]");

    &do_dig($SERVER_ID,$query,$verbose);


}

sub show_zone {
    my ($query,$type,$verbose) = @_ ;

    # use dig...
    # forget about the verbose option for now, dig can do that directly.

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <zone> (type)") ;
       return (0) ;
    }

    &debug (2,"showing zone [@_]");

    if ( ! $type ) { $type = "SOA" }

    &do_dig($SERVER_ID,$query,$type,$verbose);
}

sub show_network {
    my ($query,$type,$verbose) = @_ ;

    # use dig...
    # forget about the verbose option for now, dig can do that directly.

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <network> (type)") ;
       return (0) ;
    }

    &debug (2,"showing network [@_]");

    if ( ! $type ) { $type = "SOA" }

    # force a revrse lookup
    $verbose = "reverse" ;
    &do_dig($SERVER_ID,$query,$type,$verbose);
}

sub do_dig {
    # use a 'dig' to get zone data.
#     my $DIG = '/usr/bin/dig' ;
    my $DIG = 'dig' ;
    my $DIGOPTS = '+multiline +nostat +nocmd +norecur';
    my $TERSEOPTS = '+noquestion +noauthority +noadditional +nocomments';
    my $REVOPTS = '+noquestion +noadditional +nocomments';

    my $V_DIG = "$DIG $DIGOPTS";
    my $T_DIG = "$DIG $DIGOPTS $TERSEOPTS";
    my $R_DIG = "$DIG $DIGOPTS $REVOPTS";

    # so we pass args to dig to work out what type of dig to do
    &debug (3,"dig reqest =  [@_]");
    my ($server,$query,$type,$verbose) = @_ ;

    my $COMM ;

    # verbose is disabled for now, i'll use it for something else.
    if ($verbose) {
       $COMM = "$V_DIG \@$server $query $type";
       if ( $verbose eq "reverse" ) {
          $COMM = "$R_DIG \@$server -x $query $type";
       }
    }
    else {
       $COMM = "$T_DIG \@$server $query $type";
    }

    &debug (2,"dig comm =  [$COMM]");

#     if ( ! $CONNECTED ) {
#        &err_print( "CANNOT dig - no connection is in place");
#     }
#     else {
#        print "\n";
#        system("$COMM");
#        print "\n";
#     }

    print "\n";
    system("$COMM");
    print "\n";

}

# ib_open_connection(\$SERVER_ID,\$SERVER_PASS);
sub script_header {

    print "#!/usr/bin/perl
#
# AUTOGENERATED from $NAME 
#
use InfoBloxDNS ;

ib_open_connection(\"$S_ID\",\"$S_PASS\");

\n";
}

sub script_footer {

    print "
ib_close_connection();

exit ; \n";

}

sub show_version {
    print "$REV\n";
}


############################################3

sub cidrfind {
    # match up netmasks to cidr syntax
    # YES, i /KNOW/ i can do this using math, but this took me
    # 20 seconds with cut and paste and it works, so move along
    # there's nothing to see here.
    #  (besides, a hash lookup is probably faster)
    my ($cidr) = @_ ;
    my %mlook = (
       8 =>  '255.0.0.0' ,
       9 =>  '255.128.0.0' ,
       10 => '255.192.0.0' ,
       11 => '255.224.0.0' ,
       12 => '255.240.0.0' ,
       13 => '255.248.0.0' ,
       14 => '255.252.0.0' ,
       15 => '255.254.0.0' ,
       16 => '255.255.0.0' ,
       17 => '255.255.128.0' ,
       18 => '255.255.192.0' ,
       19 => '255.255.224.0' ,
       20 => '255.255.240.0' ,
       21 => '255.255.248.0' ,
       22 => '255.255.252.0' ,
       23 => '255.255.254.0' ,
       24 => '255.255.255.0' ,
       25 => '255.255.255.128' ,
       26 => '255.255.255.192' ,
       27 => '255.255.255.224' ,
       28 => '255.255.255.240' ,
       29 => '255.255.255.248' ,
       30 => '255.255.255.252' ,
    ) ;

    &debug(3,"CIDR is [$cidr]");
    &debug(3,"MASK is [$mlook{$cidr}]");

    return($mlook{$cidr}) ;
}

sub debug {
    # we're passed a message and a level
    # if this level is <= the CURRENT DEBUG level 
    # we print the data
    my $level = shift @_ ;


    if ($level <= $DEBUG) {
        if ( $MAKE ) { print "# " ; }
        print "($level) DEBUG: @_\n";
    }

}

###########################################################

# $Log: ibcli,v $
# Revision 1.15  2004/08/01 19:34:03  horne
# Added 'peer_assoc' support for V2.5
#
# Revision 1.14  2004/06/16 20:19:46  horne
# added comments to ptrs
# added modify global dhcp opts
#   conf dhcp global
# added fixed addresses
# added modify network options
#   conf net x.x.x.x/mm modify opt value
# added non-auth networks
#
# Revision 1.13  2004/02/13 20:11:21  horne
# added the command lister
#
# Revision 1.12  2003/11/26 01:29:09  horne
# *** empty log message ***
#
# Revision 1.11  2003/11/06 07:31:28  horne
# server and password now live on the same commandline
# upload and download database
# import zone
# conf zone add now takes additional options
#
# the software now writes its own code
#
# Revision 1.10  2003/10/16 21:41:25  horne
# un hardcoede dig
# changed password syntax
# added a -V -v option (version)
# added download commands
#
# Revision 1.9  2003/09/24 01:43:08  horne
# added dhcp range stuff
# cleaned up the dig pre-processing
#
# Revision 1.8  2003/09/22 21:37:30  horne
# added prt functions
# cleaned up show network
#
# Revision 1.7  2003/09/22 19:24:30  horne
# *** empty log message ***
#
# Revision 1.6  2003/09/21 23:04:29  horne
# added ambiguous commands
# prints now wrapped for cli or batch
# batch commands now work
#
# Revision 1.5  2003/09/20 01:22:36  horne
# First full working version with the abstracted argument parser.
# there is still a lot of gumpf in here, but most of the repeatable code is
# now packed into subroutines
#
# Revision 1.4  2003/09/18 02:28:56  horne
# *** empty log message ***
#
# Revision 1.3  2003/09/16 23:17:25  horne
# *** empty log message ***
#
# Revision 1.2  2003/09/09 22:58:27  horne
# *** empty log message ***
#
# Revision 1.1  2003/08/11 23:31:57  horne
# INFOBLOX version, re-set the CVS counters
#
# Revision 1.9  2001/06/07 16:45:47  horne
# major rewrite of the arg parser - ripped out all the RE's to a much better
# process.
# delete commands disabled
#
# Revision 1.8  2001/05/31 05:28:15  horne
# *** empty log message ***
#
# Revision 1.7  2001/05/24 00:17:54  horne
# Added RE's to handle shortened commant words, not however that this is
# still buggy, typos, as long as they are unique will still work. thus
#  - password, p , pa , ps , pdfgt = password
# I need to find a better command parser
#
# Revision 1.6  2001/05/23 19:39:11  horne
# working version - waiting for updates from infoblox to see if they have
# changed the API syntax
#
# Revision 1.5  2001/05/19 06:08:13  horne
# iblox ready version, but no connections to servers work
#
# Revision 1.4  2001/05/19 04:59:19  horne
# All base commands are being parsed and netmasks are being applied.
# Now we need to hit the infoblox engine for real
#
# Revision 1.3  2001/05/19 03:43:45  horne
# added the DEBUG option before i started to drown in a lot of messy print
# statements
#
# Revision 1.2  2001/05/19 03:34:34  horne
# Basic version, config file parsing is functional.
#
# Revision 1.1  2001/05/19 03:33:56  horne
# *** empty log message ***
#
