#!/usr/bin/perl
#
# (c) Copyright: Geoff horne, SLC 2001-2003
#               All rights reserved
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. So there...
#
# THIS TICKET IS SOLD SUBJECT TO THE SELLERS CONDITIONS OF SALE OF COPY
# WHICH IS AVAILABLE FOR INSPECTION AT TIME OF PURCHASE AND/OR CONDITIONS
# OF THIS TICKET AND ALSO (TO THE EXTENT THAT THEY ARE NOT INCONSISTENt
# WITH THE SELLERS CONDITIONS OF SALE) THE FOLLOWING:
# 
# 1: A CHANGE IN CONDITIONS OF THE PURCHASER DOES NOT ENTITLE THE PURCHASER
#    TO RETURN OR EXCHANGE TICKET.
# 
# 2: THE SELLER RESERVES THE RIGHT TO:
#    - ADD, WITHDRAW OR SUBSTITUTE ARTISTS
#    - VARY ADVERTISED PROBRAMMES, SEATING ARRANGEMENT AND AUDIENCE
#      CAPACITY , AND:
#    - REFUSE ADMISSION WITH REASONABLE CAUSE
#
# 3: CAMERAS AND TAPE RECORDERS MAY NOT BE PERMITTED. LATE ARRIVALS MAY
#    RESULT IN NON-ADMITTANCE UNTIL A SUITABLE BREAK IN PERFORMANCE. THE
#    SELLER REQUESTS THAT ALL PAGERS AND MOBILE PHONES BE TURNED OFF BEFORE
#    ENTRY.
#
# 4: IF AN OUTDOOR PERFORMANCE IS CANCELLED DUE TO ADVERSE WEATHER OR ANy
#    OTHER CAUSE REASONABLY BEYOND THE SELLERS CONTROL, THERE IS NO RIGHT 
#    TO A REFUND OR EXCHANGE, AND THE SELLER IS NOT OBLIGED TO ARRANGE A 
#    SUBSTITUTE SERVICE, EVENT OR PERFORMANCE
#
# StreetLevel Communications
#
#            support@slc.com.au
#            ph: +1-650-483-0998
#
###############################################################################

#### work out where i am
# these 3 varables can then be used to find config files
# and keep the code portable

use FindBin qw($Bin $Script);
my ($BASE,$NAME)=($Bin,$Script) ;

#   $Id: ibcli,v 2.0 2004/11/03 19:58:48 horne Exp $
my $REV = "\n$BASE/$NAME" . '
$Revision: 2.0 $
$Date: 2004/11/03 19:58:48 $
';
$REV =~ s/\$//g;


# Perl CGI common chunks
#
use strict ;
no strict "refs" ;
use Getopt::Long ;
use Text::Abbrev ;

# include infoblox , find the path ???
# this is done at compile time so we need to use a method...
use lib "$FindBin::Bin";
use InfoBloxDNS ;
use Infoblox::RADIUSOne ;

######################
#
# define some globals
#
my $DNS_VER = 3 ;

my $DEBUG = 0 ;
my $CLI = 0 ;
my $CONN_STRING = "!" ;

my %CONN_INFO ;
my $PUB_SESS ;
my $PRI_SESS ;

my $CONNECTED ;
my $CONFIG ;
my $MAKE ;
my $LIST_COMM ;
my $GET_VERSION ;
my @LIST_BRANCH ;

my $GOOD_COMMAND ;
my $LINE ;

my $SAVE_HIST ;
my @CLIST ;
my @WORDS ;
my @P_ARGS ;
my @HISTORY ;

my $PROMPT ;

#
# WTF is P_ARGS ??
#
# Well, grasshopper, some subroutines need to know some of the earlier
# arguments, so we keep these in a stack and pass them around where
# necessary. it is a global because all sorts of subs will want to play
# with it...
#

#
#####################

# read the lines
# the datastructure is kinda nested, but the command set is still small
# enough to avoid some sort of lexical overhead subroutine

## NOTE - to make a better CLI version we should have a wrapper loop that
#  checks if you are coming in as a file or STD in. The primary loop in
#  either case should pass to the actual arg parser
#

# optional args
# -f <config file>
# -s <server>
# -p <password>
# -d <debug level>
# -m make a script

my $S_ID ;
my $S_USER ;
my $S_PASS ;

GetOptions(
      "s=s" => \$S_ID , 
      "p=s" => \$S_PASS ,
      "u=s" => \$S_USER ,
      "f=s" => \$CONFIG ,
      "d=s" => \$DEBUG ,
      "l=s" => \$DNS_VER ,
      "m+"  => \$MAKE ,
      "t+"  => \$LIST_COMM ,
      "v|V"   => \$GET_VERSION ,
   );

   #

if ( $GET_VERSION ) {
   &show_version ;
   exit 0 ;
}

# set the first level command set
my %commands = ( 
            'history' => 'show_history',
            'commit' => 'commit',
            'connect' => 'connect',
            'disconnect' => 'disconnect',
            'download' => 'download_commands',
#             'upload' => 'upload_commands',
            'set' => 'set_commands' ,
            'configure' => 'set_commands' ,
            'show' => 'show_commands' ,
            'get' => 'show_commands' ,
            'exit' => 'do_exit' ,
            'quit' => 'do_exit' ,
) ;

# catch fools who forget to do a '-f'
if ( @ARGV ) { $CONFIG = shift ; }

# if we were called with a "-c" we are dumping the command parsing tree
if ( $LIST_COMM ) {
   print "$REV\n";

   &walk_tree(%commands) ;
   exit ;
}

# are we in make mode ?
if ( $MAKE ) { &script_header }

&err_print("Using Version [$DNS_VER] Syntax");

# check if we need to do any initial conections
# use temp vars to avoid a clobbering problem
# you would never pass a partial set from commandline, so we can do this
# in one go. 
#
# the existece of variables is shecked in the called sub

$PROMPT = "no server > " ; 
# success changes the prompt

if ( $S_ID ) {
   &add_server($S_ID,"user",$S_USER,"password",$S_PASS);
}

# if ( $S_ID ) { &add_server($S_ID) }
# else         { $PROMPT = "no server > " ; }
# 
# if ( $S_PASS ) { &add_pass($S_PASS) }

#
# are we interactive or in batch mode ?
#
if ( ! $CONFIG ) {
   print "CLI version\n";
   $CLI = 1 ;
   # unflush the buffer
   $| = 1 ;

   # set initial prompt
   &print_prompt ;
}

if ( $CONFIG ) { 
   # make 'while(<>)' still work...
   push @ARGV , $CONFIG  ;
}

#
# time to read commands, line at a time...
#

while (<>) {

   # strip blanks, comments etc
   if ( /^\s*#/ ) { 
      if ( $MAKE ) { print $_ ; }
         &print_prompt ; 
         next ; 
   } ;

   if ( /^\s*$/ ) { 
      if ( $MAKE ) { print $_ ; }
         &print_prompt ; 
         next ; 
   } ;

   $GOOD_COMMAND = 1 ;
   $SAVE_HIST = "" ;

   chomp ;

   #
   # Pattern matching, we want 'fuzzy' matches but only in the form of
   # abbreviations, if the command is 'server', 'ser' and 'serv' should
   # match but not 'serf'. FORTUNATELY, there seems to be a perlmodule
   # for this. ( Text::Abbrev )
   #
   # and the nice thing is that we can build up a hash
   # of command to subroutine matching, the abbrev code will
   # find the right command to call, then we can pass the WHOLE line to
   # the required routine.
   #
   # HOWEVER, the additional args at the end of the line will break the
   # abbrev match, so we still need to eat the line - 1 word at a time
   # and branch apropriately
   #
   # if the abbrev gets an ambiguous match, we return '0'...

   # we have a problem in that if we get a match on the first arg we are
   # still in 2 states
   #  - execute
   #  - check for more args
   #  - check for more commands
   #
   # after the branching we still keep track of :
   #  - the original command (for history)
   #  - the optional args
   # and IF WE GET A MATCH, we say the command is good and THEN execute


   # SO break the commandline into components
   #
   # @WORDS is a global, because we want to keep eating the array
   # regardless of what routine we are in. At the end of the parsing, we
   # should end up with the command ($SAVE_HIST) and the args (@WORDS)
   #
   # SO, if there are more args that need to be checked, the subroutine
   # to call should be a simple one that just resets $commands and makes
   # another call to 'shift_Arg'
   #
   $LINE = $_ ;
   @WORDS  = split /\s+/ ;
   @P_ARGS = () ;
   my $arg = shift @WORDS ;

   &shift_arg($arg,%commands);

   # history - if kosher
   # ( done at the end, after all other line processing... )
   if ( $GOOD_COMMAND ) {
      &addhistory($SAVE_HIST , @WORDS);
   }

   # lastly - the prompt
   &print_prompt ;
   
}

# just in case
&do_exit ;

################################################################

# 
# EXIT
#
sub do_exit {
    $LINE = "exit" ;
    if ( $CONNECTED ) { 
#        &commit ;
       &disconnect ;
    }

    if ( $MAKE ) { &script_footer }

    exit ;
}

#
# shift arg, once we've set up a new %commands hash
# we just want to call shift_arg to do the rest of the processing
#
# THIS is the guts of the command line parser, for each ARG in a line
# shift_arg looks at this word, does an apprev match, and if it is ok
# then calles the hashed subroutine.
#
# The nice thing about this is that the subroutines can either be end
# points (do this feature) or subroutines that set possibilities for the
# next arg value. This has more power then putting ALL the commands in a
# treed hash since we can jump around tween subs as much as we like
#
# [ you just have to keep track of the parser subroutines :-) ]
#
sub shift_arg {

   my ( $arg , %commands ) = @_ ;

   if ( $LIST_COMM ) { &walk_tree(%commands) ; return ; }


   @CLIST = sort keys %commands ;
   my %clookup = abbrev ( @CLIST ) ;

   # $full_comm does the abbreviation lookup and gets the
   # ACTUAL full comand name, or returns '0' so the expansion
   # is automatic, but sometimes full_comm can be a wildcard
   # so we check the existence of the subroutine to call instead.
   #
   # and we hack history accordingly
   
   my $full_comm = $clookup{ lc($arg) };
   &debug (4,"shift: h($SAVE_HIST) arg($arg) com[$full_comm]");

   # we set $call_sub , coz we risk re-setting $full_com ;
   my $call_sub = $commands{$full_comm} ;
   if ( $call_sub ) {
      &debug (4,"shift: sub($call_sub)");

      # catch wildcards...
      if ( ! $full_comm ) { 
         $full_comm = $arg  ;
         push @P_ARGS , $arg ;
      }
      $SAVE_HIST .= "$full_comm " ;

      &rd_line($call_sub) ;
   }
   else {
      &missing_arg(@CLIST)  ;
   }
}

# parse a line, this is called EVERYTIME we press <cr> so we can
# do things like print the prompt
# we abstract this to keep it in one place
#
sub rd_line {

    # we're passed :
    #  the subroutine to call
    #  the subroutine arguments
    #
    #  if we are eating more of the args, we append to savehistory...

    my ($command) = @_ ;

    &debug (4,"rd_line b: c[$command] h[$SAVE_HIST] , go_c [$GOOD_COMMAND]");
    &debug (4,"           p_args[@P_ARGS] words[@WORDS]");

    # call the command (and any prev args...)
    &$command(@P_ARGS,@WORDS);

    #
    &debug (4,"rd_line a: c[$command] h[$SAVE_HIST] , go_c [$GOOD_COMMAND]");
    &debug (4,"           p_args[@P_ARGS] words[@WORDS]");


}

sub walk_tree {
   my ( %commands ) = @_ ;

   foreach my $cmd ( sort keys %commands ) {
      my $call = $commands{$cmd};

      &debug(1,"arg : $cmd => ($call) [@LIST_BRANCH] [$cmd]");

      # a few sanity checks
      if ( $cmd eq "" ) { $cmd = "<value>" ; }
      if ( $cmd eq "set" ) { next ; }
      if ( $cmd eq "remove" ) { next ; }

      push ( @LIST_BRANCH , $cmd ) ;

      if ( $call =~ /commands/ ) {
         &$call("foo","foo");
      }

      if ( @LIST_BRANCH ) { print "@LIST_BRANCH\n"; }

      pop @LIST_BRANCH ;
   }
}


# PARSER : show xxx
sub show_commands {
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                'zone' => 'show_zone',
                'network' => 'show_network',
                'host' => 'show_host',
                'version' => 'show_version',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : download xxx
sub download_commands {
   &debug (4,"sub = download_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "database" => 'get_database',
#                 "logs" => 'get_logs',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : upload xxx
sub upload_commands {
   &debug (4,"sub = upload_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
#                 "database" => 'put_database',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set xxx
#
# note, 'conf dhcp' (for the present) == 'conf network'
sub set_commands {
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                'debug' => 'set_debug',
                'server' => 'add_server',
#                 'system' => 'system_commands',
                'password' => 'add_pass',
                'zone' => 'zone_commands',
                'realm' => 'realm_commands',
                'network' => 'network_commands',
                'dhcp' => 'network_commands',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : set system xxx
sub system_commands {
   &debug (4,"sub = system_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
#                 "default" => 'erase_data',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf realm xxx
sub realm_commands {
   &debug (4,"sub = realm_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_realm',
                "delete" => 'remove_realm',
                "remove" => 'remove_realm',
                "" => 'mod_realm_commands',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf zone xxx
sub zone_commands {
   &debug (4,"sub = zone_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_zone',
                "delete" => 'remove_zone',
                "remove" => 'remove_zone',
                "" => 'mod_zone_commands',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network xxx
sub network_commands {
   &debug (4,"sub = network_commands");
   my ( $arg ) = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_network',
                "delete" => 'remove_network',
                "remove" => 'remove_network',
#                 "global" => 'mod_global_dhcp',
                "" => 'set_network_commands',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network <n.n.n.n/mm> xxx
sub set_network_commands {
   &debug (4,"sub = set_net ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "split" => 'split_network',
                "add" => 'add_to_network_commands',
                "remove" => 'delete_from_network_commands',
                "delete" => 'delete_from_network_commands',
                "modify" => 'modify_network',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network <n.n.n.n/mm> add xxx
sub add_to_network_commands {
   &debug (4,"sub = add_to_network ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "fixed" => 'add_fixed_address',
                "network" => 'add_sub_network',
                "range" => 'add_dhdprange',
                "dhcprange" => 'add_dhdprange',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : set network <n.n.n.n/mm> delete xxx
sub delete_from_network_commands {
   &debug (4,"sub = delete_from_network ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "fixed" => 'del_fixed_address',
                "range" => 'del_dhcprange',
                "dhcprange" => 'del_dhcprange',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf realm <realm> xxx
sub mod_realm_commands {
   &debug (4,"sub = mod_realm ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_to_realm_commands',
                "delete" => 'remove_from_realm_commands',
                "remove" => 'remove_from_realm_commands',
                "modify" => 'modify_realm_commands',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf zone <zone> xxx
sub mod_zone_commands {
   &debug (4,"sub = mod_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "add" => 'add_to_zone_commands',
                "delete" => 'remove_from_zone_commands',
                "remove" => 'remove_from_zone_commands',
                "import" => 'import_to_zone',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> modify xxx
sub modify_realm_commands {
   &debug (4,"sub = modify_realm ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "user" => 'mod_realm_opt',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> modify user xxx
sub mod_realm_opt {
   &debug (4,"sub = mod_realm_opt ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "" => 'modify_realm_user',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> modify user <user> xxx
sub modify_realm_user {
   &debug (4,"sub = mod_realm_usr ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "add" => 'modify_realm_user_add',
                "delete" => 'modify_realm_user_delete',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> modify user <user> add xxx
sub modify_realm_user_add {
   &debug (4,"sub = mod_realm_usr_add ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "attribute" => 'modify_realm_user_add_att',
        ) ;
   &shift_arg($arg,%commands);

}

sub modify_realm_user_delete {
   &debug (4,"sub = mod_realm_usr_del ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "attribute" => 'modify_realm_user_del_att',
        ) ;
   &shift_arg($arg,%commands);

}

# PARSER : conf realm <realm> add xxx
sub add_to_realm_commands {
   &debug (4,"sub = add_to_realm ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "attribute" => 'add_attrib_to_realm',
                "user" => 'add_user_to_realm',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf zone <zone> add xxx
sub add_to_zone_commands {
   &debug (4,"sub = add_to_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "host" => 'add_host',
                "cname" => 'add_cname',
                "a" => 'add_a_rec',
                "ptr" => 'add_zone_ptr',
                "bulkhost"   => 'add_bulkhost',
                "nameserver" => 'NOT_READY',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf zone <zone> remove xxx
sub remove_from_zone_commands {
   &debug (4,"sub = remove_from_zone ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "host" => 'remove_host',
                "cname" => 'remove_cname',
                "bulkhost" => 'remove_bulkhost',
                "a" => 'remove_a_rec',
                "ptr" => 'del_zone_ptr',
                "nameserver" => 'NOT_READY',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : conf realm <realm> remove xxx
sub remove_from_realm_commands {
   &debug (4,"sub = remove_from_realm ($SAVE_HIST)(@P_ARGS)(@WORDS)");

   my $arg  = shift @WORDS ;
   my %commands = ( 
                "user" => 'remove_user_from_realm',
                "attribute" => 'remove_attrib_from_realm',
        ) ;
   &shift_arg($arg,%commands);
}

# PARSER : default
sub NOT_READY {
    print "***-  NOT IMPLEMENTED\n";
}

###########################################
#
# here endith the arg parsers
#
###########################################

# 2 functions here (and more damn globals - hmm...)
# do_pub_conn calls the public function
# do_priv_conn calls the priv function

# sub do_pub_conn {
#     my ( $ib_call , @fargs ) = @_ ;
#     &debug (1,"do_pub_conn ($ib_call) [@fargs]");
# 
#     # format the data for pretty printing
#     my $fstring = &format_ib_func($ib_call,@fargs);
# 
#     if ( ! $MAKE ) { 
#        my $result ;
# 
#        ($result, $SESS_CONN) = &$ib_call ( { @fargs } ) ;
#     }
# }

#
# call an infoblox function, ONLY if we're connected
#
sub do_pub_func {

    # assume we are passed a single hash
    #
    my ( $ib_call , %hash ) = @_ ;
    &debug (1,"do_pub_func ($ib_call)");

    # format the data for pretty printing
    my $hash_ptr = \%hash ;
    my $fstring = &format_ib_func($ib_call,$hash_ptr);

    if ( ! $MAKE ) {
       # actually try and run it
       if ( $CONNECTED ) {
          # type cast correctly and prepend the SESSION
#           my $result = &$ib_call ( $PUB_SESS , { @fargs } ) ;
          my $result = &$ib_call ( $PUB_SESS , $hash_ptr ) ;
       }
       else {
          &err_print("CANNOT EXECUTE - no connection is in place");
       }

    }
}

sub do_priv_func {
    # private functions need a different session handler
    my ( $ib_call , $key_ptr , $mod_ptr ) = @_ ;
    &debug (1,"do_priv_func ($ib_call)");

    # format the data for pretty printing
    my $fstring = &format_ib_func($ib_call,$key_ptr,$mod_ptr);

    if ( ! $MAKE ) {
       # actually try and run it
       if ( $CONNECTED ) {
          # type cast correctly and prepend the SESSION
          my ( $res , $info ) = &$ib_call ( $PRI_SESS , $key_ptr , $mod_ptr ) ;
       }
       else {
          &err_print("CANNOT EXECUTE - no connection is in place");
       }

    }
}

sub do_nothing {
    my ( $ib_call , @fargs ) = @_ ;
    &debug (1,"do_nothing ($ib_call) [@fargs]");

    # format the data for pretty printing
    my $fstring = &format_ib_func($ib_call,@fargs);

    if ( ! $MAKE ) {
          &err_print("CANNOT EXECUTE - NOT IMPLEMENTED");
    }
}

sub format_ib_func {

    my ( $ib_call , @fargs ) = @_ ;

#     my $p_args ;
    my $p_comm ;

#     my %arg_hash = @fargs ;
#     my $syntax = &dump_hash( 0 , "HASH" , %arg_hash );
#     my $syntax = &dump_hash( 0 , "ARRAY" , @fargs );

    # V3 code passes args as a hash or many hashes

    my $syntax ;
    foreach my $ptr ( @fargs ) {
       my %hash = %{ $ptr } ;

       # format each hash
       $syntax .= &dump_hash( 0 , "HASH" , %hash );
    }

#     print "my (\$result, \$message) = $ib_call ( \$SESSION ,\n $syntax";
    $p_comm = "my \$result = $ib_call ( \$SESSION ,\n $syntax    );\n\n";
#     print "    );\n\n";


#     # format the data if we are V2 or V3
#     if ( $DNS_VER == 2 ) {
#        $p_args = join ( '","' , @fargs );
#        $p_comm = "$ib_call (\"$p_args\")";
#     }
#     if ( $DNS_VER == 3 ) {
#        my %hargs = @fargs ;
#        # pretty print a hash (errk)
#        foreach my $key ( sort keys %hargs ) {
#           $p_args .= "\t\"$key\"\t=> \"$hargs{$key}\",\n";
#        }
#        $p_comm = "$ib_call (\$session, {\n$p_args\t});\n";
#     }

    # do we pring out code instead...
    if ( $MAKE ) {
       print "\nprint '" . $ib_call . "'.\"\\n\";\n" ;

       print "$p_comm ;\n" ;
    }

    # return the formatted string (in case we need it)
    return ( $p_comm );
}


###########################################
#
# actual API functions.
#
###########################################

# sub get_logs {
#     #
#     # download the logs to the current dir
#     #
#     my ( $dest ) = @_ ;
# #     chomp($dest = `pwd`);
# #     $dest="$dest/IB_files";
#     if ( ! $dest ) {
#        &missing_arg("<dir>")  ;
#        return ;
#     }
# 
#     &err_print("DOWNLOADING ALL LOGS data to $dest ...");
#     if ( ! -d $dest ) { mkdir($dest,0755); }
# 
#     my @function = ("ib_export_logs",$dest);
#     &do_nothing(@function);
# 
#     &err_print("DONE ");
# 
# }

sub get_database {
    #
    # download the database to the current dir
    #
    my ( $dest ) = @_ ;
#     chomp($dest = `pwd`);
#     $dest="$dest/IB_files";
    if ( ! $dest ) {
       &missing_arg("<dir>")  ;
       return ;
    }

    &err_print("DOWNLOADING ALL DATABASE data to $dest ...");
    if ( ! -d $dest ) { mkdir($dest,0755); }

    my %opthash ;
    $opthash{'path'}=$dest;

#     # build the rest ad name value pairs
#     while ( my $key = shift @type_opts ) {
#        my $value = shift @type_opts ;
#        $opthash{$key} = $value ;
#     }

    my @function = ("backup_system",%opthash);

    &do_pub_func(@function);

    &err_print("DONE ");

}

# sub put_database {
#     #
#     # upload the database from the spec'd dir
#     #
#     my ( $dest ) = @_ ;
#     if ( ! $dest ) {
#        &missing_arg("<dir>")  ;
#        return ;
#     }
# 
#     &err_print("UPLOADING ALL DATABASE data from $dest ...");
#     if ( ! -d $dest ) { 
#        &err_print("NO such location");
#        return ;
#     }
# 
#     my @function = ("ib_import_database" , $dest ) ;
#     &do_nothing(@function);
# 
#     &err_print("DONE ");
# 
#     # do an implicit disconnect
#     &disconnect ;
# 
# }

# sub erase_data {
# 
#     &err_print("ERASING ALL DATABASE data ...");
# 
#     # we may want an 'are you sure here...'
#     my @function = ("ib_erase_dns_data");
#     &do_nothing(@function);
# 
#     &err_print("DONE ");
# }

sub import_to_zone {
    my ( $zone , $ip , $opt ) = @_ ;
    if ( ! $ip ) {
       &missing_arg("<ip> [noptr]")  ;
       return ;
    }

    &debug (2,"importing z($zone) ip($ip) ");

    my @function = ("ib_import_zone",$zone,$ip,$opt);
    &do_nothing(@function);

}

sub add_host {
    my ( $zone , $host , $ip , $comment ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }
    my $name="$host.$zone";

    &debug (2,"addh n($name) n($ip) c($comment)");

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'name'}=$host;
    $opthash{'comment'}=$comment;

    # add the IP address
    push @{ $opthash{"address_list"} } , {( "address" , $ip )};

    my @function = ("add_host",%opthash);

    &do_pub_func(@function);

}

sub remove_host {
    my ( $zone , $host ) = @_ ;
    if ( ! $host ) {
       &missing_arg("<host>")  ;
       return ;
    }
    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'name'}=$host;

    my @function = ("remove_host",%opthash);
    &debug (2,"addh n($host) ");

    &do_pub_func(@function);

}

sub add_a_rec {
    my ( $zone , $host , $ip , $comment ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'name'}=$host;
    $opthash{'address'}=$ip;
    $opthash{'comment'}=$comment;

    &debug (2,"add1h n($host) n($ip) ");

    my @function = ("add_rr_a",%opthash);
    &do_pub_func(@function);

}

sub remove_a_rec {
    my ( $zone , $host , $ip ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<host> <ip>")  ;
       return ;
    }

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'name'}=$host;
    $opthash{'address'}=$ip;

    &debug (2,"add1h n($host) n($ip) ");

    my @function = ("remove_rr_a",%opthash);
    &do_pub_func(@function);

}

sub add_bulkhost {
    my ( $zone , $prefix , $fip , $lip , $comment ) = @_ ;

    if ( $zone and $prefix and $fip and $lip ) {

       &debug (2,"addbh n($zone) p($prefix) n($fip,$lip) ");

       my %opthash ;
       $opthash{'zone'}=$zone;
       $opthash{'prefix'}=$prefix;
       $opthash{'start_address'}=$fip;
       $opthash{'end_address'}=$lip;
       $opthash{'comment'}=$comment;

       my @function=("add_bulk_host",%opthash);
       &do_pub_func(@function);
    }
    else {
       &missing_arg("<prefix> <start_ip> <end_ip>")  ;
       return ;
    }

}

sub remove_bulkhost {
    my ( $zone , $prefix , $fip , $lip ) = @_ ;

    if ( $zone and $prefix and $fip and $lip ) {

       &debug (2,"addbh n($zone) p($prefix) n($fip,$lip) ");

       my %opthash ;
       $opthash{'zone'}=$zone;
       $opthash{'prefix'}=$prefix;
       $opthash{'start_address'}=$fip;
       $opthash{'end_address'}=$lip;

       my @function=("remove_bulk_host",%opthash);
       &do_pub_func(@function);
    }
    else {
       &missing_arg("<prefix> <start_ip> <end_ip>")  ;
       return ;
    }
}

sub add_cname {
    my ( $zone , $alias , $cname , $comment ) = @_ ;
    if ( (! $alias ) or ( ! $cname ) ) {
       &missing_arg("<alias> <cname>")  ;
       return ;
    }

    &debug (2,"addh a($alias) cn($cname) ");

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'alias'}=$alias;
    $opthash{'canonical_name'}=$cname;
    $opthash{'comment'}=$comment;

    my @function=("add_rr_cname",%opthash);
    &do_pub_func(@function);

}

sub remove_cname {
    my ( $zone , $alias ) = @_ ;
    if ( ! $alias ) {
       &missing_arg("<alias>")  ;
       return ;
    }

    &debug (2,"addh n($alias) ");

    my %opthash ;
    $opthash{'zone'}=$zone;
    $opthash{'alias'}=$alias;

    my @function=("remove_rr_cname",%opthash);
    &do_pub_func(@function);

}

sub add_zone {

    # [ ] need a post cli deeper arg parser
    # essentially all options are passed as name value pairs
    # after the required options
    # so we pass this array to an abbrev validator that looks at each
    # second word and abbrev/expands and validates
    # 
    # the validator has to be passed an array, and a list of keywords
    # (ARRG!! - 2 arrays...)
    # 
    # for the moment we'll not bother to validate

    my ( $zone , $type , @type_opts) = @_ ;

    if ( ! $zone ) { &missing_arg("<zone>") ; return }

    #
    # etype is the expanded version of whatever we typed for $type
    # We'll only allow authorative zones for present
    #
    my $etype ;
    if ( $type ) {
#        my @opts = ( "authoritative","delegated","secondary");
       my @opts = ( "Authoritative");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
    else { ( $etype = "Authoritative" ) ; }

    # format the type opts
    # ..... (code goes here) ...

    &debug (2,"addz n($zone) a($etype) oo(@type_opts)");

    my %opthash ;
    $opthash{'name'}=$zone;
    $opthash{'type'}=$etype;
    $opthash{'parent_zone'}=".";

    my @function=("add_zone",%opthash);
    &do_pub_func(@function);

}

sub remove_zone {
    my ( $zone ) = @_ ;
    if ( ! $zone ) { &missing_arg("<zone>") ; return }
    &debug (2,"remz n($zone)");

    my %opthash ;
    $opthash{'name'}=$zone;
    $opthash{'parent_zone'}=".";

    my @function=("remove_zone",%opthash);
    &do_pub_func(@function);

}

# sub mod_global_dhcp {
#     my ( $opt , $val , @extra ) = @_ ;
#     if ( (! $val ) or ( ! $opt ) ) {
#        &missing_arg("<option> <value>")  ;
#        return ;
#     }
#     # clean up any custom option args
#     my $custom= join ( '","' , @extra );
# 
#     # clean some options
#     $val=~s/["']*//g ;
#     $custom=~s/""/"/g ;
# 
#     &debug (2,"modglob o($opt) v($val) c($custom)");
# 
#     #
#     # GLOBAL custom props have to ALL be on one line, or stuff gets dropped
#     #
#     # ib_modify_global_dhcp_options
#     #         ("10.34.8.0","255.255.252.0","router","10.34.8.1");
#     # OR
#     # ib_modify_global_dhcp_options
#     #         ("10.54.0.0","255.255.252.0","custom_option",
#     #           "netbios-name-servers","","10.23.60.20");
#     my $comm="ib_modify_global_dhcp_options";
#     my @function=($comm,$opt,$val);
# 
#     if ( $opt eq "custom_option" ) {
#        @function=($comm,"custom_option",$val,$custom);
#     }
#        
# 
#     &do_pub_func(@function);
# 
# }

sub modify_network {

    # THIS IS A PRIVATE FUNCTION...
    #
    my ( $parent , $opt , @opt_args ) = @_ ;

    if ( (! $opt ) or ( ! @opt_args ) ) {
       &missing_arg("<option> <arg> [arg]")  ;
       return ;
    }
    # clean up the netmask
    my ($net,$cidr) = split(/\//,$parent) ;
    my $mask = &cidrfind($cidr) ;

    # so we are forced to use the same crappy arg parser that was
    # in the 2.x code.. unless we can get clever, but different args
    # require more or less options and the setting of flags
    # [ ]
    # first order pass we will only accept one option per command,
    # but you can call this command many times

    my $eopt ;
    if ( $opt ) {
       my @opts = ( "name_servers","custom","routers","lease_time");
       my %optlist = abbrev ( @opts ) ;
       $eopt = $optlist{ lc($opt) } ;

       if ( ! $eopt ) { 
          &missing_arg(@opts);
          return ;
       }
    }

#     # clean some options
#     $val=~s/["']*//g ;
#     $custom=~s/["']*//g ;

    &debug (2,"modnet n($net) m($mask) o($eopt) a(@opt_args)");

    # build the hash
    my %keyhash ;
    $keyhash{"address"} = $net;
    $keyhash{"netmask"} = $mask;

    my %opthash ;
    $opthash{"address"} = $net;
    $opthash{"netmask"} = $mask;

    # dammit - i hate doing this... this gets fixed if it is not private
    if ( $eopt eq "name_servers" ) {
       $opthash{"override_domain_servers"} = "true";
       my $pos = 0 ;
       foreach my $lopt ( @opt_args ) {
          push @{ $opthash{"domain_name_server_list"} } ,
                  {( "position" , $pos, 
                     "address" , $lopt )};
          $pos++ ;
      }

    }
    elsif ( $eopt eq "lease_time" ) {
       $opthash{"lease_time"} = shift @opt_args;
       $opthash{"override_lease_time"} = "true";
    }
    elsif ( $eopt eq "routers" ) {
       $opthash{"override_routers"} = "true";
       my $pos = 0 ;
       foreach my $lopt ( @opt_args ) {
          push @{ $opthash{"router_list"} } ,
                  {( "position" , $pos, 
                     "address" , $lopt )};
          $pos++ ;
      }
    }
    # custom options
    elsif ( $eopt eq "custom" ) {
       $opthash{"override_custom_options"} = "true";
       my ( $option , $value ) = @opt_args ;
       my $name = &rename_custom_option ( $option ) ;

          push @{ $opthash{"network_custom_option_list"} } ,
                  {( "name" , $name, 
                     "value" , $value )};
    }

    # careful here - we need 2 hashes... key and mod
    my $kptr = \%keyhash ;
    my $optr = \%opthash;

    my @function=("update_network",$kptr,$optr);
     
    &do_priv_func(@function);
}

sub add_fixed_address {
    my ( $network , $ip , $mac , $comment ) = @_ ;
    if ( (! $ip ) or ( ! $mac ) ) {
       &missing_arg("<ip> <mac>")  ;
       return ;
    }
    &debug (2,"addfix n($network) ip($ip) mac($mac) c($comment)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'ip_address'}=$ip;
    $opthash{'mac_address'}=$mac;
    $opthash{'comment'}=$comment;

    my @function=("add_fixed_address",%opthash);
    &do_pub_func(@function);

}

sub del_fixed_address {
    my ( $network , $ip ) = @_ ;
    if ( ! $ip  ) {
       &missing_arg("<ip>")  ;
       return ;
    }
    &debug (2,"remfix ip($ip)");

    # we don't actually eed the network value...

    my %opthash ;
    $opthash{'ip_address'}=$ip;

    my @function=("remove_fixed_address",%opthash);
    &do_pub_func(@function);

}

sub add_zone_ptr {
    my ( $network , $ip , $host , $comment ) = @_ ;
    if ( (! $host ) or ( ! $ip ) ) {
       &missing_arg("<ip> <host>")  ;
       return ;
    }
#     my ($net,$cidr) = split(/\//,$parent) ;
#     my $mask = &cidrfind($cidr) ;

    &debug (2,"addnp n($network) ip($ip) h($host)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'name'}=$ip;
    $opthash{'host'}=$host;
    $opthash{'comment'}=$comment;

    my @function=("add_rr_ptr",%opthash);
    &do_pub_func(@function);

}

sub del_zone_ptr {
    my ( $network , $ip , $host ) = @_ ;
    if ( ( ! $ip ) or ( ! $host ) ) {
       &missing_arg("<ip> <host>")  ;
       return ;
    }
    &debug (2,"remnp n($network) ip($ip) ho($host)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'name'}=$ip;
    $opthash{'host'}=$host;

    my @function=("remove_rr_ptr",%opthash);
    &do_pub_func(@function);

}

sub add_dhdprange {
    my ( $network , $fip , $lip , $type , @type_opts ) = @_ ;
    if ( (! $fip ) or ( ! $lip ) ) {
       &missing_arg("<first_ip> <last_ip>")  ;
       return ;
    }

    &debug (2,"addrng n($network) s($fip) e($lip) t($type) oo(@type_opts)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'start_address'}=$fip;
    $opthash{'end_address'}=$lip;

    # parse optional extra arguments

    my $etype ;
    if ( $type ) {
       my @opts = ( "peer_association");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype || ! @type_opts ) { 
          &missing_arg(@opts , "<name>" );
          return ;
       }

       # set the hash
       $opthash{$etype}="@type_opts";

    }

    my @function=("add_dhcp_range",%opthash);
    &do_pub_func(@function);

}

sub del_dhcprange {
    my ( $network , $fip , $lip ) = @_ ;
    if ( ( ! $fip ) or ( ! $lip )  ) {
       &missing_arg("<first_ip> <last_ip>")  ;
       return ;
    }

    # we don't need the network..
    &debug (2,"remrng n($network) s($fip) e($lip)");

    my %opthash ;
    $opthash{'start_address'}=$fip;
    $opthash{'end_addresss'}=$lip;

    my @function=("remove_dhcp_range",%opthash);
    &do_pub_func(@function);

}

sub add_network {
    my ( $network , $comment ) = @_ ;
    if ( ! $network ) { 
            &missing_arg("<n.n.n.n/mm>") ; 
            return 
    }

    &debug (2,"addn n($network) c($comment)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'comment'}=$comment;

    my @function=("add_network",%opthash);
    &do_pub_func(@function);

}


sub remove_network {
    my ( $network ) = @_ ;
    if ( ! $network ) { &missing_arg("<n.n.n.n/mm>") ; return }

    &debug (2,"remn n($network)");

    my %opthash ;
    $opthash{'network'}=$network;

    my @function=("remove_network",%opthash);
    &do_pub_func(@function);

}

sub split_network {
    #
    # the split arg of split_network is a bitshift RELATIVE
    # to the original mask, so there is some math involved
    #
    # splitting either creates ALL networks or only the ones
    # we have to have (which could be none)

    my($network,$ncidr,$type) = @_ ;

    # the bitshift code will change, so we calc for now until it 
    # becomes redundant
    my($pnet,$pcidr)= split(/\//,$network );
       $ncidr =~ s/\/// ;
    my $bitshift = $ncidr - $pcidr ;
#     my $pmask = &cidrfind($pcidr);

    &debug (3,"split net [$pnet] [$pcidr] [$ncidr] ($bitshift)\n");
    &debug (2,"split net ($network) nb ($ncidr)");

    my %opthash ;
    $opthash{'network'}=$network;
    $opthash{'subnet_bits'}=$bitshift;

    # check for optional args...
    my $etype ;
    if ( $type ) {
       my @opts = ( "all","required");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;

       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
    }
#     else { 
#          # don't add networks
#          $opthash{'add_all_sunetworks'} = "false" 
#     }

    if ( $etype eq "required" ) { 
            $opthash{'add_all_sunetworks'} = "false" 
    }
    if ( $etype eq "all" ) { 
            $opthash{'add_all_sunetworks'} = "true" 
    }

    my @function=("split_network",%opthash);
    &do_pub_func(@function);

}

sub add_sub_network {
    my ( $network , $subnet ) = @_ ;
    if ( ! $subnet ) { &missing_arg("<n.n.n.n/mm>") ; return }

    &debug (2,"addsn pn($network) n($subnet)");

    my %opthash ;
    $opthash{'network'}=$subnet;
    $opthash{'network_container'}=$network;

    my @function=("add_subnetwork",%opthash);
    &do_pub_func(@function);

}

##########################################################
#
# RADIUS commands
#
##########################################################

sub add_realm {
    my ( $realm , @type_opts) = @_ ;

    # only "name" is required
    if ( ! $realm ) { &missing_arg("<realm>") ; return }

    &debug (2,"addrm n($realm) oo(@type_opts)");

    #
    # type_opts is a list of name value pairs, we just eat these into a
    # hash and shove them into the request
    #

    # format the type opts
    my %opthash ;
    $opthash{'name'}=$realm;

    # build the rest ad name value pairs
    while ( my $key = shift @type_opts ) {
       my $value = shift @type_opts ;
       $opthash{$key} = $value ;
    }

    my @function = ("RADIUSOne::realm_insert",%opthash);

    &do_pub_func(@function);

}

sub remove_realm {
    my ( $realm ) = @_ ;

    # only "name" is required
    if ( ! $realm ) { &missing_arg("<realm>") ; return }

    &debug (2,"delrm n($realm)");

    my %opthash ;
    $opthash{'name'}=$realm;

    my @function = ("RADIUSOne::realm_delete",%opthash);

    &do_pub_func(@function);

}

# add an attribute to a realm
sub add_attrib_to_realm {
    #
    my ( $realm , $type , $name , $value ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "check","reply");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    &debug (2,"add2r n($realm) t($type) et($etype) ($name)=($value)");

    if ( ! $etype ) { 
       &missing_arg(@opts);
       return ;
    }

    if ( ! $name or ! $value ) { 
       &missing_arg("<name> <value>");
       return ;
    }

    # convert opts to a hash
    my %opthash;
    $opthash{'name'}=$realm;
    $opthash{'check_reply'}=$etype;
    $opthash{'attribute'}=$name;
    $opthash{'value'}=$value;

    my @function = ("RADIUSOne::realm_av_pair_insert",%opthash);
    &do_pub_func(@function);

}

# delete an attribute to a realm
sub remove_attrib_from_realm {
    #
    my ( $realm , $type , $name , $value ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "check","reply");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    &debug (2,"add2r n($realm) t($type) et($etype) ($name)=($value)");

    if ( ! $etype ) { 
       &missing_arg(@opts);
       return ;
    }

    if ( ! $name or ! $value ) { 
       &missing_arg("<name> <value>");
       return ;
    }

    # convert opts to a hash
    my %opthash;
    $opthash{'name'}=$realm;
    $opthash{'check_reply'}=$etype;
    $opthash{'attribute'}=$name;
    $opthash{'value'}=$value;

    my @function = ("RADIUSOne::realm_av_pair_delete",%opthash);
    &do_pub_func(@function);

}

# add an user to a realm
sub add_user_to_realm {
    #
    my ( $realm , $name , $popt , $passwd ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "password");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($popt) } ;

    &debug (2,"add2r n($realm) n($name) p($popt) ep($etype) ($passwd)");

    if ( ! $name ) { 
       &missing_arg("<name>");
       return ;
    }

    # convert opts to a hash
    my %opthash;

    $opthash{'realm'}=$realm;
    # default user ?
    if ( $name =~ /^default$/i ) {
       $opthash{'default'}="true";
    }
    else {
       # check for password
       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
       if ( ! $passwd ) { 
          &missing_arg("<password>");
          return ;
       }

       # set values
       $opthash{'default'}="false";
       $opthash{'name'}=$name;
       $opthash{'user_password'}=$passwd;
    }

    my @function = ("RADIUSOne::radius_user_insert",%opthash);
    &do_pub_func(@function);

}

# remove an user to a realm
sub remove_user_from_realm {
    #
    my ( $realm , $name ) = @_ ;

    &debug (2,"del2r n($realm) n($name)");

    if ( ! $name ) { 
       &missing_arg("<name>");
       return ;
    }

    # convert opts to a hash
    my %opthash;

    $opthash{'realm'}=$realm;
    # default user ?
    if ( $name =~ /^default$/i ) {
       $opthash{'default'}="true";
    }
    else {
       # set values
       $opthash{'default'}="false";
       $opthash{'name'}=$name;
    }

    my @function = ("RADIUSOne::radius_user_delete",%opthash);
    &do_pub_func(@function);

}

sub modify_realm_user_add_att {
    #
    my ( $realm , $name , $type , $att , $value ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "check","reply");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    &debug (2,"modru r($realm) n($name) t($type) et($etype) ($att)=($value)");

    if ( ! $etype ) { 
       &missing_arg(@opts);
       return ;
    }

    if ( ! $name or ! $value ) { 
       &missing_arg("<name> <value>");
       return ;
    }

    # convert opts to a hash
    my %opthash;
    $opthash{'realm'}=$realm;
    $opthash{'check_reply'}=$etype;
    $opthash{'attribute'}=$att;
    $opthash{'value'}=$value;

    # is this the default user ?
    $opthash{'default'}="false";
    if ( $name =~ /^default$/i ) {
       $opthash{'default'}="true";
    }
    else {
       $opthash{'radius_user'}=$name;
    }


    my @function = ("RADIUSOne::user_av_pair_insert",%opthash);
    &do_pub_func(@function);

}

sub modify_realm_user_del_att {
    #
    my ( $realm , $name , $type , $att , $value ) = @_ ;

    # syntax check next arg...
    my $etype ;
    my @opts = ( "check","reply");
    my %optlist = abbrev ( @opts ) ;
    $etype = $optlist{ lc($type) } ;

    &debug (2,"modru r($realm) n($name) t($type) et($etype) ($att)=($value)");

    if ( ! $etype ) { 
       &missing_arg(@opts);
       return ;
    }

    if ( ! $name or ! $value ) { 
       &missing_arg("<name> <value>");
       return ;
    }

    # convert opts to a hash
    my %opthash;
    $opthash{'realm'}=$realm;
    $opthash{'check_reply'}=$etype;
    $opthash{'attribute'}=$att;
    $opthash{'value'}=$value;

    # is this the default user ?
    $opthash{'default'}="false";
    if ( $name =~ /^default$/i ) {
       $opthash{'default'}="true";
    }
    else {
       $opthash{'radius_user'}=$name;
    }


    my @function = ("RADIUSOne::user_av_pair_delete",%opthash);
    &do_pub_func(@function);

}

##########################################################
#
# An important thing to note :
#
# what happens if you issue commands and you do NOT have a connection in
# place yet ? do we rely on the infoblox module to generate errors or
# should we assume the worst ? we don't want to re-invent the wheel
# here...
#
#


###########################################3
#

sub missing_arg {
    &debug(4,"MISS ARG call");
    if ( $CLI ) {
       print "Next possible completions : \n\t@_\n";
    }
    else {
       &err_print("UNRECOGNISED command");
    }
    $GOOD_COMMAND = 0 ;
}

#
# PROMPT
#
sub print_prompt {
    if ( $CLI ) {
       print "[$DEBUG] $CONN_STRING $PROMPT" ;
    }
}

#
# ERRORS
#
sub err_print {
    if ( $CLI ) {
       print "@_\n" ;
    }
    else {
       # comment if making..
       if ( $MAKE ) { print "# " }
       print "@_ : $LINE\n";
    }
}

#
# SET DEBUG
#
sub set_debug {

    if ( "@_" =~ /\d+/ ) {
       $DEBUG = shift @_ ;
    }
    else {
       &missing_arg("$SAVE_HIST <level>");
    }
}

#
# SHOW THE HISTORY:
#

sub addhistory {
    my ($line) = "@_" ;

    #cleanup spacing
    $line =~ s/^\s*//;
    $line =~ s/\s+/ /g;
    $line =~ tr/A-Z/a-z/;

    push @HISTORY , $line ;

}

sub show_history {
    my $lineno = 1 ;

    # walk through the history array and print what we input
    print "\n-- COMMAND HISTORY --\n";
    foreach my $command ( @HISTORY ) {
       print "-- $lineno\t$command\n";
       $lineno ++ ;
    }
    print "\n";

#     $GOOD_COMMAND = 1 ;

}

#
# SERVER CONNECTION STUFF.....
#

sub add_server {
    my ($type,@args) = @_ ;
    # save the server id and see if we have enough info to connect
    # password can be passed on this line, if not specified, assume
    # no password

    # [ ] there seems to be too much code here, sone time in the future
    # i will work out what i can remove

    &debug (2,"adding server args[@args]");

    # if the server arg is NOT an ip address it is a type
    my $IPRE = '\d+\.\d+\.\d+\.\d+';

    my ( $server , $pass , $user , $junk ) ;

    # were we given an IP address or something else ?
    if ( $type !~ /^$IPRE$/) {

       # must be a server type, check the syntax
       # syntax check next arg...
       my $etype ;
       my @opts = ( "dns","radius");
       my %optlist = abbrev ( @opts ) ;
       $etype = $optlist{ lc($type) } ;
       if ( ! $etype ) { 
          &missing_arg(@opts);
          return ;
       }
       
       # otherwise, we're good
       ( $server , $junk , $user , $junk , $pass ) = @args ;

       $CONN_INFO{'cli_type'}=$etype ;

    }
    else {
       ( $server , $junk , $user , $junk , $pass ) = ($type, @args ) ;
    }
    &debug (2,"adding server t[$type] s($server) p($pass) u($user)");

    # ok - now eat the rest of the data
    
    if ($server) {
       # if we're already connected, sput an error
       if ( ! $CONNECTED ) {
          &debug (2,"adding server [$server]");
          $CONN_INFO{'Host'} = $server ;

          $PROMPT = "$CONN_INFO{'UserNAme'}\@$CONN_INFO{'Host'} > " ;

          # when you specify a new server, you need to re-set the
          # password
          if ( $pass ) {
             $CONN_INFO{'UserPassword'} = $pass ;
          }
          else {
             # this is a NON DNSone, DIG only
             # unset the password
             $CONN_INFO{'UserPassword'} = "" ;
          }
          &debug (2,"adding passwd [$pass]");

          if ( $user ) {
             # this is a v3 system
             $CONN_INFO{'UserName'} = $user ;
          }
          &debug (2,"adding user [$user]");

          &connect ;
       }
       else {
          &err_print("SERVER :: already connected");
       }
    }
    else {
       &missing_arg("$SAVE_HIST <server>");
    }
}

sub add_pass {
    my ($passwd) = @_ ;

    if ($passwd) {
       # save the server password and see if we have enough info to connect
       &debug (2,"adding passwd [$passwd]");
       $CONN_INFO{'UserPassword'} = $passwd ;

       # attepmt to connect
       &connect ;
    }
    else {
       &missing_arg("$SAVE_HIST <password>");
    }


}

#
# [ ] really need 2 routines here, one for batch mode and one for calls
# to 'connect' from the cli
#
#
sub connect {
    # make a connection
    # unless we have both server and password,  die

      if ( $CONN_INFO{'Host'} 
           && $CONN_INFO{'UserName'}
           && $CONN_INFO{'UserPassword'} ) {

         if ( $CONNECTED ) {
            &err_print("SERVER :: already connected");
            return ;
         }

         # now set up the correct hashes for connection
         my %priv_hash;
         $priv_hash{'HostIP'} = $CONN_INFO{'Host'};
         $priv_hash{'UserName'} = $CONN_INFO{'UserName'};
         $priv_hash{'UserPassword'} = $CONN_INFO{'UserPassword'};
         $priv_hash{'HostPort'} = "443";
         $priv_hash{'Secure'} = "true";

         &debug (1,"conn ->[$CONN_INFO{'Host'}] [$CONN_INFO{'UserName'}]");

         &err_print("SERVER :: connecting");

         # set the global PUB_SESS or PRIV_SESS
         # which we will call later

         if ( $CONN_INFO{'cli_type'} eq 'radius' ) {
            if ( $MAKE ) {
               # pretty print the hash 
               my $fst = &format_ib_func("RADIUSOne::server_session_create"
                                          ,%CONN_INFO);
            }
            else {
               my $res ;
               ($res,$PUB_SESS)=RADIUSOne::server_session_create(%CONN_INFO);
            }
         }
         else {
            # pretty print the hash 

            if ( $MAKE ) {
               # format the data for pretty printing
               my $fst=&format_ib_func("Infoblox::Session->new",%CONN_INFO);
               my
               $fst=&format_ib_func("Infoblox::InfobloxSession->new",%priv_hash);
            }
            else {
               $PUB_SESS = Infoblox::Session->new( %CONN_INFO );
               $PRI_SESS = Infoblox::InfobloxSession->new( %CONN_INFO );
            }
         }

         $PROMPT = "$CONN_INFO{'Host'} > " ;
         $CONN_STRING = "*" ;
   
         $CONNECTED = 1 ;

      }
      else {
         &err_print ("CANNOT CONNECT :: no server or password supplied");
         &debug (3,"NOOP - incomplete details for server connection");
      }

}

sub disconnect {

    &err_print ( "Disconnect :: depricated");

    if ( $CONNECTED ) {
#        &commit ;
#        ib_close_connection();
#    [ ] restart service ??
       $CONNECTED = 0 ;

       $PROMPT = "no server > " ;
    }
#     else {
#        &err_print ( "CANNOT DISCONNECT - no connection is in place");
#     }

}

sub commit {

    #
    # call 'publish changes' ??
    #
#     &err_print ( "COMMIT -  NOT WORKING");

    if ( $CONNECTED ) {
       print "SERVER :: Committing Changes .. ";

       ib_close_connection();
       sleep 3 ;
       ib_open_connection($CONN_INFO{'Host'},$CONN_INFO{'UserPassword'}) ;

#        ib_update_server();

       print "DONE.\n";

       $CONN_STRING = " " ;
    }
    else {
       &err_print ("CANNOT COMMIT - no connection is in place");
    }
}

#
# DIGS AND GET ROUTINES
#

sub show_host {
    my ($query,$verbose) = @_ ;

    # use dig...

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <host> (verbose)") ;
       return (0) ;
    }

    &debug (2,"showing zone [@_]");

    &do_dig($CONN_INFO{'Host'},$query,$verbose);


}

sub show_zone {
    my ($query,$type,$verbose) = @_ ;

    # use dig...
    # forget about the verbose option for now, dig can do that directly.

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <zone> (type)") ;
       return (0) ;
    }

    &debug (2,"showing zone [@_]");

    if ( ! $type ) { $type = "SOA" }

    &do_dig($CONN_INFO{'Host'},$query,$type,$verbose);
}

sub show_network {
    my ($query,$type,$verbose) = @_ ;

    # use dig...
    # forget about the verbose option for now, dig can do that directly.

    if ( ! $query ) {
       &missing_arg("$SAVE_HIST <network> (type)") ;
       return (0) ;
    }

    &debug (2,"showing network [@_]");

    if ( ! $type ) { $type = "SOA" }

    # force a revrse lookup
    $verbose = "reverse" ;
    &do_dig($CONN_INFO{'Host'},$query,$type,$verbose);
}

sub do_dig {
    # use a 'dig' to get zone data.
#     my $DIG = '/usr/bin/dig' ;
    my $DIG = 'dig' ;
    my $DIGOPTS = '+multiline +nostat +nocmd +norecur';
    my $TERSEOPTS = '+noquestion +noauthority +noadditional +nocomments';
    my $REVOPTS = '+noquestion +noadditional +nocomments';

    my $V_DIG = "$DIG $DIGOPTS";
    my $T_DIG = "$DIG $DIGOPTS $TERSEOPTS";
    my $R_DIG = "$DIG $DIGOPTS $REVOPTS";

    # so we pass args to dig to work out what type of dig to do
    &debug (3,"dig reqest =  [@_]");
    my ($server,$query,$type,$verbose) = @_ ;

    my $COMM ;

    # verbose is disabled for now, i'll use it for something else.
    if ($verbose) {
       $COMM = "$V_DIG \@$server $query $type";
       if ( $verbose eq "reverse" ) {
          $COMM = "$R_DIG \@$server -x $query $type";
       }
    }
    else {
       $COMM = "$T_DIG \@$server $query $type";
    }

    &debug (2,"dig comm =  [$COMM]");

#     if ( ! $CONNECTED ) {
#        &err_print( "CANNOT dig - no connection is in place");
#     }
#     else {
#        print "\n";
#        system("$COMM");
#        print "\n";
#     }

    print "\n";
    system("$COMM");
    print "\n";

}

# ib_open_connection(\$SERVER_ID,\$SERVER_PASS);
sub script_header {

    print "#!/usr/bin/perl
#
# AUTOGENERATED from $NAME 
#
\n";
print "use InfoBloxDNS ;\n";
print "use Infoblox::RADIUSOne;\n";
print "use Infoblox::InfobloxDNS;\n";
print "\n";

}

sub script_footer {

    print "

exit ; \n";

}

sub show_version {
    print "$REV\n";
}


############################################3


sub rename_custom_option {
  # remap some variables
    my $option = shift;
    my %lookup = (
        "1" => "Option  1: subnet-mask",
        "2" => "Option  2: time-offset",
        "3" => "Option  3: router",
        "4" => "Option  4: time-servers",
        "5" => "Option  5: ien116-name-servers",
        "6" => "Option  6: dns_server",
        "7" => "Option  7: log-servers",
        "8" => "Option  8: cookie-servers",
        "9" => "Option  9: lpr-servers",
        "10" => "Option  10: impress-servers",
        "11" => "Option  11: resource-location-servers",
        "12" => "Option  12: host-name",
        "13" => "Option  13: boot-size",
        "14" => "Option  14: merit-dump",
        "15" => "Option  15: default_domain",
        "16" => "Option  16: swap-server",
        "17" => "Option  17: root-path",
        "18" => "Option  18: extensions-path",
        "19" => "Option  19: ip-forwarding",
        "20" => "Option  20: non-local-source-routing",
        "21" => "Option  21: policy-filter",
        "22" => "Option  22: max-dgram-reassembly",
        "23" => "Option  23: default-ip-ttl",
        "24" => "Option  24: path-mtu-aging-timeout",
        "25" => "Option  25: path-mtu-plateau-table",
        "26" => "Option  26: interface-mtu",
        "27" => "Option  27: all-subnets-local",
        "28" => "Option  28: broadcast_address",
        "29" => "Option  29: perform-mask-discovery",
        "30" => "Option  30: mask-supplier",
        "31" => "Option  31: router-discovery",
        "32" => "Option  32: router-solicitation-address",
        "33" => "Option  33: static-routes",
        "34" => "Option  34: trailer-encapsulation",
        "35" => "Option  35: arp-cache-timeout",
        "36" => "Option  36: ieee802-3-encapsulation",
        "37" => "Option  37: default-tcp-ttl",
        "38" => "Option  38: tcp-keepalive-interval",
        "39" => "Option  39: tcp-keepalive-garbage",
        "40" => "Option  40: nis-domain",
        "41" => "Option  41: nis-servers",
        "42" => "Option  42: ntp-servers",
        "43" => "Option  43: vendor-encapsulated-options",
        "44" => "Option  44: netbios-name-servers",
        "45" => "Option  45: netbios-dd-server",
        "46" => "Option  46: netbios-node-type",
        "47" => "Option  47: netbios-scope",
        "48" => "Option  48: font-servers",
        "49" => "Option  49: x-display-manager",
        "50" => "Option  50: dhcp-requested-address",
        "51" => "Option  51: lease_time",
        "52" => "Option  52: dhcp-option-overload",
        "53" => "Option  53: dhcp-message-type",
        "54" => "Option  54: dhcp-server-identifier",
        "55" => "Option  55: dhcp-parameter-request-list",
        "56" => "Option  56: dhcp-message",
        "57" => "Option  57: dhcp-max-message-size",
        "58" => "Option  58: dhcp-renewal-time",
        "59" => "Option  59: dhcp-rebinding-time",
        "60" => "Option  60: vendor-class-identifier",
        "61" => "Option  61: dhcp-client-identifier",
        "62" => "Option  62: nwip-domain",
        "63" => "Option  63: nwip-suboptions",
        "64" => "Option  64: nisplus-domain",
        "65" => "Option  65: nisplus-servers",
        "66" => "Option  66: tftp-server-name",
        "67" => "Option  67: boot_file",
        "68" => "Option  68: mobile-ip-home-agent",
        "69" => "Option  69: smtp-server",
        "70" => "Option  70: pop-server",
        "71" => "Option  71: nntp-server",
        "72" => "Option  72: www-server",
        "73" => "Option  73: finger-server",
        "74" => "Option  74: irc-server",
        "75" => "Option  75: streettalk-server",
        "76" => "Option  76: streettalk-directory-assistance-server",
        "77" => "Option  77: user-class",
        "78" => "Option  78: slp-directory-agent",
        "79" => "Option  79: slp-service-scope",
        "80" => "Option  80: option-80",
        "81" => "Option  81: fqdn",
        "82" => "Option  82: relay-agent-information",
        "83" => "Option  83: option-83",
        "84" => "Option  84: option-84",
        "85" => "Option  85: nds-servers",
        "86" => "Option  86: nds-tree-name",
        "87" => "Option  87: nds-context",
        "88" => "Option  88: option-88",
        "89" => "Option  89: option-89",
        "90" => "Option  90: option-90",
        "91" => "Option  91: option-91",
        "92" => "Option  92: option-92",
        "93" => "Option  93: option-93",
        "94" => "Option  94: option-94",
        "95" => "Option  95: option-95",
        "96" => "Option  96: option-96",
        "97" => "Option  97: option-97",
        "98" => "Option  98: uap-servers",
        "99" => "Option  99: option-99",
        "100" => "Option  100: option-100",
        "101" => "Option  101: option-101",
        "102" => "Option  102: option-102",
        "103" => "Option  103: option-103",
        "104" => "Option  104: option-104",
        "105" => "Option  105: option-105",
        "106" => "Option  106: option-106",
        "107" => "Option  107: option-107",
        "108" => "Option  108: option-108",
        "109" => "Option  109: option-109",
        "110" => "Option  110: option-110",
        "111" => "Option  111: option-111",
        "112" => "Option  112: option-112",
        "113" => "Option  113: option-113",
        "114" => "Option  114: option-114",
        "115" => "Option  115: option-115",
        "116" => "Option  116: option-116",
        "117" => "Option  117: option-117",
        "118" => "Option  118: subnet-selection",
        "119" => "Option  119: option-119",
        "120" => "Option  120: option-120",
        "121" => "Option  121: option-121",
        "122" => "Option  122: option-122",
        "123" => "Option  123: option-123",
        "124" => "Option  124: option-124",
        "125" => "Option  125: option-125",
        "126" => "Option  126: option-126",
        "127" => "Option  127: option-127",
        "128" => "Option  128: option-128",
        "129" => "Option  129: option-129",
        "130" => "Option  130: option-130",
        "131" => "Option  131: option-131",
        "132" => "Option  132: option-132",
        "133" => "Option  133: option-133",
        "134" => "Option  134: option-134",
        "135" => "Option  135: option-135",
        "136" => "Option  136: option-136",
        "137" => "Option  137: option-137",
        "138" => "Option  138: option-138",
        "139" => "Option  139: option-139",
        "140" => "Option  140: option-140",
        "141" => "Option  141: option-141",
        "142" => "Option  142: option-142",
        "143" => "Option  143: option-143",
        "144" => "Option  144: option-144",
        "145" => "Option  145: option-145",
        "146" => "Option  146: option-146",
        "147" => "Option  147: option-147",
        "148" => "Option  148: option-148",
        "149" => "Option  149: option-149",
        "150" => "Option  150: option-150",
        "151" => "Option  151: option-151",
        "152" => "Option  152: option-152",
        "153" => "Option  153: option-153",
        "154" => "Option  154: option-154",
        "155" => "Option  155: option-155",
        "156" => "Option  156: option-156",
        "157" => "Option  157: option-157",
        "158" => "Option  158: option-158",
        "159" => "Option  159: option-159",
        "160" => "Option  160: option-160",
        "161" => "Option  161: option-161",
        "162" => "Option  162: option-162",
        "163" => "Option  163: option-163",
        "164" => "Option  164: option-164",
        "165" => "Option  165: option-165",
        "166" => "Option  166: option-166",
        "167" => "Option  167: option-167",
        "168" => "Option  168: option-168",
        "169" => "Option  169: option-169",
        "170" => "Option  170: option-170",
        "171" => "Option  171: option-171",
        "172" => "Option  172: option-172",
        "173" => "Option  173: option-173",
        "174" => "Option  174: option-174",
        "175" => "Option  175: option-175",
        "176" => "Option  176: option-176",
        "177" => "Option  177: option-177",
        "178" => "Option  178: option-178",
        "179" => "Option  179: option-179",
        "180" => "Option  180: option-180",
        "181" => "Option  181: option-181",
        "182" => "Option  182: option-182",
        "183" => "Option  183: option-183",
        "184" => "Option  184: option-184",
        "185" => "Option  185: option-185",
        "186" => "Option  186: option-186",
        "187" => "Option  187: option-187",
        "188" => "Option  188: option-188",
        "189" => "Option  189: option-189",
        "190" => "Option  190: option-190",
        "191" => "Option  191: option-191",
        "192" => "Option  192: option-192",
        "193" => "Option  193: option-193",
        "194" => "Option  194: option-194",
        "195" => "Option  195: option-195",
        "196" => "Option  196: option-196",
        "197" => "Option  197: option-197",
        "198" => "Option  198: option-198",
        "199" => "Option  199: option-199",
        "200" => "Option  200: option-200",
        "201" => "Option  201: option-201",
        "202" => "Option  202: option-202",
        "203" => "Option  203: option-203",
        "204" => "Option  204: option-204",
        "205" => "Option  205: option-205",
        "206" => "Option  206: option-206",
        "207" => "Option  207: option-207",
        "208" => "Option  208: option-208",
        "209" => "Option  209: option-209",
        "210" => "Option  210: authenticate",
        "211" => "Option  211: option-211",
        "212" => "Option  212: option-212",
        "213" => "Option  213: option-213",
        "214" => "Option  214: option-214",
        "215" => "Option  215: option-215",
        "216" => "Option  216: option-216",
        "217" => "Option  217: option-217",
        "218" => "Option  218: option-218",
        "219" => "Option  219: option-219",
        "220" => "Option  220: option-220",
        "221" => "Option  221: option-221",
        "222" => "Option  222: option-222",
        "223" => "Option  223: option-223",
        "224" => "Option  224: option-224",
        "225" => "Option  225: option-225",
        "226" => "Option  226: option-226",
        "227" => "Option  227: option-227",
        "228" => "Option  228: option-228",
        "229" => "Option  229: option-229",
        "230" => "Option  230: option-230",
        "231" => "Option  231: option-231",
        "232" => "Option  232: option-232",
        "233" => "Option  233: option-233",
        "234" => "Option  234: option-234",
        "235" => "Option  235: option-235",
        "236" => "Option  236: option-236",
        "237" => "Option  237: option-237",
        "238" => "Option  238: option-238",
        "239" => "Option  239: option-239",
        "240" => "Option  240: option-240",
        "241" => "Option  241: option-241",
        "242" => "Option  242: option-242",
        "243" => "Option  243: option-243",
        "244" => "Option  244: option-244",
        "245" => "Option  245: option-245",
        "246" => "Option  246: option-246",
        "247" => "Option  247: option-247",
        "248" => "Option  248: option-248",
        "249" => "Option  249: option-249",
        "250" => "Option  250: option-250",
        "251" => "Option  251: option-251",
        "252" => "Option  252: option-252",
        "253" => "Option  253: option-253",
        "254" => "Option  254: option-254",
    );

    # fix it ?
    if ( $lookup{$option} ) {
       return ( $lookup{$option} );
    }
    else {
       return ( $option );
    }

}


sub cidrfind {
    # match up netmasks to cidr syntax
    # YES, i /KNOW/ i can do this using math, but this took me
    # 20 seconds with cut and paste and it works, so move along
    # there's nothing to see here.
    #  (besides, a hash lookup is probably faster)
    my ($cidr) = @_ ;
    my %mlook = (
       8 =>  '255.0.0.0' ,
       9 =>  '255.128.0.0' ,
       10 => '255.192.0.0' ,
       11 => '255.224.0.0' ,
       12 => '255.240.0.0' ,
       13 => '255.248.0.0' ,
       14 => '255.252.0.0' ,
       15 => '255.254.0.0' ,
       16 => '255.255.0.0' ,
       17 => '255.255.128.0' ,
       18 => '255.255.192.0' ,
       19 => '255.255.224.0' ,
       20 => '255.255.240.0' ,
       21 => '255.255.248.0' ,
       22 => '255.255.252.0' ,
       23 => '255.255.254.0' ,
       24 => '255.255.255.0' ,
       25 => '255.255.255.128' ,
       26 => '255.255.255.192' ,
       27 => '255.255.255.224' ,
       28 => '255.255.255.240' ,
       29 => '255.255.255.248' ,
       30 => '255.255.255.252' ,
    ) ;

    &debug(3,"CIDR is [$cidr]");
    &debug(3,"MASK is [$mlook{$cidr}]");

    return($mlook{$cidr}) ;
}

sub dump_hash {
    # recursively walk a data structure
    my ($depth,$type,@data) = @_ ;

    # we're going to stuff all this into a variable
    my $syntax ;

    # set the spacer
    my $spc ;
    for my $i ( 0 .. $depth ) { $spc .= "    " }

    # type dependent
    if ( $type eq "HASH" ) {
       my %hash = @data ;
       $syntax .= "$spc { \n";
       foreach my $key ( sort keys %hash ) {
          my $value = $hash{$key} ;

          # do we recurse or print ?
          if ( $value =~ /^HASH/ ) {
             $syntax .= "$spc '$key' => \n";
             $syntax .= &dump_hash ( $depth+1 , "HASH" , %{ $hash{$key} } );
          }
          elsif ( $value =~ /^ARRAY/ ) {
             $syntax .= "$spc '$key' => \n";
             $syntax .= &dump_hash ( $depth+1 , "ARRAY" , @{ $hash{$key} } );
          }
          else {
            $syntax .= "$spc '$key' => '$value',\n";
          }
       }
       $syntax .= "$spc }, \n";
    }

    elsif ( $type eq "ARRAY" ) {
       $syntax .= "$spc [\n";
       foreach my $value ( @data ) {
          if ( $value =~ /^HASH/ ) {
             $syntax .= &dump_hash ( $depth+1 , "HASH" , %{ $value } );
          }
          elsif ( $value =~ /^ARRAY/ ) {
             $syntax .= &dump_hash ( $depth+1 , "ARRAY" , @{ $value } );
          }
          else {
             $syntax .= "$spc'$value',\n";
          }
       }
       $syntax .= "$spc ], \n";
    }

    return ( $syntax ) ;

}

sub debug {
    # we're passed a message and a level
    # if this level is <= the CURRENT DEBUG level 
    # we print the data
    my $level = shift @_ ;


    if ($level <= $DEBUG) {
        if ( $MAKE ) { print "# " ; }
        print "($level) DEBUG: @_\n";
    }

}

###########################################################

# $Log: ibcli,v $
# Revision 2.0  2004/11/03 19:58:48  horne
# new code suporting the infoblox V3 API
# major rewrite
#
# Revision 1.18  2004/10/20 16:44:39  horne
# broken checkin - ignore
#
# Revision 1.17  2004/08/13 05:21:09  horne
# Added correct connection handling
#
# Revision 1.16  2004/08/13 03:57:45  horne
# Major changes to the arg parsers, args are now sent as arrays and the
#   do_ib_func does the formatting/prettyprinting
# Added conection syntax to hanvle V3 connections
# Added a whole bag of RADIUS commands
#
# Revision 1.15  2004/08/01 19:34:03  horne
# Added 'peer_assoc' support for V2.5
#
# Revision 1.14  2004/06/16 20:19:46  horne
# added comments to ptrs
# added modify global dhcp opts
#   conf dhcp global
# added fixed addresses
# added modify network options
#   conf net x.x.x.x/mm modify opt value
# added non-auth networks
#
# Revision 1.13  2004/02/13 20:11:21  horne
# added the command lister
#
# Revision 1.12  2003/11/26 01:29:09  horne
# *** empty log message ***
#
# Revision 1.11  2003/11/06 07:31:28  horne
# server and password now live on the same commandline
# upload and download database
# import zone
# conf zone add now takes additional options
#
# the software now writes its own code
#
# Revision 1.10  2003/10/16 21:41:25  horne
# un hardcoede dig
# changed password syntax
# added a -V -v option (version)
# added download commands
#
# Revision 1.9  2003/09/24 01:43:08  horne
# added dhcp range stuff
# cleaned up the dig pre-processing
#
# Revision 1.8  2003/09/22 21:37:30  horne
# added prt functions
# cleaned up show network
#
# Revision 1.7  2003/09/22 19:24:30  horne
# *** empty log message ***
#
# Revision 1.6  2003/09/21 23:04:29  horne
# added ambiguous commands
# prints now wrapped for cli or batch
# batch commands now work
#
# Revision 1.5  2003/09/20 01:22:36  horne
# First full working version with the abstracted argument parser.
# there is still a lot of gumpf in here, but most of the repeatable code is
# now packed into subroutines
#
# Revision 1.4  2003/09/18 02:28:56  horne
# *** empty log message ***
#
# Revision 1.3  2003/09/16 23:17:25  horne
# *** empty log message ***
#
# Revision 1.2  2003/09/09 22:58:27  horne
# *** empty log message ***
#
# Revision 1.1  2003/08/11 23:31:57  horne
# INFOBLOX version, re-set the CVS counters
#
# Revision 1.9  2001/06/07 16:45:47  horne
# major rewrite of the arg parser - ripped out all the RE's to a much better
# process.
# delete commands disabled
#
# Revision 1.8  2001/05/31 05:28:15  horne
# *** empty log message ***
#
# Revision 1.7  2001/05/24 00:17:54  horne
# Added RE's to handle shortened commant words, not however that this is
# still buggy, typos, as long as they are unique will still work. thus
#  - password, p , pa , ps , pdfgt = password
# I need to find a better command parser
#
# Revision 1.6  2001/05/23 19:39:11  horne
# working version - waiting for updates from infoblox to see if they have
# changed the API syntax
#
# Revision 1.5  2001/05/19 06:08:13  horne
# iblox ready version, but no connections to servers work
#
# Revision 1.4  2001/05/19 04:59:19  horne
# All base commands are being parsed and netmasks are being applied.
# Now we need to hit the infoblox engine for real
#
# Revision 1.3  2001/05/19 03:43:45  horne
# added the DEBUG option before i started to drown in a lot of messy print
# statements
#
# Revision 1.2  2001/05/19 03:34:34  horne
# Basic version, config file parsing is functional.
#
# Revision 1.1  2001/05/19 03:33:56  horne
# *** empty log message ***
#
