#!/usr/bin/perl
#
# (c) Copyright: Geoff horne, SLC 2001
#               All rights reserved
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS `AS IS' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. So there...
#
# THIS TICKET IS SOLD SUBJECT TO THE SELLERS CONDITIONS OF SALE OF COPY
# WHICH IS AVAILABLE FOR INSPECTION AT TIME OF PURCHASE AND/OR CONDITIONS
# OF THIS TICKET AND ALSO (TO THE EXTENT THAT THEY ARE NOT INCONSISTENt
# WITH THE SELLERS CONDITIONS OF SALE) THE FOLLOWING:
# 
# 1: A CHANGE IN CONDITIONS OF THE PURCHASER DOES NOT ENTITLE THE PURCHASER
#    TO RETURN OR EXCHANGE TICKET.
# 
# 2: THE SELLER RESERVES THE RIGHT TO:
#    - ADD, WITHDRAW OR SUBSTITUTE ARTISTS
#    - VARY ADVERTISED PROBRAMMES, SEATING ARRANGEMENT AND AUDIENCE
#      CAPACITY , AND:
#    - REFUSE ADMISSION WITH REASONABLE CAUSE
#
# 3: CAMERAS AND TAPE RECORDERS MAY NOT BE PERMITTED. LATE ARRIVALS MAY
#    RESULT IN NON-ADMITTANCE UNTIL A SUITABLE BREAK IN PERFORMANCE. THE
#    SELLER REQUESTS THAT ALL PAGERS AND MOBILE PHONES BE TURNED OFF BEFORE
#    ENTRY.
#
# 4: IF AN OUTDOOR PERFORMANCE IS CANCELLED DUE TO ADVERSE WEATHER OR ANy
#    OTHER CAUSE REASONABLY BEYOND THE SELLERS CONTROL, THERE IS NO RIGHT 
#    TO A REFUND OR EXCHANGE, AND THE SELLER IS NOT OBLIGED TO ARRANGE A 
#    SUBSTITUTE SERVICE, EVENT OR PERFORMANCE
#
# StreetLevel Communications
#
#            support@slc.com.au
#            ph: +1-650-483-0998
#
###############################################################################


# $Id: ibcli,v 1.3 2003/09/16 23:17:25 horne Exp $
# $Revision: 1.3 $
# $Date: 2003/09/16 23:17:25 $
#

# Perl CGI common chunks
#
use strict ;
no strict "refs" ;


# include infoblox
use InfoBloxDNS ;

#### work out where i am
# these 3 varables can then be used to find config files
# and keep the code portable

use FindBin qw($Bin $Script);
my ($BASE,$NAME)=($Bin,$Script) ;

######################
#
# define some globals
#
my $DEBUG = 0 ;
my $CLI = 0 ;
my $PROMPT = "no server > " ;
my $CONN_STRING = "!" ;
my $server_id ;
my $server_user ;
my $server_pass ;
my $CONNECTED ;
my $GOOD_COMMAND ;
my $NO_COMMAND ;
my @history ;

#
#####################

# read the lines
# the datastructure is kinda nested, but the command set is still small
# enough to avoid some sort of lexical overhead subroutine

## NOTE - to make a better CLI version we should have a wrapper loop that
#  checks if you are coming in as a file or STD in. The primary loop in
#  either case should pass to the actual arg parser
#

if ( ! @ARGV ) {
   print "CLI version\n";
   $CLI = 1 ;
   # unflush the buffer
   $| = 1 ;

   # set initial prompt
   &print_prompt ;
}

while (<>) {

   # strip blanks, comments etc
   if ( /^\s*#/ ) { &print_prompt ; next ; } ;
   if ( /^\s*$/ ) { &print_prompt ; next ; } ;

   $GOOD_COMMAND = 0;
   $NO_COMMAND = 1;

   chomp ;
   # now break the commandline into components
   my (@words) = split /\s+/ ;
   # we want to use 'shift' but keep the original words...
#    my @eatline = @words ;
   my $arg = shift @words ;

   #    &debug(1,"words : [$arg] @words");

   # you know, a case statement would work well here...
   #
   # when we call rd_line, we need to re-write the original command
   # so that it goes into history correctly
   #
   # we check HERE if a command has enough arguments, if not
   # then we need to sput an appropriate error
   #  - unrecognised (foo)
   #  - incomplete   (set ?)
   #  this will STOP us setting 'GOOD_COMMAND' inside EACH subroutine
   #  so we have the check the have enough args BEFORE we proceed
   #
   #  if we call rd_line, we ASSUME the command is good.

   
   # general commands
      # HISTORY
   if ($arg =~ /^H\w*/i)   { &rd_line("show_history","history",@words) }

      # commit
   if ($arg =~ /^COM\w*/i) { &commit               ; &addhistory($_) }

      # disconnect
   if ($arg =~ /^DIS\w*/i) { &disconnect          ; &addhistory($_) }

      # split
   if ($arg =~ /^SP\w*/i) {
      my $arg = shift @words ;
      # network
      if ($arg =~ /^N\w*/i) { &split_net(@words)  ; &addhistory($_) }
   }

   # 
   # if i REALLY get exotic i should be able to
   # abstract this loop into a hash of the form
   # { arg1 , subroutine }
   # BUT for the present, we'll keep it the way it is...
   #

   # set commands
   if ($arg =~ /^SE\w*/i) {
      $arg="set";
      &debug(1,"arg=[$arg]");

      if (@words) {
         my $arg1 = shift @words ;

         # DEBUG
         if ($arg1 =~ /^DEB\w*/i) { 
             $arg1 = "debug";
            if (@words) { &rd_line("set_debug","$arg $arg1",@words) }
            else        { &missing_arg("$arg $arg1 <level>"); }
         }

         # SERVER
         if ($arg1 =~ /^SER\w*/i) { 
             $arg1 = "server";
            if (@words) { &rd_line("add_server","$arg $arg1",@words) }
            else        { &missing_arg("$arg $arg1 <server>"); }
         }

         # PASSWORD
         if ($arg1 =~ /^P\w*/i) { 
             $arg1 = "password";
            if (@words) { &rd_line("add_pass","$arg $arg1",@words) }
            else        { &missing_arg("$arg $arg1 <password>"); }
         }

         # USER
         if ($arg1 =~ /^U\w*/i) { 
             $arg1 = "user";
            if (@words) { &rd_line("add_user","$arg $arg1",@words) }
            else        { &missing_arg("$arg $arg1 <user>"); }
         }
      }
      else        { &missing_arg("set ?"); }
   }


   # show commands
   if ($arg =~ /^SH\w*/i) {
      $arg="show";
      &debug(1,"arg=[$arg]");

      if (@words) {
          my $arg1 = shift @words ;

          # zone
          if ($arg1 =~ /^Z\w*/i)   { 
             $arg1 = "zone";
             if (@words) { &rd_line("get_zone","$arg $arg1",@words) }
             else        { &missing_arg("$arg $arg1 <zone>"); }
          }
          
          # network
          if ($arg =~ /^N\w*/i)   { 
             $arg1 = "network";
             if (@words) { &rd_line("get_zone","$arg $arg1",@words) }
             else        { &missing_arg("$arg $arg1 <1.2.3.4>"); }
          }
      }
      else        { &missing_arg("show <zone|network>"); }
      
   }
   
   # add
   if ($arg =~ /^A\w*/i) {
      &debug(1,"[$arg]=add");
      my $arg = shift @words ;
      # zone
      if ($arg =~ /^Z\w*/i)   { &add_zone(@words)   ; &addhistory($_) }
      # network
      if ($arg =~ /^N\w*/i)   { &add_net(@words)    ; &addhistory($_) }
      # subnet
      if ($arg =~ /^S\w*/i)   { &add_sub(@words)    ; &addhistory($_) }
      # host
      if ($arg =~ /^HO\w/i)    { &add_host(@words)   ; &addhistory($_) }
   }

   # delete
   if ($arg =~ /^DEL\w*/i) {
      my $arg = shift @words ;
      # network
      if ($arg =~ /^N\w*/i)  { &remove_net(@words)   ; &addhistory($_) }
      # host
      if ($arg =~ /^H\w*/i)  { &remove_host(@words)  ; &addhistory($_) }
      # zone
      if ($arg =~ /^Z\w*/i)  { &remove_zone(@words)  ; &addhistory($_) }
   }

   # no_command is only set if we didn't get something we recognised
   # this is just a lazy form of 'else'
   #
   if ( $NO_COMMAND ) {
      print "UNRECOGNISED :: $_\n";
      &print_prompt ;
   }

}

# just in case
if ( $CONNECTED ) { &disconnect } ;

exit ;

##########################################################
#
# An important thing to note :
#
# what happens if you issue commands and you do NOT have a connection in
# place yet ? do we rely on the infoblox module to generate errors or
# should we assume the worst ? we don't want to re-invent the wheel
# here...
#
#


###########################################3
#

# prompt
#
sub print_prompt {
    print "[$DEBUG] $CONN_STRING $PROMPT" ;
}

sub set_debug {
    if ( "@_" =~ /\d+/ ) {
       $DEBUG = shift @_ ;
#        $GOOD_COMMAND = 1 ;
    }
#     else {
#        &missing_arg("debug <level>");
#     }
}

# parse a line, this is called EVERYTIME we press <cr> so we can
# do things like print the prompt
# we abstract this to keep it in one place
sub rd_line {

    # we're passed :
    #  the subroutine to call
    #  the ORIGINAL LINE (post cleanup)
    #  the subroutine arguments

    my ($command,$hstring,@args) = @_ ;

    $NO_COMMAND = 0 ;

    # call the command
    &$command(@args);

    # history
    &addhistory("$hstring",@args);

    # prompt
    &print_prompt ;
    #
}

# show the history:
# &show_history ;

sub addhistory {
    my ($line) = "@_" ;

    #cleanup spacing
    $line =~ s/^\s*//;
    $line =~ s/\s+/ /g;
    $line =~ tr/A-Z/a-z/;

    push @history , $line ;

}


sub show_history {
    my $lineno = 1 ;

    # walk through the history array and print what we input
    print "\n-- COMMAND HISTORY --\n";
    foreach my $command ( @history ) {
       print "-- $lineno\t$command\n";
       $lineno ++ ;
    }
    print "\n";

    $GOOD_COMMAND = 1 ;

}

sub split_net {
    # this one assumes there is a parent
    # and thus requires some funky netmasking
    # so it takes more args , newmask

#     my ($net,$cidr) = split(/\//,$_[0] );
    my ($oldnet,$ncidr) = @_ ;
    my ($net,$cidr) = split(/\//,$oldnet );
    $ncidr =~ s/\/// ;
    my $mask = &cidrfind($cidr) ;
    my $bitshift = $ncidr - $cidr ;
    &debug (2,"split net [$net] [$cidr] [$ncidr] ($bitshift)\n");

    &debug (1,"splitting network [$net , $mask] to add [$bitshift] bits");

    # ib_split_network("10.0.0.0", "255.255.0.0", 8);
    ib_split_network("$net", "$mask", "$bitshift");
}

sub remove_net {
    # the split is done here in case we want to change the syntax
    my ($net,$cidr) = split(/\//,$_[0] );
    my $mask = &cidrfind($cidr) ;
    &debug (1,"removing network [$net] mask: [$mask]");

    ib_remove_network("$net","$mask");
}

sub add_net {
    # the split is done here in case we want to change the syntax
    my ($net,$cidr) = split(/\//,$_[0] );
    &debug (2,"adding network [$net] cidr: [$cidr]");

    my $mask = &cidrfind($cidr) ;
    &debug (1,"adding network [$net] mask: [$mask]");
    # add net now requires a bogus parent
    # not that this will add it at the root level. you need to
    # use add subnet for anything else
    ib_insert_network("$net","$mask","0.0.0.0","0.0.0.0");
}

sub add_sub {
    # add a subnet to a parent network ;
#     my ($net,$cidr) = split(/\//,$_[0] );
    my ($net,$cidr,$parent,$pcidr) = $_[0] =~ /(\S+)\/(\d+)\s+(\S+)\/(\d+)/ ;
    &debug (2,"adding subnet [$net] cidr: [$cidr]");
    &debug (2,"  to parent subnet [$parent] cidr: [$pcidr]");

    my $mask = &cidrfind($cidr) ;
    my $pmask = &cidrfind($pcidr) ;
    &debug (1,"NOOP adding subnet [$net, $mask] to: [$parent, $pmask]");

    ib_insert_network("$net","$mask","$parent","$pmask");
}

sub add_host {
    my ($name,$ip) = @_ ;
    &debug (1,"adding host [$name] [$ip]");
    ib_insert_host("$name","$ip");
}

sub remove_host {
    my ($name) = @_ ;
    &debug (1,"remove host [$name]");
    ib_remove_host("$name");
}

sub add_zone {
    # zones can be authoritative or not, we look to see
    # if the command has the 'auth' keyword after it
    my $isauth = "false" ;
    my ($zone,$auth) = @_ ;
    if ( $auth =~ /^aut/ ) { $isauth = "true" }

    &debug (1,"adding zone [$zone] [$isauth]");
     ib_insert_zone("$zone","$isauth");
}

sub remove_zone {
    my ($zone) = @_ ;
    &debug (1,"removing zone [$zone]");
    ib_remove_zone("$zone");
}


sub add_server {
    my ($arg) = @_ ;
    # save the server id and see if we have enough info to connect

    if ($arg) {
       &debug (2,"adding server [$arg]");
       $server_id = $arg ;

       $PROMPT = "$server_id > " ;

       &connect ;
    }
}

sub add_user {
    my ($arg) = @_ ;

    if ($arg) {
       # save the server user and see if we have enough info to connect
       &debug (2,"adding user [$arg]");
       $server_user = $arg ;
       &connect ;
    }
}

sub add_pass {
    my ($arg) = @_ ;

    if ($arg) {
       # save the server password and see if we have enough info to connect
       &debug (2,"adding passwd [$arg]");
       $server_pass = $arg ;
       &connect ;
    }
}

sub connect {
    # make a connection
    # unless we have both server and password die
    if ( $server_id && $server_pass && $server_user ) {
       &debug (1,"connecting to server [$server_id] [$server_pass]");

       print "SERVER :: connecting \n";

       ######
       print "Connections :: DISABLED \n";
       ######

#        ib_open_connection($server_id,$server_pass) ;

       my $ibc='ib_open_connection($server_id,$server_pass)';
       &debug (3,"ibc [$ibc]");
       eval $ibc ;

       $PROMPT = "$server_id > " ;
       $CONN_STRING = "*" ;

       $CONNECTED = 1 ;

    }
    else {
       &debug (3,"NOOP - incomplete details for server connection");
    }

}

sub disconnect {
    if ( $CONNECTED ) {
       &commit ;
       print "SERVER :: disconnecting \n";
       ib_close_connection();
       $CONNECTED = 0 ;
    }
    else {
       print "CANNOT DISCONNECT - no connection is in place\n";
    }

}

sub commit {
    if ( $CONNECTED ) {
       &debug (1,"comitting changes");
       print "SERVER :: Comitting Changes .. ";
       ib_update_server();
       print "DONE.\n";

       $CONN_STRING = " " ;
    }
    else {
       print "CANNOT COMMIT - no connection is in place\n";
    }
}

sub get_zone {
    # use dig...
    &debug (2,"getting zone [@_]");
    my ($query,$type,$verb) = @_ ;

    if ( ! $type ) { $type = "SOA" }

    if ( ! $server_id ) {
       print "CANNOT dig - no server is specified\n";
    }
    else {
       &do_dig($server_id,$query,$type,$verb);
    }


}

sub do_dig {
    # use a 'dig' to get zone data.
    my $DIG = '/usr/bin/dig' ;
    my $DIGOPTS = '+multiline +nostat +nocmd +norecur';
    my $TERSEOPTS = '+noquestion +noauthority +noadditional +nocomments';

    my $V_DIG = "$DIG $DIGOPTS";
    my $T_DIG = "$DIG $DIGOPTS $TERSEOPTS";

    # so we pass args to dig to work out what type of dig to do
    &debug (3,"dig reqest =  [@_]");
    my ($server,$query,$type,$verbose) = @_ ;

    my $COMM ;

    if ($verbose) {
       $COMM = "$V_DIG \@$server $query $type";
    }
    else {
       $COMM = "$T_DIG \@$server $query $type";
    }

    &debug (2,"dig comm =  [$COMM]");
    print "\n";
    system("$COMM");
    print "\n";


}

sub missing_arg {
    print "INCOMPLETE COMMAND :: @_\n";
    $GOOD_COMMAND = 0 ;
    $NO_COMMAND = 0 ;

    &print_prompt ;
}

############################################3

sub cidrfind {
    # match up netmasks to cidr syntax
    my ($cidr) = @_ ;
    my %mlook = (
       8 =>  '255.0.0.0' ,
       9 =>  '255.128.0.0' ,
       10 => '255.192.0.0' ,
       11 => '255.224.0.0' ,
       12 => '255.240.0.0' ,
       13 => '255.248.0.0' ,
       14 => '255.252.0.0' ,
       15 => '255.254.0.0' ,
       16 => '255.255.0.0' ,
       17 => '255.255.128.0' ,
       18 => '255.255.192.0' ,
       19 => '255.255.224.0' ,
       20 => '255.255.240.0' ,
       21 => '255.255.248.0' ,
       22 => '255.255.252.0' ,
       23 => '255.255.254.0' ,
       24 => '255.255.255.0' ,
       25 => '255.255.255.128' ,
       26 => '255.255.255.192' ,
       27 => '255.255.255.224' ,
       28 => '255.255.255.240' ,
       29 => '255.255.255.248' ,
       30 => '255.255.255.252' ,
    ) ;

    &debug(2,"CIDR is [$cidr]");
    &debug(2,"MASK is [$mlook{$cidr}]");

    return($mlook{$cidr}) ;
}

sub debug {
    # we're passed a message and a level
    # if this level is <= the CURRENT DEBUG level 
    # we print the data
    my $level = shift @_ ;

    if ($level <= $DEBUG) {
           print "DEBUG : @_\n";
    }

}

###########################################################

# $Log: ibcli,v $
# Revision 1.3  2003/09/16 23:17:25  horne
# *** empty log message ***
#
# Revision 1.2  2003/09/09 22:58:27  horne
# *** empty log message ***
#
# Revision 1.1  2003/08/11 23:31:57  horne
# *** empty log message ***
#
# Revision 1.9  2001/06/07 16:45:47  horne
# major rewrite of the arg parser - ripped out all the RE's to a much better
# process.
# delete commands disabled
#
# Revision 1.8  2001/05/31 05:28:15  horne
# *** empty log message ***
#
# Revision 1.7  2001/05/24 00:17:54  horne
# Added RE's to handle shortened commant words, not however that this is
# still buggy, typos, as long as they are unique will still work. thus
#  - password, p , pa , ps , pdfgt = password
# I need to find a better command parser
#
# Revision 1.6  2001/05/23 19:39:11  horne
# working version - waiting for updates from infoblox to see if they have
# changed the API syntax
#
# Revision 1.5  2001/05/19 06:08:13  horne
# iblox ready version, but no connections to servers work
#
# Revision 1.4  2001/05/19 04:59:19  horne
# All base commands are being parsed and netmasks are being applied.
# Now we need to hit the infoblox engine for real
#
# Revision 1.3  2001/05/19 03:43:45  horne
# added the DEBUG option before i started to drown in a lot of messy print
# statements
#
# Revision 1.2  2001/05/19 03:34:34  horne
# Basic version, config file parsing is functional.
#
# Revision 1.1  2001/05/19 03:33:56  horne
# *** empty log message ***
#
